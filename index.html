<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ellipsis LM</title>
    
    <!-- PWA and iOS Home Screen Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AI Storyteller">
    <link rel="apple-touch-icon" href="https://storage.googleapis.com/pai-images/22e56a81615f4e6691238e2124c6536b.png">

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;1,400&family=Dancing+Script:wght@700&family=EB+Garamond:ital,wght@0,400;1,400&family=Inter:wght@400;500;700&family=Lora:ital,wght@0,400;1,400&family=Nunito+Sans:ital,wght@0,400;1,400&family=Roboto+Slab:wght@400;700&family=Source+Code+Pro:ital,wght@0,400;1,400&display=swap" rel="stylesheet">

    <!-- Link to External Stylesheet -->
    <style>
	<!-- PASTE content of style.css HERE -->
:root {
    --font-primary: 'Inter', sans-serif;
    --text-primary: #e5e7eb;
    --text-secondary: #cbd5e1;
    --text-accent: #a5b4fc;
    
    --surface-glass: rgba(17, 24, 39, 0.15);
    --surface-card: rgba(55, 65, 81, 0.6);
    --surface-overlay: rgba(0, 0, 0, 0.4);
    
    --border-primary: var(--border-hue-color, rgba(75, 85, 99, 0.8));
    --border-hue-color: rgba(75, 85, 99, 0.8);
    --brand-color: #6366f1; /* Indigo */
    --brand-color-toggle: #4f46e5;
    
    --scrollbar-thumb: #4b5563;
    
    --border-radius-md: 0.75rem;
    --border-radius-sm: 4px;
    
    --transition-fast: 0.2s ease-in-out;
    --transition-medium: 0.4s ease-out;
    --transition-slow: 0.5s ease-in-out;

    /* New Appearance Variables */
    --chat-font-size: 16px;
    --bubble-image-size: 100px;
}

html, body {
    height: 100%;
    overflow: hidden;
}

body { 
    font-family: var(--font-primary); 
    color: #e5e7eb; 
}

/* Global styles for form elements to ensure readability on dark backgrounds */
input, textarea, select {
    color: var(--text-primary);
    background-color: rgba(0,0,0,0.7);
    border: 1px solid var(--border-primary);
}
input::placeholder, textarea::placeholder {
    color: #9ca3af; /* Tailwind gray-400 */
}
input:focus, textarea:focus, select:focus {
    outline: 2px solid var(--brand-color);
    outline-offset: -1px;
    border-color: var(--brand-color);
}


.glass-bg { 
    background-color: var(--surface-glass); 
    backdrop-filter: blur(5px); 
}

/* --- Scrollbar Styling --- */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { 
    background: var(--scrollbar-thumb); 
    border-radius: var(--border-radius-sm); 
}

/* --- Component Styling --- */
.character-card { 
    background-color: var(--surface-card); 
    backdrop-filter: blur(4px); 
    border: 1px solid var(--border-primary); 
    border-radius: var(--border-radius-md); 
}

.modal-overlay { 
    background-color: var(--surface-overlay); 
}

.toggle-bg:after { 
    content: ''; 
    position: absolute; 
    top: 0.125rem; 
    left: 0.125rem; 
    background-color: white; 
    border-radius: 9999px; 
    height: 1.25rem; 
    width: 1.25rem; 
    transition: transform var(--transition-fast); 
}

input:checked + .toggle-bg { 
    background-color: var(--brand-color-toggle); 
}

input:checked + .toggle-bg:after { 
    transform: translateX(100%); 
}

/* --- New Character Roster Button Styling --- */
.char-roster-btn {
    position: relative;
    background-size: cover;
    background-position: center 25%; /* Focus on the upper part of the image */
    border-radius: 0.75rem;
    overflow: hidden;
    aspect-ratio: 3 / 4;
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    border: 1px solid var(--border-primary);
    cursor: pointer;
}
.char-roster-btn:hover {
    transform: scale(1.03);
    box-shadow: 0 0 15px rgba(129, 140, 248, 0.4);
}
.char-roster-btn::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 70%;
    background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
    pointer-events: none;
}
.char-roster-content {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 1rem;
    z-index: 10;
}
/* --- End New Character Roster Button Styling --- */


/* --- Chat Components --- */
#chat-window {
    display: flex;
    flex-direction: column;
    align-items: center;
}
#chat-window h1, 
#chat-window h2, 
#chat-window h3 { 
    font-weight: bold; 
    margin-bottom: 0.0rem;
}
#chat-window h1 { font-size: 1.5em; } 
#chat-window h2 { font-size: 1.25em; } 
#chat-window h3 { font-size: 1.1em; }

#chat-window blockquote {
    border-left: 3px solid var(--brand-color);
    padding-left: 1rem;
    margin: 0.5rem 0;
    color: var(--text-secondary);
    font-style: italic;
    font-weight: bold;
}

#chat-window em {
    color: var(--text-accent);
    font-style: italic;
}

.chat-bubble-container {
    width: 100%;
    max-width: 1000px;
	align-content: center;
}

.bubble-header {
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0.25rem;
}

.bubble-header .timestamp {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.bubble-char-image {
    float: left;
    width: var(--bubble-image-size);
    height: auto;
    border-radius: 0.5rem;
    margin-right: 1rem;
    margin-bottom: 0.5rem;
}

.bubble-body { font-size: var(--chat-font-size); }
.bubble-body .whitespace-pre-wrap {
    overflow: hidden; /* BFC to contain the float */
    white-space: normal;
}
.bubble-body .whitespace-pre-wrap p {
    margin: 0;
    white-space: normal;
}
.bubble-body .whitespace-pre-wrap p + p {
    margin-top: 0.75em;
}

/* Style for scrolling memory lists */
#static-entries-list, #dynamic-entries-list {
    overflow-y: auto;
    /* max-height: 20rem; Corresponds to roughly 6-7 entries */
    min-height: 0; /* Important for flex/grid children to respect max-height */
}

/* --- Hover & Animation Effects --- */
.chat-bubble-container:hover .action-btn-group,
.chat-bubble-container:hover .timestamp { 
    opacity: 1; 
}

.action-btn-group, .timestamp { 
    opacity: 0; 
    transition: opacity var(--transition-fast);
}

#character-portrait-container img { 
    transition: opacity var(--transition-slow); 
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.chat-bubble-container.new-message {
    animation: fadeIn var(--transition-medium);
}

/* --- Layout Management & Responsiveness --- */

/* Default to Vertical/Mobile layout first */
#desktop-header { display: none; }
#mobile-header { display: flex; }

body.layout-vertical #app-container { padding: 0; }
body.layout-vertical #main-header { position: fixed; top: 0; left: 0; right: 0; z-index: 50; margin: 0; padding: 0.5rem; background: transparent; pointer-events: none; }
body.layout-vertical #hamburger-menu-button-container { opacity: 0.3; transition: opacity 0.3s ease; pointer-events: auto; }
body.layout-vertical #hamburger-menu-button-container:hover { opacity: 1; }
body.layout-vertical #mobile-story-title-overlay { position: fixed; top: 0; left: 0; width: 100%; z-index: 49; background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); padding: 1rem; text-align: center; opacity: 0; transition: opacity 0.3s ease; pointer-events: auto; }
body.layout-vertical #chat-window-container { justify-content: center; border-radius: 0; margin-bottom: 0 !important; }
body.layout-vertical #chat-window { width: 99%; }
body.layout-vertical #character-portrait-container { display: none; }
body.layout-vertical #chat-input-container { 
    padding: 1rem; 
    border-top: 1px solid;
	border-top-color: color-mix(in srgb, var(--chat-text-color) 50%, transparent);

}

/* Horizontal (Desktop) Layout Overrides */
body.layout-horizontal #desktop-header { display: flex; }
body.layout-horizontal #mobile-header { display: none; }
body.layout-horizontal #app-container { padding: 0.5rem; }
body.layout-horizontal #chat-window-container { justify-content: space-between; }
body.layout-horizontal #chat-window { width: 66.66%; }
body.layout-horizontal #character-portrait-container { display: flex; width: 33.33%; }
body.layout-horizontal #mobile-header-elements { display: none !important; }

/* --- Cinematic Mode Overhaul --- */
body[data-mode="cinematic_overlay"] #cinematic-bg-1,
body[data-mode="cinematic_overlay"] #cinematic-bg-2 {
    position: fixed;
    inset: 0;
    z-index: 0;
    background-size: cover;
    background-position: center;
}
body[data-mode="cinematic_overlay"] #app-container {
    background: transparent;
    backdrop-filter: none; /* Prevents containing the fixed-position background */
}
body[data-mode="cinematic_overlay"] main {
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* Pushes content to the bottom */
}
body[data-mode="cinematic_overlay"] #chat-window-container {
    flex-grow: 0; /* Prevent it from taking full height */
    height: 33.33vh;
    background: transparent;
    position: relative; /* For the gradient */
}
body[data-mode="cinematic_overlay"] #chat-window-container::before {
    content: '';
    position: absolute;
    top: -100px;
    left: 0;
    right: 0;
    height: 100px;
    background: linear-gradient(to bottom, transparent, rgba(17, 24, 39, 0.8));
    pointer-events: none;
    z-index: 20;
}
body[data-mode="cinematic_overlay"] #chat-window {
    background: transparent;
}
body[data-mode="cinematic_overlay"] #chat-input-container {
    background-color: rgba(17, 24, 39, 0.7); 
    backdrop-filter: blur(5px);
}
/* Specific fix for horizontal cinematic mode */
body.layout-horizontal[data-mode="cinematic_overlay"] #character-portrait-container {
    display: none;
}
body.layout-horizontal[data-mode="cinematic_overlay"] #chat-window {
    width: 100%; /* Take full width since side portrait is gone */
}

/* Make header float over cinematic background in horizontal mode */
body.layout-horizontal[data-mode="cinematic_overlay"] #main-header {
    position: absolute;
    top: 0.5rem;      /* Match app-container padding */
    left: 0.5rem;
    right: 0.5rem;
    z-index: 50;      /* Ensure it's on top of other elements */
    margin-bottom: 0; /* Override default margin */
    padding-top: 1rem;
	padding-left: 1rem;
    padding-right: 1rem;
    background: linear-gradient(to bottom, rgba(17, 24, 39, 0.6), transparent);
    border-radius: 0.75rem 0.75rem 0 0;
}

/* Styling for quoted dialogue in chat bubbles */
.dialogue-quote {
	filter: saturate(175%) opacity(75%) drop-shadow(1px 1px 5px black);
    font-weight: 500;          /* Makes the text slightly bolder than normal */
}

/* Push the first message bubble down from the top so that it's controls are accessible. */
#chat-window .chat-bubble-container:first-child {
    margin-top: 2rem; /* Adjust this value as needed */
}
	</style>
</head>
<body data-mode="none" class="bg-gray-900 min-h-screen flex flex-col">
    
    <!-- This is where the main user interface will be inserted. -->
    <!-- PASTE content of main_ui.html HERE -->
    <!-- Background Image Container -->
<div id="global-background" class="fixed inset-0 -z-10 bg-gray-900 bg-cover bg-center transition-all duration-500"></div>

<!-- Main Application Container -->
<div class="w-full h-full flex flex-col glass-bg" id="app-container">
    
    <!-- Header -->
    <header class="mb-4 flex justify-between items-center" id="main-header">
        <!-- Desktop Header -->
        <div id="desktop-header" class="justify-between items-center w-full">
            <input type="text" id="story-title-input" class="text-2xl font-bold bg-transparent text-white p-1 rounded focus:outline-none focus:bg-black/20 w-1/2">
            <div class="flex space-x-2">
                 <button onclick="Controller.openModal('story-library-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Story Library"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path><path d="M4 6h16M4 12h16M4 18h7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M18 18v-6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M15 12h6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button>
                 <button onclick="Controller.openModal('characters-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Characters"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21a6 6 0 00-9-5.197m0 0A5.965 5.965 0 0112 13a5.965 5.965 0 013 1.803"></path></svg></button>
                 <button onclick="Controller.openModal('world-map-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="World Map"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 9m-6 4v.01"></path></svg></button>
                 <button onclick="Controller.openModal('knowledge-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Knowledge"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253z"></path></svg></button>
                 <button onclick="Controller.checkWorldInfoAgent()" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Update Static Memory"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg></button>
                 <button onclick="Controller.openModal('settings-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Settings"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg></button>
            </div>
        </div>

        <!-- Mobile Header -->
        <div id="mobile-header" class="justify-end items-center w-full">
            <div class="relative" id="hamburger-menu-button-container">
                <button id="hamburger-menu-button" class="bg-gray-700/80 hover:bg-gray-600/80 text-white p-2 rounded-lg">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
                <div id="mobile-menu" class="hidden absolute right-0 mt-2 w-56 bg-gray-800/90 backdrop-blur-md rounded-lg shadow-xl z-50">
                    <a href="#" onclick="Controller.openModal('story-library-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Story Library</a>
                    <a href="#" onclick="Controller.openModal('characters-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Characters</a>
                    <a href="#" onclick="Controller.openModal('world-map-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">World Map</a>
                    <a href="#" onclick="Controller.openModal('knowledge-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Knowledge</a>
                    <a href="#" onclick="Controller.checkWorldInfoAgent(); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Update Static</a>
                    <div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Settings</div>
                    <a href="#" onclick="Controller.openSettingsToTab('appearance'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Appearance</a>
                    <a href="#" onclick="Controller.openSettingsToTab('prompt'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Prompt</a>
                    <a href="#" onclick="Controller.openSettingsToTab('model'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Model</a>
                </div>
            </div>
        </div>
    </header>
    <!-- /Header -->

    <div id="mobile-header-elements">
         <input type="text" id="mobile-story-title-overlay" class="text-xl font-bold text-white truncate text-center bg-transparent focus:bg-black/20 w-full">
    </div>

    <!-- Main Content Area -->
    <main class="flex-grow min-h-0 flex flex-col relative">
        <div id="title-trigger-area" class="absolute top-0 left-0 w-full h-16 z-40"></div>
         <!-- Chat Window & Portrait -->
         <div id="chat-window-container" class="relative flex-grow p-2 flex min-h-0 bg-black/30 rounded-lg overflow-hidden" style="
    padding-bottom: revert; padding-top: revert;">
            <div id="cinematic-bg-1" class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 pointer-events-none opacity-0"></div>
            <div id="cinematic-bg-2" class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 pointer-events-none opacity-0"></div>
            <div id="chat-window" class="relative z-10 flex-grow overflow-y-auto"></div>
            <div id="character-portrait-container" class="flex-shrink-0 flex-col justify-center items-center" style="padding-right: 0.5rem;"></div>
         </div>
         <!-- /Chat Window & Portrait -->
         
         <!-- Chat Input & Controls -->
         <div id="chat-input-container" class="flex items-start space-x-2 sm:space-x-4" style="padding: 1rem; border-top: 1px solid; border-top-color: 
 color-mix(in srgb, var(--chat-text-color) 50%, transparent);">
             <textarea id="chat-input" class="flex-grow bg-black/30 border border-gray-600 rounded-lg p-2 color: black" placeholder="Enter your message..." rows="4" style="color: var(--chat-text-color)" ></textarea>
             <div class="flex flex-col space-y-2">
                 <select id="ai-character-selector" class="bg-black/30 border border-gray-600 rounded-lg p-2 w-full mb-2"></select>
                 <div class="flex items-center justify-center space-x-1">
                     <button id="primary-action-btn" class="bg-indigo-600/50 hover:bg-indigo-600/80 text-white font-bold p-1.5 rounded-lg" title="Send / Write for Me"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></button>
                     <button id="regen-btn" class="bg-sky-600/40 hover:bg-sky-600/70 text-white font-bold p-1.5 rounded-lg" title="Regenerate / New Response"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 9a9 9 0 0114.65-5.32L20 5M20 15a9 9 0 01-14.65 5.32L4 19"></path></svg></button>
                     <button id="undo-btn" class="bg-gray-600/40 hover:bg-gray-500/70 text-white font-bold p-1.5 rounded-lg" title="Undo"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l4-4m-4 4l4 4"></path></svg></button>
                 </div>
             </div>
         </div>
         <!-- /Chat Input & Controls -->
    </main>
    <!-- /Main Content Area -->

</div>
<!-- /Main Application Container -->


    <!-- This is where all the modal dialogs and templates will be inserted. -->
    <!-- PASTE content of modals.html HERE -->
<!-- Modals -->
<!-- Story Library Modal -->
<div id="story-library-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('story-library-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh]">
        <div class="p-6 border-b border-gray-700 flex justify-between items-center">
            <h2 class="text-2xl font-semibold">Story Library</h2>
            <div class="flex space-x-2">
                <button onclick="Controller.openModal('io-hub-modal')" class="bg-teal-600/80 hover:bg-teal-700/80 text-white font-bold py-2 px-4 rounded-lg">Import / Export</button>
                <button onclick="Controller.createNewStory()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">New Story</button>
            </div>
        </div>
        <div id="library-content-container" class="flex-grow flex min-h-0"></div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
            <button onclick="Controller.closeModal('story-library-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button>
        </div>
    </div>
</div>

<!-- [NEW] Import/Export Hub Modal -->
<div id="io-hub-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('io-hub-modal')"></div>
    <div id="io-hub-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-4xl relative flex flex-col max-h-[90vh]">
        <!-- Content injected by UIManager.renderIOHubModal -->
    </div>
</div>

<!-- [NEW] Bulk Import Report Modal -->
<div id="report-modal" class="fixed inset-0 z-[70] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/60" onclick="Controller.closeModal('report-modal')"></div>
    <div id="report-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[90vh]">
        <!-- Content injected by UIManager.showBulkImportReport -->
    </div>
</div>

<!-- [NEW] Loading Spinner Overlay -->
<div id="loading-spinner" class="fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm flex-col items-center justify-center hidden" style="display: none;">
    <div class="w-16 h-16 border-4 border-t-indigo-500 border-gray-600 rounded-full animate-spin"></div>
    <p id="spinner-message" class="mt-4 text-white font-semibold">Loading...</p>
</div>


<!-- Story Details Modal (for mobile view) -->
<div id="story-details-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('story-details-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[90vh]"><div id="story-details-content-mobile" class="flex-grow flex flex-col min-h-0"></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('story-details-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Back to Library</button></div></div></div>

<!-- Characters Modal -->
<div id="characters-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('characters-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700 flex justify-between items-center"><h2 class="text-2xl font-semibold">Character Roster</h2><button onclick="Controller.addCharacter()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Character</button></div><div class="p-6 overflow-y-auto"><div id="characters-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('characters-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Individual Character Detail Modal -->
<div id="character-detail-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('character-detail-modal')"></div>
    <div id="character-detail-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[90vh]">
        <!-- Content will be injected by JS -->
    </div>
</div>

<!-- Knowledge Modal (Static & Dynamic) -->
<div id="knowledge-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
	<div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('knowledge-modal')">
	</div>
	<div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col h-[85vh]" style="width: 90%; max-width: 1200px;">
		<div class="p-6 pb-0 flex justify-between items-center border-b border-gray-700">
			<div class="flex">
				<button id="knowledge-tab-static" onclick="Controller.switchKnowledgeTab('static')" class="py-3 px-4 font-semibold text-lg border-b-2 border-indigo-500 text-white">Static</button>
				<button id="knowledge-tab-dynamic" onclick="Controller.switchKnowledgeTab('dynamic')" class="py-3 px-4 font-semibold text-lg border-b-2 border-transparent text-gray-400 hover:text-white">Dynamic</button>
			</div>
			<button id="knowledge-add-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg ml-4 flex-shrink-0">Add Entry</button>
		</div>
		<div class="p-6 overflow-y-auto flex-grow height: 100%">
				<div id="knowledge-static-content" class style="height: 100%">
					<div id="static-entries-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full">
						<div id="static-entries-list" class="md:col-span-1 bg-black/30 rounded-lg p-4"></div>
						<div id="static-entry-details" class="md:col-span-2 bg-black/30 rounded-lg p-4">
							<div id="static-entry-details-content" class="h-full">
								<div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div>
							</div>
						</div>
					</div>
				</div>
			<div id="knowledge-dynamic-content" class="hidden" class style="height: 100%">
				<div id="dynamic-entries-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full">
					<div id="dynamic-entries-list" class="md:col-span-1 bg-black/30 rounded-lg p-4 h-[26rem] md:h-full"></div>
					<div id="dynamic-entry-details" class="md:col-span-2 bg-black/30 rounded-lg p-4">
						<div id="dynamic-entry-details-content" class="h-full">
						<div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
			<button onclick="Controller.closeModal('knowledge-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
		</div>
	</div>
</div>

<!-- World Map Modal -->
<div id="world-map-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('world-map-modal')"></div>
    <div id="world-map-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh] min-h-[50vh]">
        <!-- Content injected by JS -->
    </div>
</div>

<!-- Settings Modal -->
<div id="settings-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('settings-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[90vh]"><div class="p-6 pb-0 border-b border-gray-700"><h2 class="text-2xl font-semibold mb-4">Settings</h2><div class="flex -mb-px"><button id="settings-tab-appearance" onclick="Controller.switchSettingsTab('appearance')" class="py-2 px-4 font-semibold border-b-2 border-indigo-500 text-white">Appearance</button><button id="settings-tab-prompt" onclick="Controller.switchSettingsTab('prompt')" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white">Prompt</button><button id="settings-tab-model" onclick="Controller.switchSettingsTab('model')" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white">Model</button></div></div><div class="p-6 overflow-y-auto flex-grow" id="settings-content-container">...</div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('settings-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Edit Response Modal -->
<div id="edit-response-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('edit-response-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[75vh]">
        <div class="p-6 border-b border-gray-700 flex-shrink-0"> <h3 class="text-xl font-bold">Edit Response</h3> </div>
        <div class="p-6 overflow-y-auto"> <textarea id="edit-modal-input" class="w-full bg-gray-900 border-gray-700 rounded-lg p-2 resize-none"></textarea> </div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4 flex-shrink-0">
            <button onclick="Controller.closeModal('edit-response-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button>
            <button id="edit-modal-save-button" class="bg-indigo-600 hover:bg-indigo-700 font-bold py-2 px-4 rounded-lg">Save</button>
        </div>
    </div>
</div>

<!-- View Raw Prompt Modal -->
<div id="view-raw-prompt-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('view-raw-prompt-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Raw Prompt</h2></div><div class="p-6 overflow-y-auto flex-grow bg-gray-900"><pre id="raw-prompt-content" class="text-sm whitespace-pre-wrap"></pre></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('view-raw-prompt-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Example Dialogue Modal -->
<div id="example-dialogue-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('example-dialogue-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]">
        <div class="p-6 border-b border-gray-700 flex justify-between items-center">
            <h2 class="text-2xl font-semibold">Edit Example Dialogue</h2>
            <button onclick="Controller.addExampleDialogueTurn()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Turn</button>
        </div>
        <div id="example-dialogue-container" class="p-6 overflow-y-auto flex-grow space-y-4"></div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
            <button onclick="Controller.closeModal('example-dialogue-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
        </div>
    </div>
</div>

<!-- Generic Confirmation Modal -->
<div id="confirmation-modal" class="fixed inset-0 z-[70] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/60" onclick="Controller.closeModal('confirmation-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-md relative flex flex-col">
        <div class="p-6">
            <h3 class="text-xl font-bold mb-4">Are you sure?</h3>
            <p id="confirmation-modal-message" class="text-gray-300">This action cannot be undone.</p>
        </div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4">
            <button onclick="Controller.closeModal('confirmation-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button>
            <button id="confirmation-modal-confirm-button" class="bg-red-600 hover:bg-red-700 font-bold py-2 px-4 rounded-lg">Confirm</button>
        </div>
    </div>
</div>
<!-- /Modals -->

<!-- Hidden template for settings tabs -->
<div id="settings-templates" class="hidden">
    <div id="settings-appearance-content" class="space-y-6">
        <div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="font-selector" class="text-gray-400 text-sm block mb-2">Chat Font</label>
                    <select id="font-selector" class="w-full rounded-lg p-2">
                        <option value="'Inter', sans-serif">Inter (Sans-Serif)</option>
                        <option value="'Nunito Sans', sans-serif">Nunito Sans (Sans-Serif)</option>
                        <option value="'Lora', serif">Lora (Serif)</option>
                        <option value="'Roboto Slab', serif">Roboto Slab</option>
                        <option value="'EB Garamond', serif">EB Garamond</option>
                        <option value="'Cormorant Garamond', serif">Cormorant Garamond</option>
                        <option value="'Dancing Script', cursive">Dancing Script</option>
                        <option value="'Source Code Pro', monospace">Source Code Pro</option>
                    </select>
                </div>
                <div><label for="chat-text-color" class="text-gray-400 text-sm block mb-2">Chat Text Color</label><input type="color" id="chat-text-color" class="w-full rounded-lg p-1 h-10"></div>
            </div>
		<div>
                <label for="background-image-upload" class="text-gray-400 text-sm block mb-2">Background Image</label>
                <div class="flex space-x-2">
                    <input type="file" id="background-image-upload" accept="image/*" class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                    <button id="background-image-clear" class="bg-red-600/80 hover:bg-red-700/80 text-white font-bold py-1 px-3 rounded-lg">Clear</button>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                <div><label for="bubble-opacity-slider" class="text-gray-400 text-sm block mb-2">Chat Bubble Opacity</label><div class="flex items-center space-x-4"><input type="range" id="bubble-opacity-slider" class="w-full" min="0" max="1" step="0.05"><span id="bubble-opacity-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
                <div><label for="blur-slider" class="text-gray-400 text-sm block mb-2">Background Blur (px)</label><div class="flex items-center space-x-4"><input type="range" id="blur-slider" class="w-full" min="0" max="20" step="1"><span id="blur-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
                <div><label for="text-size-slider" class="text-gray-400 text-sm block mb-2">Text Size (px)</label><div class="flex items-center space-x-4"><input type="range" id="text-size-slider" class="w-full" min="12" max="24" step="1"><span id="text-size-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
                <div><label for="bubble-image-size-slider" class="text-gray-400 text-sm block mb-2">Bubble Image Size (px)</label><div class="flex items-center space-x-4"><input type="range" id="bubble-image-size-slider" class="w-full" min="50" max="200" step="10"><span id="bubble-image-size-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
            </div>
            <label class="text-gray-400 text-sm block mt-4 mb-2">Character Image Display</label><div class="flex space-x-4" id="character-image-display"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="none" checked><span>None</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="cinematic_overlay"><span>Cinematic</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="bubble"><span>Bubble</span></label></div>
        </div>
    </div>
    <!-- Replaced the Prompt tab content with individual, collapsible <details> sections for better organization. -->
    <div id="settings-prompt-content" class="space-y-2">
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Core Prompts</summary><div class="p-4 space-y-4 bg-black/20 rounded-b-lg"><div><h3 class="text-base font-medium mb-2">System Prompt (Global Fallback)</h3><p class="text-gray-400 text-sm mb-2">Used by AI characters who don't have their own specific instructions.</p><textarea id="system-prompt-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div><hr class="border-gray-700"><div><h3 class="text-base font-medium mb-2">Event Master Prompt</h3><p class="text-gray-400 text-sm mb-2">Define the base instruction for the Event Master, which injects surprise events.</p><textarea id="event-master-prompt-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Persona Generation Prompt</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used by the AI button on a character's persona. Use <code>{concept}</code> for the existing text.</p><textarea id="prompt-persona-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">World Map Generation Prompt</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used to generate the entire world map. Use <code>{characters}</code>, <code>{static}</code>, and <code>{recent}</code>.</p><textarea id="prompt-world-map-gen-input" class="w-full rounded-lg p-2 resize-y" rows="6"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Location Prompt Generation</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used to generate a location's detailed prompt. Use <code>{name}</code> and <code>{description}</code>.</p><textarea id="prompt-location-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Memory Entry Generation</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used for Static/Dynamic memory entries. Use <code>{title}</code> and <code>{triggers}</code>.</p><textarea id="prompt-entry-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Location Memory Summary</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used to auto-summarize events when you leave a location. Use <code>{transcript}</code>.</p><textarea id="prompt-location-memory-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <div class="flex space-x-2 pt-4"><button onclick="Controller.openViewRawPromptModal()" class="bg-gray-600/80 hover:bg-gray-500/80 text-white font-bold py-2 px-4 rounded-lg">View Raw Prompt</button><button onclick="Controller.openModal('example-dialogue-modal')" class="bg-sky-600/80 hover:bg-sky-500/80 text-white font-bold py-2 px-4 rounded-lg">Edit Example Dialogue</button></div>
    </div>
    <div id="settings-model-content" class="space-y-6">
        <div><h3 class="text-lg font-medium mb-2">AI Provider</h3><div class="flex space-x-4"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="gemini" onchange="Controller.setApiProvider('gemini')"><span>Gemini</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="openrouter" onchange="Controller.setApiProvider('openrouter')"><span>OpenRouter</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="koboldcpp" onchange="Controller.setApiProvider('koboldcpp')"><span>KoboldCPP</span></label></div></div><div id="gemini-settings"><h3 class="text-lg font-medium">Gemini API Settings</h3><p class="text-gray-400 text-sm mb-2">Required for text generation.</p><input type="password" id="gemini-api-key-input" class="w-full rounded-lg p-2" placeholder="Enter Gemini API key"></div><div id="openrouter-settings"><h3 class="text-lg font-medium">OpenRouter API Settings</h3><p class="text-gray-400 text-sm mb-2">Your key and the model name.</p><input type="password" id="openrouter-api-key-input" class="w-full rounded-lg p-2" placeholder="Enter OpenRouter API key"><input type="text" id="openrouter-model-input" class="mt-2 w-full rounded-lg p-2" placeholder="Enter model name"></div><div id="koboldcpp-settings"><h3 class="text-lg font-medium">KoboldCPP Settings</h3><p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure your local server is running with the <strong>--cors</strong> flag.</p><div><label for="koboldcpp-template-selector" class="text-gray-400 text-sm block mb-2">Prompt Template</label><select id="koboldcpp-template-selector" class="w-full rounded-lg p-2"><option value="none">None (Raw Text)</option><option value="mistral">Mistral</option><option value="chatml">ChatML</option><option value="alpaca">Alpaca</option></select></div><div><label for="koboldcpp-min-p-slider" class="text-gray-400 text-sm block mt-4 mb-2">Min P</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-min-p-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-min-p-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div><div><label for="koboldcpp-dry-slider" class="text-gray-400 text-sm block mt-4 mb-2">DRY (Repetition Penalty)</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-dry-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-dry-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div></div>
    </div>
</div>


    <!-- Application Logic - The order of these scripts is important! -->
    <script>
    <!-- PASTE content of modules.js HERE -->
// Utility function to prevent a function from being called too frequently.
const debounce = (func, wait) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; };

/**
 * DBService (resilient, fail-soft, self-initializing)
 * - Never throws during app init; callers can await methods safely.
 * - Gracefully handles blocked upgrades, missing IDB (private mode), and transient errors.
 * - All public methods resolve to sensible defaults instead of rejecting.
 */
const DBService = {
  db: null,
  DB_NAME: "EllipsisDB",
  STORE_NAME: "characterImages",
  OPEN_TIMEOUT_MS: 3000, // soft guard so init can't hang the UI indefinitely

  /**
   * Open the database (version 1) and create the store if needed.
   * Never rejects; resolves to true if usable, false if unavailable.
   */
  _open(version = 1) {
    return new Promise((resolve) => {
      try {
        if (this.db) return resolve(true);
        if (!("indexedDB" in window)) {
          console.warn("IndexedDB not supported in this environment.");
          return resolve(false);
        }

        const request = indexedDB.open(this.DB_NAME, version);

        // Soft timeout so a blocked upgrade can't lock the app
        const timeout = setTimeout(() => {
          console.warn("IDB open timed out (likely blocked). Failing soft.");
          // Let the app continue without image cache
          resolve(false);
        }, this.OPEN_TIMEOUT_MS);

        request.onerror = (event) => {
          clearTimeout(timeout);
          console.warn("IndexedDB open error (fail-soft):", event?.target?.error);
          resolve(false);
        };

        request.onblocked = () => {
          clearTimeout(timeout);
          console.warn(
            "IndexedDB upgrade is blocked by another tab/window. Continuing without cache."
          );
          resolve(false);
        };

        request.onupgradeneeded = (event) => {
          try {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.STORE_NAME)) {
              db.createObjectStore(this.STORE_NAME);
              console.log("Object store created:", this.STORE_NAME);
            }
          } catch (e) {
            console.warn("onupgradeneeded failed (fail-soft):", e);
          }
        };

        request.onsuccess = (event) => {
          clearTimeout(timeout);
          try {
            this.db = event.target.result;
            // Close politely if a future upgrade happens elsewhere
            this.db.onversionchange = () => {
              console.warn("IDB version change detected; closing DB.");
              try { this.db.close(); } catch {}
              this.db = null;
            };
            console.log("IndexedDB ready.");
            resolve(true);
          } catch (e) {
            console.warn("IDB onsuccess handler failed (fail-soft):", e);
            resolve(false);
          }
        };
      } catch (err) {
        console.warn("IDB _open threw (fail-soft):", err);
        resolve(false);
      }
    });
  },

  /**
   * Public init. Never throws; resolves to void.
   */
  async init() {
    if (this.db) return;
    const ok = await this._open(1);
    if (!ok) {
      // Keep running without a DB; callers will no-op gracefully.
      return;
    }
  },

  /**
   * Ensure DB is ready. Returns boolean (true if usable).
   */
  async ensure() {
    if (this.db) return true;
    await this.init();
    return !!this.db;
  },

  /**
   * Save a Blob under a string key. Resolves boolean (success).
   */
  async saveImage(id, blob) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction([this.STORE_NAME], "readwrite");
        const store = tx.objectStore(this.STORE_NAME);

        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);

        const req = store.put(blob, id);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
      } catch (e) {
        console.warn("saveImage failed (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Fetch a Blob by id. Resolves Blob|null.
   */
  async getImage(id) {
    if (!(await this.ensure())) return null;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction([this.STORE_NAME], "readonly");
        const store = tx.objectStore(this.STORE_NAME);

        tx.onabort = () => resolve(null);
        tx.onerror = () => resolve(null);

        const req = store.get(id);
        req.onsuccess = () => resolve(req.result ?? null);
        req.onerror = () => resolve(null);
      } catch (e) {
        console.warn("getImage failed (fail-soft):", e);
        resolve(null);
      }
    });
  },

  /**
   * Delete a key. Resolves boolean (success).
   */
  async deleteImage(id) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction([this.STORE_NAME], "readwrite");
        const store = tx.objectStore(this.STORE_NAME);

        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);

        const req = store.delete(id);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
      } catch (e) {
        console.warn("deleteImage failed (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Clear the store. Resolves boolean (success).
   */
  async clear() {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction([this.STORE_NAME], "readwrite");
        const store = tx.objectStore(this.STORE_NAME);

        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);

        const req = store.clear();
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
      } catch (e) {
        console.warn("clear failed (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Close the DB handle.
   */
  close() {
    try {
      if (this.db) this.db.close();
    } catch (e) {
      console.warn("DB close failed (ignored):", e);
    } finally {
      this.db = null;
    }
  },
}


/**
 * =================================================================================================
 * StateManager Module
 * =================================================================================================
 * This module is the single source of truth for all application data.
 * It handles loading from and saving to localStorage, and provides controlled access
 * to the library and the active narrative state. All data mutations should happen
 * through this manager's methods to ensure consistency.
 */
const StateManager = {
    // Private data store. Should not be accessed directly from outside this module.
    data: {
        library: {
            active_story_id: null,
            active_narrative_id: null,
            stories: [],
            tag_cache: []
        },
        // This holds the state of the *currently active* narrative.
        // It's a combination of story-level settings and narrative-specific data.
        activeNarrativeState: {},
    },

    CONSTANTS: {
        LIBRARY_KEY: 'aiStorytellerLibrary',
    },

    // --- Public Getters ---
    // Provide read-only access to the state from other parts of the application.
    
    /** @returns {object} The active narrative state object. */
    getState() {
        return this.data.activeNarrativeState;
    },

    /** @returns {object} The entire story library object. */
    getLibrary() {
        return this.data.library;
    },

    // --- State Initialization and Persistence ---
    
    /**
     * Loads the entire story library from localStorage into the state manager.
     * Performs data migration for older story formats to ensure compatibility.
     * This is the first step in the application's data lifecycle.
     */
    loadLibrary() {
        const savedLibraryJSON = localStorage.getItem(this.CONSTANTS.LIBRARY_KEY);
        if (savedLibraryJSON) {
            try {
                let parsedLibrary = JSON.parse(savedLibraryJSON);

                // Define default settings for migration purposes using the new UTILITY module.
                const defaults = {
                    ...UTILITY.getDefaultApiSettings(),
                    ...UTILITY.getDefaultUiSettings(),
                    ...UTILITY.getDefaultSystemPrompts(),
                };

                // Migrate each story to the latest format, adding new fields if they don't exist.
                parsedLibrary.stories = (parsedLibrary.stories || []).map(story => {
                    const newStory = { ...defaults, ...story };

                    if (newStory.characters) {
                        newStory.characters = newStory.characters.map(char => {
                            const newChar = { ...char };
                            if (typeof char.short_description === 'undefined') {
                                newChar.short_description = char.is_user ? "The main character." : "A brief summary of the character.";
                            }
                            if (typeof char.model_instructions === 'undefined') {
                                if (char.is_user) {
                                    newChar.model_instructions = "Write a response for {character} in a creative and descriptive style.";
                                } else {
                                    newChar.model_instructions = newStory.system_prompt || "Act as {character}. Be descriptive and engaging.";
                                }
                            }
                            if (typeof newChar.is_narrator === 'undefined') {
                                newChar.is_narrator = false;
                            }
                            if (typeof char.color === 'string') {
                                newChar.color = { base: char.color, bold: '#FFFFFF' }; 
                            }
                            return newChar;
                        });
                    }
                    
                    // [MIGRATION] Ensure world map data exists and is valid
                    (newStory.narratives || []).forEach(narrative => {
                        if (narrative.state && (!narrative.state.worldMap || !narrative.state.worldMap.grid || narrative.state.worldMap.grid.length === 0)) {
                            narrative.state.worldMap = { 
                                grid: UTILITY.createDefaultMapGrid(), 
                                currentLocation: { x: 4, y: 4 }, 
                                destination: { x: null, y: null }, 
                                path: [] 
                            };
                        }
                    });
                    
                    return newStory;
                });
                
                this.data.library = parsedLibrary;
                if (!this.data.library.tag_cache) this.data.library.tag_cache = [];
                if (!this.data.library.active_narrative_id) this.data.library.active_narrative_id = null;

            } catch (error) {
                console.error("Failed to parse library from localStorage.", error);
                this.data.library = { active_story_id: null, active_narrative_id: null, stories: [], tag_cache: [] };
            }
        } else {
            this.data.library = { active_story_id: null, active_narrative_id: null, stories: [], tag_cache: [] };
        }
    },
    
    /**
     * Persists the current state of the entire library to localStorage.
     * This should be called after any significant data mutation.
     */
    saveLibrary() {
        localStorage.setItem(this.CONSTANTS.LIBRARY_KEY, JSON.stringify(this.data.library));
    },
    
    /**
     * Loads the currently active narrative into the `activeNarrativeState`.
     */
    loadActiveNarrative() {
        const { active_story_id, active_narrative_id, stories } = this.data.library;
        
        if (!active_story_id || !active_narrative_id) {
            this.data.activeNarrativeState = {};
            return;
        }
        
        const activeStory = stories.find(s => s.id === active_story_id);
        if (!activeStory) {
            this.data.activeNarrativeState = {};
            return;
        }
        
        const activeNarrative = (activeStory.narratives || []).find(n => n.id === active_narrative_id);
        if (activeNarrative) {
            const storySettings = { ...activeStory };
            delete storySettings.narratives;
            delete storySettings.scenarios;
            
            this.data.activeNarrativeState = {
                ...storySettings,
                ...activeNarrative.state,
                narrativeName: activeNarrative.name
            };

            // [MIGRATION] Ensure loaded narrative has a valid world map.
            if (!this.data.activeNarrativeState.worldMap || !this.data.activeNarrativeState.worldMap.grid || this.data.activeNarrativeState.worldMap.grid.length === 0) {
                 this.data.activeNarrativeState.worldMap = { 
                    grid: UTILITY.createDefaultMapGrid(), 
                    currentLocation: { x: 4, y: 4 }, 
                    destination: { x: null, y: null }, 
                    path: [] 
                };
            }

        } else {
            this.data.activeNarrativeState = {};
        }
    },

    /**
     * Saves the `activeNarrativeState` back into the library.
     */
    saveState() {
        const { active_story_id, active_narrative_id, stories } = this.data.library;
        const currentState = this.data.activeNarrativeState;

        if (!active_story_id || !active_narrative_id || !currentState) {
            console.warn("Attempted to save state without an active story/narrative.");
            return;
        }
        
        const activeStory = stories.find(s => s.id === active_story_id);
        if (activeStory) {
            const narrativeIndex = (activeStory.narratives || []).findIndex(n => n.id === active_narrative_id);
            if (narrativeIndex !== -1) {
                const narrativeState = {
                    chat_history: currentState.chat_history,
                    messageCounter: currentState.messageCounter,
                    static_entries: currentState.static_entries,
                    worldMap: currentState.worldMap
                };
                
                activeStory.narratives[narrativeIndex].state = narrativeState;
                activeStory.narratives[narrativeIndex].name = currentState.narrativeName; // Save narrative name
                activeStory.narratives[narrativeIndex].last_modified = new Date().toISOString();
                
                activeStory.characters = currentState.characters;
                activeStory.dynamic_entries = currentState.dynamic_entries;
                activeStory.font = currentState.font;
                activeStory.backgroundImageURL = currentState.backgroundImageURL;
                activeStory.bubbleOpacity = currentState.bubbleOpacity;
                activeStory.chatTextColor = currentState.chatTextColor;
                activeStory.characterImageMode = currentState.characterImageMode;
                activeStory.backgroundBlur = currentState.backgroundBlur;
                activeStory.textSize = currentState.textSize;
                activeStory.bubbleImageSize = currentState.bubbleImageSize;
                activeStory.system_prompt = currentState.system_prompt;
                activeStory.event_master_base_prompt = currentState.event_master_base_prompt;
                activeStory.event_master_prompt = currentState.event_master_prompt;
                activeStory.apiProvider = currentState.apiProvider;
                activeStory.geminiApiKey = currentState.geminiApiKey;
                activeStory.openRouterKey = currentState.openRouterKey;
                activeStory.openRouterModel = currentState.openRouterModel;
                activeStory.koboldcpp_template = currentState.koboldcpp_template;
                activeStory.koboldcpp_min_p = currentState.koboldcpp_min_p;
                activeStory.koboldcpp_dry = currentState.koboldcpp_dry;

                activeStory.prompt_persona_gen = currentState.prompt_persona_gen;
                activeStory.prompt_world_map_gen = currentState.prompt_world_map_gen;
                activeStory.prompt_location_gen = currentState.prompt_location_gen;
                activeStory.prompt_entry_gen = currentState.prompt_entry_gen;
                activeStory.prompt_location_memory_gen = currentState.prompt_location_memory_gen;

                activeStory.last_modified = new Date().toISOString();
                this.saveLibrary();
            }
        }
    },

    /**
     * Scans all stories and characters to build a unique, sorted list of all tags.
     */
    updateTagCache() {
        const allTags = new Set();
        this.data.library.stories.forEach(story => {
            if (story.tags) story.tags.forEach(tag => allTags.add(tag));
            if (story.characters) {
                story.characters.forEach(char => {
                    if (char.tags) char.tags.forEach(tag => allTags.add(tag));
                });
            }
        });
        this.data.library.tag_cache = Array.from(allTags).sort();
        this.saveLibrary();
    },
};

/**
 * =================================================================================================
 * APIService Module
 * =================================================================================================
 */
const APIService = {
    /**
     * Calls the configured AI provider with a given prompt.
     * @param {string} prompt - The prompt to send to the AI.
     * @param {boolean} [isJson=false] - Whether to expect a JSON response.
     * @param {AbortSignal|null} [signal=null] - An AbortSignal to cancel the request.
     * @returns {Promise<string>} The AI's response text.
     */
    async callAI(prompt, isJson = false, signal = null) {
        const state = StateManager.getState();
        let text = "";
        try {
            if (state.apiProvider === 'gemini') {
                text = await this.callGemini(prompt, signal);
            } else if (state.apiProvider === 'openrouter') {
                text = await this.callOpenRouter(prompt, signal);
            } else if (state.apiProvider === 'koboldcpp') {
                text = await this.callKoboldCPP(prompt, signal);
            }

            if (isJson) {
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (jsonMatch && jsonMatch[0]) {
                    return jsonMatch[0];
                }
                console.error("AI did not return valid JSON for a JSON-expected call. Response:", text);
                throw new Error("AI response was not in the expected JSON format.");
            }
            return text.trim();
        } catch (error) {
            // Don't re-throw abort errors, as they are intentional.
            if (error.name === 'AbortError') {
                console.log("Fetch aborted by user.");
                throw error; // Re-throw to be caught by the controller
            }
            console.error(`AI call failed for provider ${state.apiProvider}:`, error);
            throw error;
        }
    },
    async callGemini(prompt, signal) {
        const state = StateManager.getState();
        if (!state.geminiApiKey) throw new Error("Gemini API key not set.");
        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${state.geminiApiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
    },
    async callOpenRouter(prompt, signal) {
        const state = StateManager.getState();
        if (!state.openRouterKey || !state.openRouterModel) throw new Error("OpenRouter API key or model not set.");
        const res = await fetch('https://openrouter.ai/api/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.openRouterKey}`}, body: JSON.stringify({ model: state.openRouterModel, messages: [{ role: 'user', content: prompt }] }), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.choices[0].message.content;
    },
    async callKoboldCPP(prompt, signal) {
        const state = StateManager.getState();
        const payload = {
            prompt: prompt, use_story: false, use_memory: false, use_authors_note: false, use_world_info: false,
            max_context_length: 4096, max_length: 200, min_p: state.koboldcpp_min_p,
            rep_pen: 1.1, rep_pen_range: 2048, rep_pen_slope: 0.7, temperature: 0.65, 
            tfs: 1, top_p: 0.92, top_k: 0, typical: 1, sampler_order: [6, 0, 1, 2, 3, 4, 5],
            mirostat: 2, mirostat_tau: 4, mirostat_eta: 0.1, dry: state.koboldcpp_dry,
        };
        const res = await fetch(`${state.koboldcpp_url}/api/v1/generate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`KoboldCPP API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.results[0].text.trim();
    },
};

/**
 * =================================================================================================
 * ModalManager Module
 * =================================================================================================
 */
const ModalManager = {
    RUNTIME: {
        carousel_interval: null,
    },
    open(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'flex';
        }
    },
    close(modalId) {
        if (this.RUNTIME.carousel_interval) {
            clearInterval(this.RUNTIME.carousel_interval);
            this.RUNTIME.carousel_interval = null;
        }
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
        }
    }
};

/**
 * =================================================================================================
 * UTILITY Module
 * =================================================================================================
 */
const UTILITY = {
    uuid() { 
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)); 
    },
    escapeHTML(str) { 
        if(typeof str !== 'string') return ''; 
        const p = document.createElement("p"); 
        p.textContent = str; 
        return p.innerHTML; 
    },
    hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; } 
        else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
        return `rgba(${+r},${+g},${+b},${alpha})`;
    },
    darkenHex(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) - amt;
        const G = (num >> 8 & 0x00FF) - amt;
        const B = (num & 0x0000FF) - amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    },
    getDefaultApiSettings() {
        return {
            apiProvider: 'gemini', geminiApiKey: '', openRouterKey: '', openRouterModel: 'google/gemini-flash-1.5',
            koboldcpp_url: 'http://localhost:5001', koboldcpp_template: 'none', koboldcpp_min_p: 0.1, koboldcpp_dry: 0.25,
        };
    },
    getDefaultUiSettings() {
        return {
            font: "'Inter', sans-serif", backgroundImageURL: '', bubbleOpacity: 0.85,
            chatTextColor: '#e5e7eb', characterImageMode: 'none',
            backgroundBlur: 5, textSize: 16, bubbleImageSize: 100,
        };
    },
    getDefaultSystemPrompts() {
        return {
            system_prompt: 'You are a master storyteller. Follow instructions precisely.',
            event_master_base_prompt: 'You are a secret Event Master. Read the chat. Generate a brief, secret instruction for AI characters to introduce a logical but unexpected event.',
            event_master_prompt: '', 
            prompt_persona_gen: "Embellish this character concept into a rich, detailed, and compelling persona description. CONCEPT: \"{concept}\"",
            prompt_world_map_gen: "Based on the following story context, generate a genre-appropriate 8x8 grid of interconnected fantasy locations. The central location (4,4) should be a neutral starting point. Attempt to include locations mentioned in the context.\nCONTEXT:\nCHARACTERS:\n{characters}\n\nSTATIC LORE:\n{static}\n\nRECENT EVENTS:\n{recent}\n\nRespond with a valid JSON object: { \"grid\": [ { \"coords\": {\"x\":int, \"y\":int}, \"name\": \"string\", \"description\": \"string (one-line summary)\", \"prompt\": \"string (a rich, detailed paragraph for the AI)\", \"imageUrl\": \"\" } ] }. The grid must contain exactly 64 locations.",
            prompt_location_gen: "Generate a rich, detailed, and evocative paragraph-long prompt for a fantasy location named '{name}' which is briefly described as '{description}'. This prompt will be given to an AI storyteller to describe the scene.",
            prompt_entry_gen: "Generate a detailed and informative encyclopedia-style entry for a lore topic titled '{title}'. If relevant, use the following triggers as context: '{triggers}'.",
            prompt_location_memory_gen: "You are an archivist. Read the following chat transcript that occurred at a specific location. Summarize the key events, character developments, and important facts into a concise, single paragraph. This will serve as a memory for what happened at that location.\n\nTRANSCRIPT:\n{transcript}"
        };
    },
    createDefaultMapGrid() {
        const grid = [];
        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
                grid.push({
                    coords: { x, y },
                    name: "",
                    description: "",
                    prompt: "",
                    imageUrl: "",
                    local_static_entries: []
                });
            }
        }
        return grid;
    },
    findPath(grid, startCoords, endCoords) {
        const toKey = ({ x, y }) => `${x},${y}`;
        const fromKey = (key) => { const [x, y] = key.split(',').map(Number); return { x, y }; };

        const nodes = grid.map(loc => ({
            ...loc,
            g: Infinity,
            h: Infinity,
            f: Infinity,
            parent: null,
        }));

        const startNode = nodes.find(n => n.coords.x === startCoords.x && n.coords.y === startCoords.y);
        const endNode = nodes.find(n => n.coords.x === endCoords.x && n.coords.y === endCoords.y);

        if (!startNode || !endNode) return [];

        const heuristic = (a, b) => Math.abs(a.coords.x - b.coords.x) + Math.abs(a.coords.y - b.coords.y);

        let openSet = [startNode];
        let closedSet = new Set();

        startNode.g = 0;
        startNode.h = heuristic(startNode, endNode);
        startNode.f = startNode.h;

        while (openSet.length > 0) {
            openSet.sort((a, b) => a.f - b.f);
            let currentNode = openSet.shift();

            if (currentNode === endNode) {
                let path = [];
                let temp = currentNode;
                while (temp) {
                    path.push(temp.coords);
                    temp = temp.parent;
                }
                return path.reverse();
            }

            closedSet.add(toKey(currentNode.coords));

            const neighbors = nodes.filter(n => {
                const dx = Math.abs(n.coords.x - currentNode.coords.x);
                const dy = Math.abs(n.coords.y - currentNode.coords.y);
                return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
            });

            for (let neighbor of neighbors) {
                if (closedSet.has(toKey(neighbor.coords))) continue;

                let tentativeG = currentNode.g + 1;

                if (tentativeG < neighbor.g) {
                    neighbor.parent = currentNode;
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    }
                }
            }
        }
        return [];
    },
    weightedChoice(characters, weights, controller) {
        if (controller) {
            const scoresDataForModal = characters.map((char, index) => ({
                name: char.name,
                score: weights[index]
            })).sort((a, b) => b.score - a.score);
        }

        if (characters.length !== weights.length || characters.length === 0) {
            return null;
        }
    
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        if (totalWeight <= 0) {
            return characters[Math.floor(Math.random() * characters.length)];
        }
        let random = Math.random() * totalWeight;
    
        for (let i = 0; i < characters.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return characters[i];
            }
        }
        
        return characters[characters.length - 1];
    },
    /**
     * [NEW] Checks if there is enough space in localStorage for an estimated import size.
     * @param {number} estimatedSize - The estimated size of the import in bytes.
     * @returns {boolean} - True if there is likely enough space, false otherwise.
     */
    checkLocalStorageQuota(estimatedSize) {
        try {
            const testKey = 'quota-check';
            const existingDataSize = JSON.stringify(localStorage).length;
            const availableSpace = (5 * 1024 * 1024) - existingDataSize; // Assuming 5MB limit
            
            if (estimatedSize > availableSpace) {
                return false;
            }
            
            localStorage.setItem(testKey, '1');
            localStorage.removeItem(testKey);
            return true;
        } catch (e) {
            return false;
        }
    }
};

/**
 * =================================================================================================
 * PromptBuilder Module
 * =================================================================================================
 */
const PromptBuilder = {
    _getReplacer(contextCharacter) {
        const state = StateManager.getState();
        const userChar = state.characters.find(c => c.is_user);
        const characterName = contextCharacter ? contextCharacter.name : '';
        const userName = userChar ? userChar.name : 'You';
        return (text) => {
            if (typeof text !== 'string') return '';
            let processedText = text.replace(/{character}/g, characterName);
            processedText = processedText.replace(/{user}/g, userName);
            return processedText;
        };
    },
    buildPrompt(charToActId, isForUser = false) {
        const state = StateManager.getState();
        const charToAct = state.characters.find(c => c.id === charToActId);
        if (!charToAct) {
            console.error("PromptBuilder: Could not find character with ID:", charToActId);
            return ""; // Return empty string to prevent errors
        }
        const replacer = this._getReplacer(charToAct);
        const modelInstructions = charToAct.model_instructions || state.system_prompt;

let locationContext = '';
        if (state.worldMap && state.worldMap.grid.length > 0) {
            const { grid, currentLocation, path } = state.worldMap;
            const currentLoc = grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);

            // --- 1. Add Current Location (only if name and prompt exist) ---
            if (currentLoc && currentLoc.name && currentLoc.prompt) {
                locationContext += `CURRENT LOCATION: ${currentLoc.name}\n${currentLoc.prompt}\n\n`;

                // Add local static entries if they exist
                if (currentLoc.local_static_entries && currentLoc.local_static_entries.length > 0) {
                    locationContext += "--- LOCATION-SPECIFIC KNOWLEDGE ---\n";
                    locationContext += currentLoc.local_static_entries
                        .map(l => `Title: ${l.title}\nContent: ${replacer(l.content)}`)
                        .join('\n\n') + "\n\n";
                }
            } else if (currentLoc && currentLoc.name) {
                 // Fallback if only name exists but prompt is missing (optional, remove if unwanted)
                 locationContext += `CURRENT LOCATION: ${currentLoc.name}\n(No detailed description available.)\n\n`;
            }

            // --- 2. Add Adjacent Locations (only if they have name AND description) ---
            if (currentLoc) { // Check currentLoc exists before checking neighbors
                const directions = [
                    { dir: 'North', x: 0, y: -1 }, { dir: 'South', x: 0, y: 1 },
                    { dir: 'East', x: 1, y: 0 }, { dir: 'West', x: -1, y: 0 },
                    { dir: 'Northeast', x: 1, y: -1 }, { dir: 'Northwest', x: -1, y: -1 },
                    { dir: 'Southeast', x: 1, y: 1 }, { dir: 'Southwest', x: -1, y: 1 }
                ];

                const validAdjacentLocations = directions
                    .map(({ dir, x, y }) => {
                        const adjLoc = grid.find(l => l.coords.x === currentLocation.x + x && l.coords.y === currentLocation.y + y);
                        // Require both name and description to be non-empty
                        if (adjLoc && adjLoc.name && adjLoc.description) {
                            return `- (${dir}): ${adjLoc.name} - ${adjLoc.description}`;
                        }
                        return null; // Ignore invalid/incomplete locations
                    })
                    .filter(Boolean); // Remove null entries

                // Only add the section if there are valid neighbors
                if (validAdjacentLocations.length > 0) {
                    locationContext += 'ADJACENT LOCATIONS:\n';
                    locationContext += validAdjacentLocations.join('\n') + '\n\n';
                }
            }

            // --- 3. Add Travel Path (only if path array exists and is not empty) ---
            if (path && path.length > 0) {
                const pathNames = path
                    .map(p => grid.find(l => l.coords.x === p.x && l.coords.y === p.y)?.name)
                    .filter(Boolean) // Filter out any potential undefined names
                    .join(' -> ');
                // Ensure pathNames isn't empty after filtering before adding
                if (pathNames) {
                    locationContext += `TRAVEL PATH TO DESTINATION: ${pathNames}\n`;
                }
            }
        }
        
        const components = {
            system_prompt: replacer(modelInstructions),
            event_master_prompt: replacer(state.event_master_prompt),
            static_entries: (state.static_entries || []).map(l => `### ${l.title}\n${replacer(l.content)}`).join('\n\n'),
            dynamic_entries: (state.dynamic_entries || [])
                .filter(entry => entry.triggered_at_turn !== null)
                .map(l => `### ${l.title}\n${replacer(l.content)}`).join('\n\n'),
            characters: (state.characters || []).filter(c => c.is_active).map(c => `### Character: ${c.name}\n\n${replacer(c.description)}`).join('\n\n'),
            history: (state.chat_history || []).filter(m => !m.isHidden).slice(-10),
            charToAct: charToAct,
            isForUser: isForUser,
            location_context: locationContext,
        };
        
        if (state.event_master_prompt) { 
            state.event_master_prompt = ''; 
            StateManager.saveState(); 
        }

        if (state.apiProvider === 'koboldcpp') { 
            return this.buildKoboldTemplatedPrompt(components, replacer); 
        }
        return this.buildDefaultPrompt(components, replacer);
    },
    buildDefaultPrompt(components, replacer) {
        const state = StateManager.getState();
        let p = components.system_prompt + "\n\n";
        if (components.event_master_prompt) p += "--- SECRET EVENT MASTER INSTRUCTION ---\n" + components.event_master_prompt + "\n\n";
        if (components.location_context) p += "## LOCATION CONTEXT\n" + components.location_context + "\n\n";
        p += "## WORLD KNOWLEDGE\n" + components.static_entries + "\n\n";
        if (components.dynamic_entries) p += "## RECENTLY REVEALED DYNAMIC KNOWLEDGE\n" + components.dynamic_entries + "\n\n";
        p += "## CHARACTERS\n" + components.characters + "\n\n";

        const exampleDialogue = (state.chat_history || []).filter(m => m.isHidden);
        if(exampleDialogue.length > 0){
            p += "## EXAMPLE DIALOGUE\n";
            exampleDialogue.forEach(msg => {
                const char = state.characters.find(c => c.id === msg.character_id);
                if (char) p += `${char.name}: ${replacer(msg.content)}\n`;
            });
            p += "\n";
        }
        
        p += "## RECENT CONVERSATION & EVENTS\n";
        components.history.forEach(msg => { 
            if (msg.type === 'chat') {
                const char = state.characters.find(c => c.id === msg.character_id); 
                if (char) p += `[${char.name}:]\n${replacer(msg.content)}\n\n`;
            } else if (msg.type === 'lore_reveal') {
                p += `[System Note: Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}\n\n`;
            } else if (msg.type === 'system_event') {
                 p += `[System Event: ${replacer(msg.content)}]\n`;
            }
        });
        p += "\n### INSTRUCTION\n";
        p += components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;
        p += " Do not repeat the character's name in the response itself.\n[CHARACTER_TO_ACT]: " + components.charToAct.name;
        return p;
    },
    buildKoboldTemplatedPrompt(components, replacer) {
        const state = StateManager.getState();
        const template = state.koboldcpp_template;
        if (template === 'none') return this.buildDefaultPrompt(components, replacer);

        let system = [components.system_prompt];
        if (components.event_master_prompt) system.push("SECRET EVENT INSTRUCTION:\n" + components.event_master_prompt);
        if (components.location_context) system.push("LOCATION CONTEXT:\n" + components.location_context);
        system.push("STATIC KNOWLEDGE:\n" + components.static_entries);
        if (components.dynamic_entries) system.push("DYNAMIC KNOWLEDGE:\n" + components.dynamic_entries);
        system.push("CHARACTERS:\n" + components.characters);
        const system_prompt_str = system.join('\n\n');
        
        const history_str = components.history.map(msg => {
            if (msg.type === 'chat') {
                const char = state.characters.find(c => c.id === msg.character_id); 
                if (char) return `${char.is_user ? 'user' : 'assistant'}:${char.name}:\n${replacer(msg.content)}`;
            } else if (msg.type === 'lore_reveal') {
                return `system:Dynamic Entry Revealed - ${msg.title}:\n${replacer(msg.content)}`;
            }
        }).filter(Boolean).join('\n');

        let instruction = components.isForUser ? `Write the next chat message for the user's character, ${components.charToAct.name}.` : `Write the next chat message for ${components.charToAct.name}. Stay in character.`;
        instruction += " Do not write any prefix like 'Character Name:'.";

        switch (template) {
            case 'mistral':
                return `<s>[INST] ${system_prompt_str}\n\n${history_str}\n\n${instruction} [/INST]`;
            case 'chatml':
                const history_chatml = components.history.map(msg => {
                    const role = msg.type === 'lore_reveal' ? 'system' : (state.characters.find(c=>c.id === msg.character_id)?.is_user ? 'user' : 'assistant');
                    const content = msg.type === 'lore_reveal' ? `[Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}` : `${state.characters.find(c=>c.id === msg.character_id)?.name}:\n${replacer(msg.content)}`;
                    return `<|im_start|>${role}\n${content}<|im_end|>`;
                }).join('\n');
                return `<|im_start|>system\n${system_prompt_str}<|im_end|>\n${history_chatml}\n<|im_start|>user\n${instruction}<|im_end|>\n<|im_start|>assistant\n${components.charToAct.name}:\n`;
            case 'alpaca':
                 return `### Instruction:\n${system_prompt_str}\n\n${history_str}\n\n${instruction}\n\n### Response:\n`;
            default:
                return this.buildDefaultPrompt(components, replacer);
        }
    },
};

/**
 * =================================================================================================
 * [10/17/2025 Edit] ImageProcessor Module
 * =================================================================================================
 * Handles client-side image processing, such as resizing and format conversion.
 */
/**
 * =================================================================================================
 * [10/17/2025 Edit] ImageProcessor Module
 * =================================================================================================
 * Handles client-side image processing, such as resizing and format conversion.
 */
const ImageProcessor = {
    /**
     * Processes an image file, resizing it if necessary and converting it to a JPEG data URL.
     */
	async processImageAsBlob(imageFile) { // Renamed for clarity
		return new Promise((resolve, reject) => {
			const MAX_HEIGHT = 2000;
			const QUALITY = 0.85;

			const reader = new FileReader();
			reader.onload = (e) => {
				const img = new Image();
				img.onload = () => {
					let { width, height } = img;
					if (height > MAX_HEIGHT) {
						const ratio = MAX_HEIGHT / height;
						height = MAX_HEIGHT;
						width *= ratio;
					}
					const canvas = document.createElement('canvas');
					canvas.width = width;
					canvas.height = height;
					const ctx = canvas.getContext('2d');
					ctx.drawImage(img, 0, 0, width, height);

					canvas.toBlob((blob) => {
						if (blob) {
							resolve(blob);
						} else {
							reject(new Error('Canvas to Blob conversion failed.'));
						}
					}, 'image/jpeg', QUALITY); // Still saves as JPEG initially
				};
				img.onerror = (err) => reject(new Error('Failed to load image for processing.'));
				img.src = e.target.result;
			};
			reader.onerror = (err) => reject(new Error('Failed to read image file.'));
			reader.readAsDataURL(imageFile);
		});
	}, // <<< Make sure there is a comma here after the first function

    /**
     * Converts an image Blob (potentially JPEG) to a PNG Blob using a canvas.
     * @param {Blob} imageBlob - The input image Blob.
     * @returns {Promise<Blob>} A promise that resolves with the PNG Blob.
     */
    async convertBlobToPNGBlob(imageBlob) {
        return new Promise((resolve, reject) => {
            // Create an object URL from the input Blob
            const imageUrl = URL.createObjectURL(imageBlob);
            const img = new Image();

            img.onload = () => {
                // Image loaded successfully, now draw to canvas
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth; // Use natural dimensions
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // IMPORTANT: Revoke the object URL *after* drawing to canvas
                URL.revokeObjectURL(imageUrl);

                // Convert canvas content to a PNG Blob
                canvas.toBlob((pngBlob) => {
                    if (pngBlob) {
                        resolve(pngBlob); // Resolve the promise with the new PNG Blob
                    } else {
                        reject(new Error('Canvas to PNG Blob conversion failed.'));
                    }
                }, 'image/png'); // Specify PNG format
            };

            img.onerror = (err) => {
                // Handle image loading errors
                URL.revokeObjectURL(imageUrl); // Clean up even on error
                reject(new Error('Failed to load image blob for PNG conversion. Could be invalid image data.'));
            };

            // Start loading the image from the object URL
            img.src = imageUrl;
        });
    }

};


/**
 * =================================================================================================
 * ImportExportService Module
 * =================================================================================================
 * Manages all data conversion and file handling for importing and exporting stories.
 */
const ImportExportService = {
    // --- Public High-Level API ---

    /**
     * Main entry point for file imports. Determines file type and routes to the correct parser.
     * @param {File} file - The uploaded file object.
     * @param {boolean} [skipImages=false] - If true, image processing will be skipped to save storage space.
     * @returns {Promise<object>} A promise that resolves with a fully formed Ellipsis story object.
     */
    async parseUploadedFile(file, skipImages = false) {
        const lowerCaseName = file.name.toLowerCase();
        
        if (lowerCaseName.endsWith('.png')) {
            return this._parseV2Card(file, skipImages);
        } else if (lowerCaseName.endsWith('.zip') || lowerCaseName.endsWith('.byaf')) {
            return this._parseBYAF(file, skipImages);
        } else if (lowerCaseName.endsWith('.json')) {
            return this._parseEllipsisJSON(file);
        } else {
            throw new Error("Unsupported file type. Please use .png, .byaf, .zip, or .json.");
        }
    },

    /**
     * Exports a narrative to a native Ellipsis JSON file.
     * @param {object} story - The story object containing the narrative.
     * @returns {Blob} A Blob containing the JSON data.
     */
    exportStoryAsJSON(story) {
        const storyExport = JSON.parse(JSON.stringify(story));
        return new Blob([JSON.stringify(storyExport, null, 2)], { type: 'application/json' });
    },

    /**
     * Exports a narrative to the V2 PNG Card format.
     * @param {object} story - The story object.
     * @param {object} narrative - The narrative to export.
     * @param {string} primaryCharId - The ID of the character to feature on the card.
     * @returns {Promise<Blob>} A promise that resolves with a Blob of the final PNG file.
     */
async exportStoryAsV2(story, narrative, primaryCharId) {
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        if (!primaryChar) {
             throw new Error("V2 export requires a selected primary character.");
        }

        let originalImageBlob = null; // Store the potentially non-PNG blob

        // --- IMAGE FETCHING LOGIC (same as previous fix) ---
        try {
            originalImageBlob = await DBService.getImage(primaryChar.id);
        } catch (dbError) {
            console.warn(`Could not get image from IDB for ${primaryChar.id}:`, dbError);
        }
        if (!originalImageBlob && primaryChar.image_url && !primaryChar.image_url.startsWith('local_idb_')) {
            try {
                const response = await fetch(primaryChar.image_url);
                if (response.ok) {
                    originalImageBlob = await response.blob();
                } else {
                     console.warn(`Failed to fetch legacy image URL for ${primaryChar.id}: ${response.statusText}`);
                }
            } catch (fetchError) {
                console.warn(`Error fetching legacy image URL for ${primaryChar.id}:`, fetchError);
            }
        }
        // --- END IMAGE FETCHING LOGIC ---

        if (!originalImageBlob) {
            throw new Error("V2 export requires the primary character to have a valid image (either uploaded locally or via URL).");
        }

        // --- NEW: Convert the retrieved blob to PNG ---
        let pngBlob;
        try {
            // Only convert if it's not already PNG
            if (originalImageBlob.type === 'image/png') {
                pngBlob = originalImageBlob;
                console.log("Image is already PNG, skipping conversion.");
            } else {
                console.log(`Converting image from ${originalImageBlob.type} to PNG...`);
                pngBlob = await ImageProcessor.convertBlobToPNGBlob(originalImageBlob);
            }
        } catch (conversionError) {
            console.error("PNG Conversion failed:", conversionError);
            throw new Error("Failed to convert character image to PNG format for export.");
        }
        // --- END NEW CONVERSION STEP ---

        const v2Object = this._convertEllipsistoV2(story, narrative, primaryCharId);

        // Convert the *PNG* Blob to ArrayBuffer needed by _injectDataIntoPng
        const pngImageBuffer = await pngBlob.arrayBuffer();

        // Pass the PNG buffer to the injection function
        return this._injectDataIntoPng(pngImageBuffer, v2Object);
    },
    
    /**
     * Exports a narrative to the BYAF format.
     * @param {object} story - The story object.
     * @param {object} narrative - The narrative to export.
     * @param {string} primaryCharId - The ID of the primary character.
     * @returns {Promise<Blob>} A promise that resolves with a Blob of the final .byaf (zip) file.
     */
async exportStoryAsBYAF(story, narrative, primaryCharId) {
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        if (!primaryChar) throw new Error("BYAF export requires a selected primary character.");

        let imageBlob = null;
        let imageExtension = 'png'; // Default extension
        let imageFilename = null; // Filename including extension, derived later

        // --- IMAGE FETCHING LOGIC (Determine extension FIRST) ---
        try {
            const blob = await DBService.getImage(primaryChar.id);
            if (blob) {
                imageBlob = blob;
                const typeParts = blob.type.split('/');
                if (typeParts.length === 2 && ['png', 'jpeg', 'jpg', 'webp'].includes(typeParts[1])) {
                    imageExtension = typeParts[1] === 'jpeg' ? 'jpg' : typeParts[1];
                }
                console.log(`BYAF Export: Found local image (${imageBlob.type}), using extension: ${imageExtension}`);
            }
        } catch (dbError) {
            console.warn(`Could not get image from IDB for BYAF export ${primaryChar.id}:`, dbError);
        }

        if (!imageBlob && primaryChar.image_url && !primaryChar.image_url.startsWith('local_idb_')) {
            try {
                const response = await fetch(primaryChar.image_url);
                if (response.ok) {
                    const blob = await response.blob();
                    imageBlob = blob;
                    let determinedExt = 'png'; // Default inside this block
                     const contentType = response.headers.get('content-type');
                     if (contentType) {
                         const typeParts = contentType.split('/');
                         if (typeParts.length === 2 && ['png', 'jpeg', 'jpg', 'webp'].includes(typeParts[1])) {
                            determinedExt = typeParts[1] === 'jpeg' ? 'jpg' : typeParts[1];
                         }
                     } else {
                         const urlParts = primaryChar.image_url.split('.').pop()?.toLowerCase();
                         if (urlParts && ['png', 'jpg', 'jpeg', 'webp'].includes(urlParts)) {
                             determinedExt = urlParts === 'jpeg' ? 'jpg' : urlParts;
                         }
                     }
                     imageExtension = determinedExt; // Update the outer scope variable
                     console.log(`BYAF Export: Fetched legacy image (${contentType || 'unknown type'}), using extension: ${imageExtension}`);
                } else {
                     console.warn(`Failed to fetch legacy image URL for BYAF export ${primaryChar.id}: ${response.statusText}`);
                }
            } catch (fetchError) {
                console.warn(`Error fetching legacy image URL for BYAF export ${primaryChar.id}:`, fetchError);
            }
        }
        // --- END IMAGE FETCHING ---

        // --- GENERATE FILENAME (using character ID) ---
        if (imageBlob) {
             // Use character ID for the filename base, similar to example
            imageFilename = `${primaryChar.id}.${imageExtension}`;
        }

        // Call converter, passing the determined filename (or null if no image)
        const byafArchiveData = this._convertEllipsistoBYAF(story, narrative, primaryCharId, imageFilename);

        if (!byafArchiveData || !byafArchiveData.manifest || !byafArchiveData.character || !byafArchiveData.scenario) {
            throw new Error("Failed to generate BYAF data structure (converter returned invalid data).");
         }

        const zip = new JSZip();

        zip.file("manifest.json", JSON.stringify(byafArchiveData.manifest, null, 2));

        // --- CRITICAL: Use the character's ORIGINAL ID for the folder path ---
        const charFolder = zip.folder(`characters/${primaryChar.id}`);
        charFolder.file("character.json", JSON.stringify(byafArchiveData.character, null, 2));

        // Add the image blob if it exists, using the generated filename
        if (imageBlob && imageFilename) {
            charFolder.file(`images/${imageFilename}`, imageBlob);
             console.log(`BYAF Export: Added image blob as images/${imageFilename}`);
        } else {
            console.log("BYAF Export: No image blob found or added.");
        }

        zip.file(`scenarios/scenario1.json`, JSON.stringify(byafArchiveData.scenario, null, 2));

        return zip.generateAsync({ type: "blob" });
    },


    // --- Internal Parsing & Data Mapping Logic ---
    
    async _parseEllipsisJSON(file) {
        const jsonString = await file.text();
        const story = JSON.parse(jsonString);

        // Basic validation
        if (!story.id || !story.name || !story.characters) {
            throw new Error("Invalid Ellipsis JSON file. Missing required fields.");
        }
        // Re-randomize IDs to prevent conflicts in the library
        story.id = UTILITY.uuid();
        (story.characters || []).forEach(c => c.id = UTILITY.uuid());
        (story.scenarios || []).forEach(s => s.id = UTILITY.uuid());
        (story.narratives || []).forEach(n => {
            n.id = UTILITY.uuid();
            (n.state?.static_entries || []).forEach(e => e.id = UTILITY.uuid());
        });
        (story.dynamic_entries || []).forEach(e => e.id = UTILITY.uuid());
        
        return { story, imageBlob: null };
    },

    async _parseV2Card(file, skipImages) {
        const arrayBuffer = await file.arrayBuffer();
        const v2DataString = await this._extractV2Data(arrayBuffer);
        if (!v2DataString) throw new Error("No character data found in PNG file.");
        
        const v2RawData = JSON.parse(this._b64_to_utf8(v2DataString));
        const v2Data = v2RawData.data || v2RawData; // Handle both v1 and v2 spec

        let imageBlob = null;
		if (!skipImages) {
			imageBlob = await ImageProcessor.processImageAsBlob(file);
		}
		return { story: this._convertV2toEllipsis(v2Data), imageBlob };
    },

    async _parseBYAF(file, skipImages) {
        const zip = await JSZip.loadAsync(file);

        const characterFile = zip.file(/character\.json$/i)[0];
        const scenarioFile = zip.file(/scenario\d*\.json$/i)[0];
        const imageFile = zip.file(/\.png$/i)[0];

        if (!characterFile || !scenarioFile) {
            throw new Error("Archive is missing character.json or scenario.json.");
        }

        const byafData = {
            character: JSON.parse(await characterFile.async('string')),
            scenario: JSON.parse(await scenarioFile.async('string')),
        };

		let imageBlob = null;
		if (!skipImages && imageFile) {
			const imageFileBlob = await imageFile.async('blob');
			imageBlob = await ImageProcessor.processImageAsBlob(imageFileBlob);
		}
		return { story: this._convertBYAFtoEllipsis(byafData), imageBlob }; // Also correct the function call here
    },

    // --- Data Conversion Helpers (Import) ---

	_convertV2toEllipsis(v2Data) {
		const story = this._createEmptyEllipsisStory();
		story.name = v2Data.name || "Imported Character";
		story.tags = v2Data.tags || [];

		// Create User and AI Character with corrected variable names
		const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {user} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', tags:[], is_narrator: false };
		const aiChar = {
			id: UTILITY.uuid(),
			name: v2Data.name || "Imported Character",
			description: (v2Data.description || "").replace(/{{char}}/g, v2Data.name || "Imported Character").replace(/{{user}}/g, "You"),
			short_description: (v2Data.description || "").split('.')[0] + '.',
			model_instructions: (v2Data.system_prompt || "Act as {character}. Be descriptive and engaging.").replace(/{{char}}/g, "{character}").replace(/{{user}}/g, "{user}"),
			image_url: '',
			extra_portraits: [],
			tags: v2Data.tags || [],
			is_user: false,
			is_active: true,
			is_narrator: false
		};
		story.characters = [userChar, aiChar];

		// Map Lorebook -> Dynamic Entries
		if (v2Data.character_book && v2Data.character_book.entries) {
			story.dynamic_entries = v2Data.character_book.entries.map(entry => ({
				id: UTILITY.uuid(),
				title: (entry.keys || []).join(', ') || "Imported Lore",
				triggers: (entry.keys || []).join(', '),
				content: entry.content || "",
				triggered_at_turn: null
			}));
		}
		
		const firstMes = (v2Data.first_mes || `The story of ${aiChar.name} begins.`).replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, userChar.name);
		// Create Scenario and Narrative
		const scenario = { id: UTILITY.uuid(), name: "Imported Start", message: firstMes };
		story.scenarios.push(scenario);
				
		// Create a scenario for the main first_mes AND each alternate_greeting
		const allGreetings = [v2Data.first_mes || `The story of ${aiChar.name} begins.`];
		if (Array.isArray(v2Data.alternate_greetings)) {
			allGreetings.push(...v2Data.alternate_greetings);
		}
    
		story.scenarios = []; // Clear the default empty scenario
		allGreetings.forEach((greeting, index) => {
			const scenarioName = index === 0 ? "Imported Start" : `Alternate Start ${index}`;
			const messageContent = (greeting || "").replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, userChar.name);
			
			story.scenarios.push({
				id: UTILITY.uuid(),
				name: scenarioName,
				message: messageContent
			});
		});
		
		const narrative = this._createEmptyEllipsisNarrative("Imported Chat");

		// Parse V2 multi-turn example dialogues
			if (v2Data.mes_example) {
				const charNameIdMap = { '{{user}}': userChar.id, '{{char}}': aiChar.id };
				const regex = /({{user}}|{{char}}):([\s\S]*?)(?={{user}}:|{{char}}:|$)/g;
				
				let cleanedText = v2Data.mes_example.replace(/<START>/g).trim();
				
				for (const match of cleanedText.matchAll(regex)) {
					const speakerPrefix = match[1];
					const messageContent = match[2].trim().replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, userChar.name);
					const speakerId = charNameIdMap[speakerPrefix];

					if (speakerId && messageContent) {
						narrative.state.chat_history.push({
							character_id: speakerId,
							content: messageContent,
							type: 'chat',
							isHidden: true
						});
					}
				}
			}

			// Add the first message from the PRIMARY scenario to the chat history so it appears on load
			const firstScenario = story.scenarios[0];
			if (firstScenario && firstScenario.message) {
				narrative.state.chat_history.push({
					character_id: aiChar.id,
					content: firstScenario.message,
					type: 'chat',
					isHidden: false
				});
				narrative.state.messageCounter = 1;
			}
			
			story.narratives.push(narrative);
			return story;
		},

    _convertBYAFtoEllipsis(byafData) {
        const { character, scenario } = byafData;
        const story = this._createEmptyEllipsisStory();
        story.name = character.displayName || character.name || "Imported Character";
        story.tags = character.tags || [];

        const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', tags:[], is_narrator: false };
        const aiChar = {
            id: UTILITY.uuid(),
            name: character.displayName || character.name,
            description: character.persona || "",
            short_description: (character.persona || "").split('.')[0] + '.',
            model_instructions: scenario.formattingInstructions || "Act as {character}. Be descriptive and engaging.",
            image_url: '',
            extra_portraits: [],
            tags: character.tags || [],
            is_user: false,
            is_active: true,
            is_narrator: false
        };
        story.characters = [userChar, aiChar];

        // Map Lore Items -> Dynamic Entries
        if (character.loreItems) {
            story.dynamic_entries = character.loreItems.map(item => ({
                id: UTILITY.uuid(),
                title: item.key || "Imported Lore",
                triggers: item.key || "",
                content: item.value || "",
                triggered_at_turn: null
            }));
        }

        const firstMes = (scenario.firstMessages && scenario.firstMessages[0]?.text) || `The story of ${aiChar.name} begins.`;
        const newScenario = { id: UTILITY.uuid(), name: "Imported Start", message: firstMes };
        story.scenarios.push(newScenario);

        const narrative = this._createEmptyEllipsisNarrative("Imported Chat");
		
		 // Correctly map the BYAF scenario's 'narrative' field to a static entry
		if (scenario.narrative) {
			narrative.state.static_entries.push({
				id: UTILITY.uuid(),
				title: "Starting Scenario",
				content: scenario.narrative
			});
		}
	
// [FIX] Parse multi-turn example dialogues from BYAF format
    if (scenario.exampleMessages && scenario.exampleMessages.length > 0) {
        const charNameIdMap = { '#{character}:': aiChar.id, '#{user}:': userChar.id };
        const regex = /(#\{(?:character|user)\}:)([\s\S]*?)(?=#\{|$)/g;

        scenario.exampleMessages.forEach(msg => {
            const exampleText = msg.text || "";
            for (const match of exampleText.matchAll(regex)) {
                const speakerPrefix = match[1];
                const messageContent = match[2].trim();
                const speakerId = charNameIdMap[speakerPrefix];

                if (speakerId && messageContent) {
                    narrative.state.chat_history.push({
                        character_id: speakerId,
                        content: messageContent,
                        type: 'chat',
                        emotion: 'neutral',
                        timestamp: new Date().toISOString(),
                        isHidden: true
                    });
                }
            }
        });
	}
		
		// Add the first message to the chat history so it appears on load
		if (firstMes) {
			narrative.state.chat_history.push({
				character_id: aiChar.id,
				content: firstMes,
				type: 'chat',
				emotion: 'neutral',
				timestamp: new Date().toISOString(),
				isHidden: false // Ensure it's a visible message
			});
			narrative.state.messageCounter = 1;
		}

		story.narratives.push(narrative);
		return story;
	},

    // --- Data Conversion Helpers (Export) ---

_convertEllipsistoV2(story, narrative, primaryCharId) {
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        // Find other AI characters (excluding user and primary)
        const otherAiChars = story.characters.filter(c => !c.is_user && c.id !== primaryCharId);
        // Find the user character
        const userChar = story.characters.find(c => c.is_user);

        if (!primaryChar) {
            // Should have been caught earlier, but double-check
            throw new Error("Primary character not found during V2 conversion.");
        }

        // --- Prepare Merged Description ---
        let fullDescription = primaryChar.description || "";
        if (otherAiChars.length > 0) {
            fullDescription += "\n\n--- Other Characters ---\n";
            otherAiChars.forEach(char => {
                fullDescription += `\nName: ${char.name || 'Unnamed Character'}\nDescription: ${char.description || '(No description)'}\n`;
            });
        }

        // --- Prepare Character Book Entries ---
        const bookEntries = [];
        let insertionCounter = 0; // Simple counter for insertion_order

        // Map dynamic entries
        (story.dynamic_entries || []).forEach(entry => {
            bookEntries.push({
                keys: (entry.triggers || entry.title || "").split(',').map(t => t.trim()).filter(Boolean),
                content: entry.content || "",
                enabled: true, // Mandatory field
                insertion_order: insertionCounter++, // Mandatory field
                extensions: {}, // Mandatory field
                // Add other optional fields with defaults if desired (e.g., case_sensitive: false)
                case_sensitive: false,
            });
        });

        // Map world map locations
        (narrative.state.worldMap?.grid || [])
            .filter(loc => loc.name) // Only include locations with names
            .forEach(loc => {
                bookEntries.push({
                    keys: [loc.name], // Use location name as the key
                    content: `Location Description: ${loc.description || '(No description)'}\n\nLocation Prompt: ${loc.prompt || '(No prompt)'}`,
                    enabled: true,
                    insertion_order: insertionCounter++,
                    extensions: {},
                    case_sensitive: false,
                });
             });

        // Map local static entries for the *current* location in the narrative state
         const currentLocCoords = narrative.state.worldMap?.currentLocation;
         if (currentLocCoords) {
            const currentLocData = narrative.state.worldMap.grid.find(l => l.coords.x === currentLocCoords.x && l.coords.y === currentLocCoords.y);
            if (currentLocData && currentLocData.local_static_entries) {
                currentLocData.local_static_entries.forEach(entry => {
                     bookEntries.push({
                        keys: [(entry.title || "Local Lore").toLowerCase()], // Use title as key
                        content: entry.content || "",
                        enabled: true,
                        insertion_order: insertionCounter++,
                        extensions: {},
                        case_sensitive: false,
                    });
                });
            }
         }


        // --- Prepare Example Messages ---
        // Replace placeholders correctly for V2 format ({character} -> {{char}}, {user} -> {{user}})
        const replacePlaceholdersV2 = (text) => {
            if (typeof text !== 'string') return '';
            let processed = text.replace(/{character}/gi, '{{char}}'); // Replace your format
            processed = processed.replace(/{user}/gi, '{{user}}');     // Replace your format
            // Ensure standard {{char}} and {{user}} are present if original was different
            processed = processed.replace(/\{\{char\}\}/gi, '{{char}}');
            processed = processed.replace(/\{\{user\}\}/gi, '{{user}}');
            return processed;
        }

        // Map hidden messages to mes_example
        const mesExample = (narrative.state.chat_history || [])
            .filter(m => m.isHidden && m.type === 'chat')
            .map(m => {
                const speaker = story.characters.find(c => c.id === m.character_id);
                if (speaker) {
                     // Use V2 placeholders
                    const prefix = speaker.is_user ? '{{user}}:' : '{{char}}:';
                    return `${prefix}\n${replacePlaceholdersV2(m.content)}`;
                }
                return replacePlaceholdersV2(m.content); // Fallback if speaker somehow missing
            })
            .join('\n'); // V2 spec doesn't specify separator, newline seems common

        // Find the first non-hidden message for first_mes
        const firstMessageEntry = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
        const firstMes = firstMessageEntry ? replacePlaceholdersV2(firstMessageEntry.content) : replacePlaceholdersV2(`The story of ${primaryChar.name} begins.`);


        // --- Construct the V2 Data Object ---
		// --- Prepare Scenario Field from Static Entries ---
        const scenarioText = (narrative.state.static_entries || [])
            .map(entry => `[${entry.title || 'Untitled Entry'}]\n${entry.content || '(No content)'}`)
            .join('\n\n---\n\n'); // Use a clear separator between entries
			
        const v2Data = {
            // V1 Fields (Required by convention within V2 data)
            name: primaryChar.name || "",
            description: replacePlaceholdersV2(fullDescription), // Ensure placeholders are V2 style
            personality: "", // Add mandatory empty V1 field
            scenario: replacePlaceholdersV2(scenarioText),
            first_mes: firstMes,
            mes_example: mesExample,

            // V2 Fields
            creator_notes: "", // Optional, default empty
            system_prompt: replacePlaceholdersV2(primaryChar.model_instructions || ""), // Ensure V2 placeholders
            post_history_instructions: "", // Optional, default empty
            alternate_greetings: [], // Mandatory empty array
            character_book: {
                name: "", // Optional book name
                description: "", // Optional book description
                scan_depth: 100, // Example value, adjust if needed
                token_budget: 2048, // Example value
                recursive_scanning: false, // Default
                extensions: {}, // Mandatory empty object
                entries: bookEntries // Use the prepared entries array
            },
            tags: primaryChar.tags || [], // Mandatory (can be empty array)
            creator: "", // Optional, default empty
            character_version: "", // Optional, default empty
            // --- CRITICAL: Add mandatory extensions object ---
            extensions: {}
        };

        // --- Construct the Final V2 Object ---
        const v2Object = {
            spec: 'chara_card_v2',      // Mandatory
            spec_version: '2.0',        // Mandatory
            data: v2Data
        };

        return v2Object; // This object will be passed to _injectDataIntoPng
    },
    
// MODIFIED: Added imageFilename parameter
    _convertEllipsistoBYAF(story, narrative, primaryCharId, imageFilename = null) { // Expect full filename or null
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        const userChar = story.characters.find(c => c.is_user); // Needed for example messages

        if (!primaryChar) {
             console.error("Primary character not found in _convertEllipsistoBYAF");
             return { manifest: {}, character: {}, scenario: {} }; // Return empty structure on error
        }
        const now = new Date().toISOString();

        // Map dynamic entries and world map locations
        const loreItems = [
            ...(story.dynamic_entries || []),
            ...(narrative.state.worldMap?.grid || [])
                .filter(loc => loc.name) // Ensure location has a name
                .map(loc => ({ // Map grid locations to lore item structure
                    id: UTILITY.uuid(), // Generate unique ID for the lore item itself
                    title: loc.name,
                    triggers: loc.name, // Use name as trigger key
                    content: `Description: ${loc.description || '(no description)'}\n\nPrompt: ${loc.prompt || '(no prompt)'}`
                }))
        ].map((entry, index) => ({
            id: entry.id || UTILITY.uuid(), // Use existing ID if available, else generate
            // --- ADDED: Simple random string for order ---
            order: Math.random().toString(36).substring(2, 12), // Placeholder order
            key: entry.triggers || entry.title || `Imported Lore ${index + 1}`,
            value: entry.content || "",
            createdAt: entry.created_date || now, // Use original creation date if possible
            updatedAt: entry.last_modified || now // Use original modified date if possible
        }));


        const character = {
            schemaVersion: 1,
            name: primaryChar.name || "",
            displayName: primaryChar.name || "", // Often used for a shorter/display name
             // --- MODIFIED: Use the passed filename ---
            images: imageFilename ? [{ path: `images/${imageFilename}`, label: "" }] : [],
            createdAt: primaryChar.created_date || now, // Try to preserve original dates
            updatedAt: primaryChar.last_modified || now,
            // --- CRITICAL: Use the character's ORIGINAL ID ---
            id: primaryChar.id,
            isNSFW: false, // Assuming false
            persona: primaryChar.description || "",
            loreItems: loreItems,
            tags: primaryChar.tags || []
        };

        const firstMessageEntry = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
        // Use the actual first message content if found, otherwise a default
        const firstMessageText = firstMessageEntry ? firstMessageEntry.content : `The story of ${primaryChar.name} begins.`;

        // Filter for hidden messages and map them correctly
        const exampleMessages = (narrative.state.chat_history || [])
            .filter(m => m.isHidden && m.type === 'chat')
            .map(m => {
                const speaker = story.characters.find(c => c.id === m.character_id);
                let byafFormattedText = m.content || ""; // Ensure content exists
                let msgCharId = null;

                // Add BYAF prefixes and set characterID appropriately
                if (speaker) {
                    if (speaker.is_user) {
                        byafFormattedText = `#{user}:\n${byafFormattedText}`;
                        // characterID should be null/absent for user messages in exampleMessages
                    } else if (speaker.id === primaryChar.id) { // Only map the primary character
                        byafFormattedText = `#{character}:\n${byafFormattedText}`;
                         // --- CRITICAL: Use the character's ORIGINAL ID ---
                        msgCharId = primaryChar.id;
                    } else {
                         // Optional: Handle other AI chars differently? For now, skip prefix/ID.
                         // Or maybe add their name? Let's just include the text.
                    }
                }

                return {
                    text: byafFormattedText,
                    characterID: msgCharId // Will be null for user or non-primary AI
                };
            })
            // Optional: Filter out messages that didn't belong to user or primary AI, if desired
            // .filter(m => m.text.startsWith('#{user}:') || m.text.startsWith('#{character}:'));

        // --- ADDED: Missing fields with defaults ---
        const scenario = {
            schemaVersion: 1,
            title: narrative.name || "Exported Scenario", // Use narrative name or placeholder
            canDeleteExampleMessages: true, // Default
            exampleMessages: exampleMessages, // Use the correctly mapped array
            model: "", // Default empty
            temperature: 1.0, // Default
            topP: 0.9, // Default
            minP: 0.1, // Default
             // --- CRITICAL: Use the character's ORIGINAL ID ---
            firstMessages: [{ text: firstMessageText, characterID: primaryChar.id }],
            formattingInstructions: primaryChar.model_instructions || "",
            grammar: "", // Default empty
            repeatPenalty: 1.05, // Default
            repeatLastN: 256, // Default
            topK: 30, // Default
            minPEnabled: false, // Default - Match example (was true)
             // Use static entry if exists, else empty string
            narrative: (narrative.state.static_entries || []).find(e => e.title === "Starting Scenario")?.content || "",
            promptTemplate: null, // Default
            messages: [] // Default empty
        };

        const manifest = {
            schemaVersion: 1,
            createdAt: now,
            // --- CRITICAL: Use the character's ORIGINAL ID in the path ---
            characters: [ `characters/${primaryChar.id}/character.json` ],
            scenarios: [ `scenarios/scenario1.json` ] // Assuming only one scenario export
        };

        return { manifest, character, scenario };
    },

    // --- Low-Level File and Helper Functions ---
    
    _createEmptyEllipsisStory() {
        return {
            id: UTILITY.uuid(),
            name: "New Imported Story",
            last_modified: new Date().toISOString(),
            created_date: new Date().toISOString(),
            ...UTILITY.getDefaultApiSettings(),
            ...UTILITY.getDefaultUiSettings(),
            ...UTILITY.getDefaultSystemPrompts(),
            characters: [],
            dynamic_entries: [],
            scenarios: [],
            narratives: []
        };
    },
    
    _createEmptyEllipsisNarrative(name) {
        return {
            id: UTILITY.uuid(), name: name,
            last_modified: new Date().toISOString(),
            state: {
                chat_history: [], messageCounter: 0, static_entries: [],
                worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: {x:null, y:null}, path:[] }
            }
        };
    },

    _b64_to_utf8(str) {
        return decodeURIComponent(escape(atob(str)));
    },

    _utf8_to_b64(str) {
        return btoa(unescape(encodeURIComponent(str)));
    },

    async _extractV2Data(arrayBuffer) {
        const dataView = new DataView(arrayBuffer);
        const PNG_SIGNATURE = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
        for (let i = 0; i < PNG_SIGNATURE.length; i++) { if (dataView.getUint8(i) !== PNG_SIGNATURE[i]) throw new Error("Invalid PNG signature."); }
        let offset = 8;
        while (offset < arrayBuffer.byteLength) {
            const length = dataView.getUint32(offset);
            const type = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer, offset + 4, 4));
            if (['tEXt', 'zTXt'].includes(type)) {
                let keywordEnd = -1;
                for (let i = 0; i < length; i++) { if (dataView.getUint8(offset + 8 + i) === 0) { keywordEnd = i; break; } }
                if (keywordEnd !== -1) {
                    const keyword = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8, keywordEnd));
                    if (keyword === 'chara') {
                        if (type === 'tEXt') return new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8 + keywordEnd + 1, length - keywordEnd - 1));
                        if (type === 'zTXt') return new TextDecoder().decode(pako.inflate(new Uint8Array(arrayBuffer, offset + 8 + keywordEnd + 2, length - keywordEnd - 2)));
                    }
                }
            }
            if (type === 'IEND') break;
            offset += 12 + length;
        }
        return null;
    },

async _injectDataIntoPng(imageBuffer, v2Object) {
        // Standard PNG CRC32 calculation table and function
        const _CRC_TABLE = Array.from({ length: 256 }, (_, n) => { let c = n; for (let k = 0; k < 8; k++) c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1); return c; });
        const _crc32 = (bytes) => { let crc = -1; for (const byte of bytes) crc = (crc >>> 8) ^ _CRC_TABLE[(crc ^ byte) & 0xff]; return (crc ^ -1) >>> 0; };

// --- Prepare data for zTXt chunk (Compressed) ---
        // 1. Stringify the V2 character data object
        const jsonDataString = JSON.stringify(v2Object);
        // 2. Base64 encode the JSON string
        const base64Data = this._utf8_to_b64(jsonDataString);
        // 3. Get the raw bytes *of the Base64 string itself*
        const base64Bytes = new TextEncoder().encode(base64Data);
        // 4. Compress these bytes using pako (DEFLATE)
        const compressedData = pako.deflate(base64Bytes);
        // 5. Define the keyword
        const keyword = 'chara';

        // 6. Create the chunk data for zTXt: keyword + null separator + compression method (0) + compressed data
        const keywordBytes = new TextEncoder().encode(keyword);
        const chunkData = new Uint8Array(keywordBytes.length + 1 + 1 + compressedData.length);

        chunkData.set(keywordBytes);                      // Keyword: "chara"
        chunkData[keywordBytes.length] = 0;               // Null separator
        chunkData[keywordBytes.length + 1] = 0;           // Compression method (0 = DEFLATE)
        chunkData.set(compressedData, keywordBytes.length + 2); // Compressed data bytes

        // 7. Define the chunk type as zTXt
        const chunkType = new TextEncoder().encode('zTXt');
        // --- End Corrected Data Preparation ---

        // Prepare data for CRC calculation (Chunk Type + Chunk Data)
        const dataForCrc = new Uint8Array(chunkType.length + chunkData.length);
        dataForCrc.set(chunkType);
        dataForCrc.set(chunkData, chunkType.length);
        const crc = _crc32(dataForCrc); // Calculate CRC

        // --- Inject the chunk before IEND using proper chunk iteration ---
        const originalPng = new Uint8Array(imageBuffer);
        const dataView = new DataView(originalPng.buffer);
        let iendOffset = -1; // This will store the starting offset of the IEND chunk
        let offset = 8;      // Start after PNG signature

        while (offset < originalPng.length) {
            // Read chunk length (data length) - 4 bytes, Big Endian
            const length = dataView.getUint32(offset);
            // Read chunk type - 4 bytes
            const type = String.fromCharCode.apply(null, originalPng.slice(offset + 4, offset + 8));

            if (type === 'IEND') {
                iendOffset = offset; // Found the start of the IEND chunk
                break;
            }

            // Move to the next chunk: current offset + chunk header (8 bytes) + data length + CRC (4 bytes)
            offset += 12 + length;
        }


        if (iendOffset === -1) {
             console.error("Original PNG Data (first 50 bytes):", originalPng.slice(0, 50));
             throw new Error('Could not find IEND chunk using proper iteration. The image data might be corrupted or not a valid PNG.');
        }

        // Calculate new PNG size: Original up to IEND + New Chunk (12 bytes header/CRC + data length) + IEND chunk (12 bytes)
        const newChunkLength = chunkData.length;
        const newPngSize = iendOffset + (12 + newChunkLength) + 12;
        const newPng = new Uint8Array(newPngSize);
        const newPngView = new DataView(newPng.buffer);

        // 1. Copy original PNG data up to the point where IEND starts
        newPng.set(originalPng.slice(0, iendOffset));

        // 2. Write the new zTXt chunk
        let writeOffset = iendOffset;
        newPngView.setUint32(writeOffset, newChunkLength);      // Length of chunk data
        writeOffset += 4;
        newPng.set(chunkType, writeOffset);                     // Chunk Type ("zTXt")
        writeOffset += chunkType.length;
        newPng.set(chunkData, writeOffset);                     // Chunk Data (keyword \0 method \0 compressed_data)
        writeOffset += chunkData.length;
        newPngView.setUint32(writeOffset, crc);                 // CRC of Type+Data
        writeOffset += 4;

        // 3. Write the original IEND chunk (always 12 bytes: 0 length, "IEND" type, CRC)
        newPng.set(originalPng.slice(iendOffset, iendOffset + 12), writeOffset);

        return new Blob([newPng], { type: 'image/png' });
    }
};



    <!-- PASTE content of ui.js HERE -->
/**
 * =================================================================================================
 * UIManager Module (The View)
 * =================================================================================================
 * This module is exclusively responsible for all direct DOM manipulation. It reads data
 * from the StateManager to render the UI but does not modify the application's state itself.
 */
const UIManager = {
    // Holds temporary, non-persistent properties related to the app's runtime behavior.
    RUNTIME: {
        streamingInterval: null,
        titleTimeout: null,
        lastCinematicImageUrl: null,
        activeCinematicBg: 1,
		globalBackgroundImageCache: null,
    },
    
    /**
     * Returns the SVG icon string for AI generation buttons.
     * @returns {string} SVG HTML string.
     */
    getAIGenIcon() {
        return `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 3.5a1.5 1.5 0 011.5 1.5V6a1.5 1.5 0 01-3 0V5A1.5 1.5 0 0110 3.5zM5.429 7.429a1.5 1.5 0 012.121 0l1.061 1.061a1.5 1.5 0 01-2.121 2.121L5.429 9.55a1.5 1.5 0 010-2.121zM14.571 7.429a1.5 1.5 0 010 2.121l-1.061 1.061a1.5 1.5 0 01-2.121-2.121l1.061-1.061a1.5 1.5 0 012.121 0zM10 16.5a1.5 1.5 0 01-1.5-1.5V14a1.5 1.5 0 013 0v1a1.5 1.5 0 01-1.5 1.5z"></path></svg>`;
    },

    /**
     * Renders all primary UI components. Called on initial load and after major state changes.
     */
    renderAll() { 
        const state = StateManager.getState();
        if (state && state.narrativeName) {
            document.getElementById('story-title-input').value = state.narrativeName;
            const mobileTitle = document.getElementById('mobile-story-title-overlay');
            if (mobileTitle) mobileTitle.value = state.narrativeName;
        }
        this.renderCharacters(); 
        this.renderStaticEntries(); 
        this.renderDynamicEntries(); 
        this.renderChat(); 
        this.updateAICharacterSelector(); 
    },

    /**
     * Renders the main story library interface, including search, sort, and filter controls.
     * @param {object} [filterState={}] - The current state of the filters (searchTerm, sortBy, filterTag).
     */
    renderLibraryInterface(filterState = {}) {
        const library = StateManager.getLibrary();
        const container = document.getElementById('library-content-container');
        const { searchTerm = '', sortBy = 'last_modified', filterTag = '' } = filterState;

        const isTallScreen = window.innerHeight > window.innerWidth;

        // --- Filter, Search, Sort Logic ---
        let stories = [...library.stories];
        if (searchTerm) {
            const lowerCaseSearch = searchTerm.toLowerCase();
            stories = stories.filter(s => s.search_index && s.search_index.includes(lowerCaseSearch));
        }
        if (filterTag) {
            stories = stories.filter(s => {
                const storyTags = new Set(s.tags || []);
                (s.characters || []).forEach(c => (c.tags || []).forEach(t => storyTags.add(t)));
                return storyTags.has(filterTag);
            });
        }
        stories.sort((a, b) => {
            if (sortBy === 'name') return (a.name || '').localeCompare(b.name || '');
            if (sortBy === 'created_date') return new Date(b.created_date) - new Date(a.created_date);
            return new Date(b.last_modified) - new Date(a.last_modified);
        });

        // --- Controls HTML ---
        const tagOptions = library.tag_cache.map(tag => `<option value="${tag}" ${filterTag === tag ? 'selected':''}>${tag}</option>`).join('');
        const controlsHTML = `
            <div class="p-6 border-b border-gray-700 space-y-4">
                <input type="search" placeholder="Search stories..." value="${searchTerm}" oninput="UIManager.renderLibraryInterface({searchTerm: this.value, sortBy: document.getElementById('sort-by').value, filterTag: document.getElementById('filter-by-tag').value})" class="w-full bg-black/30 p-2 rounded-lg border-gray-600">
                <div class="flex space-x-4">
                    <select id="sort-by" onchange="UIManager.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: this.value, filterTag: document.getElementById('filter-by-tag').value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="last_modified" ${sortBy === 'last_modified' ? 'selected' : ''}>Modified</option>
                        <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Name</option>
                        <option value="created_date" ${sortBy === 'created_date' ? 'selected' : ''}>Created</option>
                    </select>
                    <select id="filter-by-tag" onchange="UIManager.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: document.getElementById('sort-by').value, filterTag: this.value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="">All Tags</option>
                        ${tagOptions}
                    </select>
                </div>
            </div>`;

        // --- Story List HTML ---
        const storyListHTML = stories.map(story => {
            const displayName = story.name || 'Untitled Story';
            const isActiveStory = story.id === library.active_story_id;
            return `
            <div class="p-4 rounded-lg flex justify-between items-center cursor-pointer ${isActiveStory ? 'bg-indigo-600/30' : 'bg-gray-700/50 hover:bg-gray-600/50'}" onclick="UIManager.openStoryDetails('${story.id}')">
                <div>
                    <h3 class="font-semibold text-lg">${UTILITY.escapeHTML(displayName)}</h3>
                    <p class="text-sm text-gray-400">Modified: ${new Date(story.last_modified).toLocaleString()}</p>
                </div>
                ${isActiveStory ? '<span class="text-xs text-indigo-300 font-bold">ACTIVE</span>' : ''}
            </div>
        `}).join('<hr class="border-gray-700 my-2">');

        // --- Assemble Final Layout ---
        if (isTallScreen) {
             container.innerHTML = `<div class="flex flex-col flex-grow min-h-0">${controlsHTML}<div class="p-6 overflow-y-auto">${storyListHTML}</div></div>`;
        } else {
            container.innerHTML = `
                <div class="w-[450px] flex-shrink-0 border-r border-gray-700 flex flex-col">${controlsHTML}<div class="p-6 overflow-y-auto flex-grow">${storyListHTML}</div></div>
                <div id="story-details-content-desktop" class="flex-grow p-6 flex text-gray-500"><div class="w-full h-full flex items-center justify-center">Select a story to see details...</div></div>
            `;
        }
    },

    /**
     * Renders the detailed view for a selected story, showing its scenarios and narratives.
     * @param {string} storyId - The ID of the story to display.
     */
    openStoryDetails(storyId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (!story) return;

        const scenariosHTML = (story.scenarios || []).map(scenario => `
            <div class="bg-gray-700/30 p-3 rounded-lg flex justify-between items-center gap-2">
                <p class="font-semibold flex-grow">${UTILITY.escapeHTML(scenario.name)}</p>
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button onclick="Controller.createNarrativeFromScenario('${story.id}', '${scenario.id}')" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold p-2 rounded-lg" title="Load Scenario (Creates New Narrative)"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg></button>
                    <button onclick="Controller.duplicateScenario('${story.id}', '${scenario.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold p-2 rounded-lg" title="Duplicate Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                    <button onclick="Controller.deleteScenario('${story.id}', '${scenario.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold p-2 rounded-lg" title="Delete Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            </div>
        `).join('');

        const narrativesHTML = (story.narratives || []).sort((a, b) => new Date(b.last_modified) - new Date(a.last_modified)).map(narrative => `
            <div class="bg-gray-700/60 p-3 rounded-lg flex justify-between items-center gap-2">
                <div class="flex-grow">
                    <p class="font-semibold">${UTILITY.escapeHTML(narrative.name)}</p>
                    <p class="text-xs text-gray-400">Modified: ${new Date(narrative.last_modified).toLocaleString()}</p>
                </div>
                ${narrative.id === library.active_narrative_id && story.id === library.active_story_id ? '<span class="text-xs text-sky-300 font-bold flex-shrink-0">ACTIVE</span>' : ''}
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button onclick="Controller.elevateNarrativeToScenario('${story.id}', '${narrative.id}')" class="bg-teal-600 hover:bg-teal-500 text-white font-bold p-2 rounded-lg" title="Elevate to Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 11l3-3m0 0l3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"></path></svg></button>
                    <button onclick="Controller.loadNarrative('${story.id}', '${narrative.id}')" class="bg-green-600 hover:bg-green-500 text-white font-bold p-2 rounded-lg" title="Load Narrative"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>
                    <button onclick="Controller.duplicateNarrative('${story.id}', '${narrative.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold p-2 rounded-lg" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                    <button onclick="Controller.deleteNarrative('${story.id}', '${narrative.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold p-2 rounded-lg" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            </div>
        `).join('');

        const detailsHTML = `
            <div class="relative w-full h-full bg-black/20 overflow-hidden flex flex-col">
                <div class="relative w-full aspect-video flex-shrink-0">
                     <div id="details-carousel" class="w-full h-full"></div>
                     <div class="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-black/80 via-black/30 to-transparent pointer-events-none z-10"></div>
                     <h3 class="absolute top-4 left-4 text-white text-2xl font-bold drop-shadow-lg z-20">${UTILITY.escapeHTML(story.name || 'Untitled Story')}</h3>
                </div>
                <div class="p-6 flex-grow overflow-y-auto space-y-6 min-h-0">
                     <div>
                        <h4 class="font-bold text-lg mb-2 text-indigo-300">Scenarios (Templates)</h4>
                        <div class="space-y-2">${scenariosHTML || '<p class="text-sm text-gray-400">No scenarios in this story.</p>'}</div>
                     </div>
                     <hr class="border-gray-600">
                     <div>
                        <h4 class="font-bold text-lg mb-2 text-sky-300">Narratives (Chats)</h4>
                        <div class="space-y-2">${narrativesHTML || '<p class="text-sm text-gray-400">No narratives yet. Load a scenario to start one.</p>'}</div>
                     </div>
                      <hr class="border-gray-600">
                     <div class="flex space-x-2">
                        <button onclick="Controller.renameStoryPrompt('${story.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg" title="Rename"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button onclick="Controller.duplicateStory('${story.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                        <button onclick="Controller.deleteStory('${story.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-3 rounded-lg" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                     </div>
                </div>
            </div>
        `;

        if (window.innerHeight > window.innerWidth) {
            document.getElementById('story-details-content-mobile').innerHTML = detailsHTML;
            Controller.openModal('story-details-modal');
            this.startCarousel(story.characters, 'details-carousel');
        } else {
            document.getElementById('story-details-content-desktop').innerHTML = detailsHTML;
            this.startCarousel(story.characters, 'details-carousel');
        }
    },

    /**
     * Starts an image carousel for the story details view.
     * @param {Array} characters - The characters from the story.
     * @param {string} containerId - The ID of the element to host the carousel.
     */
    startCarousel(characters, containerId) {
        if (ModalManager.RUNTIME.carousel_interval) clearInterval(ModalManager.RUNTIME.carousel_interval);
        
        const container = document.getElementById(containerId);
        if (!container) return;

		const images = (characters || [])
		  .map(c => UIManager.getPortraitSrc(c))
		  .filter(Boolean);

        if (images.length === 0) {
            container.innerHTML = `<div class="w-full h-full flex items-center justify-center bg-gray-900 text-gray-500">No character images</div>`;
            return;
        }

        container.innerHTML = `
            <img id="${containerId}-img1" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 1;">
            <img id="${containerId}-img2" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 0;">
        `;
        
        let currentIndex = 0;
        let activeImg = 1;

        const img1 = document.getElementById(`${containerId}-img1`);
        const img2 = document.getElementById(`${containerId}-img2`);
        img1.src = images[currentIndex];
        
        ModalManager.RUNTIME.carousel_interval = setInterval(() => {
            currentIndex = (currentIndex + 1) % images.length;
            if (activeImg === 1) {
                img2.src = images[currentIndex];
                img1.style.opacity = 0;
                img2.style.opacity = 1;
                activeImg = 2;
            } else {
                img1.src = images[currentIndex];
                img1.style.opacity = 1;
                img2.style.opacity = 0;
                activeImg = 1;
            }
        }, 4000);
    },
    
    renderCharacters() { 
        const state = StateManager.getState();
        const container = document.getElementById('characters-container');
        if (!state.characters) {
            container.innerHTML = '';
            return;
        }
        container.innerHTML = state.characters.map(char => {
            const tagsHTML = (char.tags || []).map(tag => `<span class="bg-indigo-500/50 text-indigo-200 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${UTILITY.escapeHTML(tag)}</span>`).join('');
            return `
                <div onclick="Controller.openModal('character-detail-modal', '${char.id}')" 
                     class="char-roster-btn" 
                     style="background-image: url('${UIManager.RUNTIME.characterImageCache[char.id] || char.image_url || 'https://placehold.co/600x800/111827/4b5563?text=?'}')">
                    <div class="char-roster-content text-white">
                        <h3 class="font-bold text-lg truncate">${UTILITY.escapeHTML(char.name)}</h3>
                        <p class="text-sm text-gray-300 italic truncate">${UTILITY.escapeHTML(char.short_description)}</p>
                        <div class="mt-2 h-6 overflow-hidden">${tagsHTML}</div>
                    </div>
                </div>
            `;
        }).join('');
    },

    renderKnowledgeModalTabs() {
        const tabName = Controller.RUNTIME.activeKnowledgeTab;
        const staticTab = document.getElementById('knowledge-tab-static');
        const dynamicTab = document.getElementById('knowledge-tab-dynamic');
        const staticContent = document.getElementById('knowledge-static-content');
        const dynamicContent = document.getElementById('knowledge-dynamic-content');
        const addButton = document.getElementById('knowledge-add-button');

        if (tabName === 'static') {
            staticContent.classList.remove('hidden');
            dynamicContent.classList.add('hidden');
            staticTab.classList.add('border-indigo-500', 'text-white');
            staticTab.classList.remove('border-transparent', 'text-gray-400');
            dynamicTab.classList.add('border-transparent', 'text-gray-400');
            dynamicTab.classList.remove('border-indigo-500', 'text-white');
            addButton.onclick = () => Controller.addStaticEntry();
            this.renderStaticEntries();
        } else { // dynamic
            dynamicContent.classList.remove('hidden');
            staticContent.classList.add('hidden');
            dynamicTab.classList.add('border-indigo-500', 'text-white');
            dynamicTab.classList.remove('border-transparent', 'text-gray-400');
            staticTab.classList.add('border-transparent', 'text-gray-400');
            staticTab.classList.remove('border-indigo-500', 'text-white');
            addButton.onclick = () => Controller.addDynamicEntry();
            this.renderDynamicEntries();
        }
    },
    
    renderStaticEntries() { 
        const state = StateManager.getState(); 
        document.getElementById('static-entries-list').innerHTML = (state.static_entries || []).map(entry => `<div onclick="Controller.selectStaticEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${state.selectedStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}"><h4 class="font-semibold truncate">${UTILITY.escapeHTML(entry.title)}</h4></div>`).join(''); 
        this.renderStaticEntryDetails(); 
    },
    
    renderStaticEntryDetails() { 
        const state = StateManager.getState(); 
        const container = document.getElementById('static-entry-details-content'); 
        const entry = (state.static_entries || []).find(e => e.id === state.selectedStaticEntryId); 
        if (entry) { 
            container.innerHTML = `
            <div class="flex flex-col h-full">
				<input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateStaticEntryField('${entry.id}', 'title', this.value)" onblur="UIManager.renderStaticEntries()" class="text-xl font-bold bg-black/30 p-2 w-full mb-4 flex-shrink-0">
                <div class="relative flex-grow">
                    <textarea oninput="Controller.updateStaticEntryField('${entry.id}', 'content', this.value)" class="w-full h-full bg-black/30 p-2 resize-none rounded-md">${UTILITY.escapeHTML(entry.content)}</textarea>
                    <button onclick="Controller.generateStaticEntryContentAI(event, '${entry.id}')" class="absolute top-2 right-2 text-sky-400 hover:text-sky-300 p-1 bg-sky-600/80 rounded" title="Generate with AI">${this.getAIGenIcon()}</button>
                </div>
                <div class="flex justify-end mt-4 flex-shrink-0">
                    <button onclick="Controller.deleteStaticEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button>
                </div>
            </div>`; 
        } else { 
            container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div>`; 
        } 
    },
    
    renderDynamicEntries() { 
        const state = StateManager.getState(); 
        document.getElementById('dynamic-entries-list').innerHTML = (state.dynamic_entries || []).map(entry => `<div onclick="Controller.selectDynamicEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${state.selectedDynamicEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} flex justify-between items-center"><h4 class="font-semibold truncate">${UTILITY.escapeHTML(entry.title)}</h4> ${entry.triggered_at_turn !== null ? '<span class="text-xs text-sky-300">ACTIVE</span>' : ''}</div>`).join(''); 
        this.renderDynamicEntryDetails(); 
    },
    
    renderDynamicEntryDetails() { 
        const state = StateManager.getState();
        const container = document.getElementById('dynamic-entry-details-content'); 
        const entry = (state.dynamic_entries || []).find(e => e.id === state.selectedDynamicEntryId); 
        if (entry) { 
            container.innerHTML = `<div class="flex flex-col h-full">
                <label class="font-bold">Title</label>
				<input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateDynamicEntryField('${entry.id}', 'title', this.value)" onblur="UIManager.renderDynamicEntries()" class="text-xl font-bold bg-black/30 p-2 w-full mb-4">
                <label class="font-bold mb-2">Triggers (Keywords, AND, XOR, % Chance)</label>
                <input type="text" value="${UTILITY.escapeHTML(entry.triggers)}" oninput="Controller.updateDynamicEntryField('${entry.id}', 'triggers', this.value)" placeholder="e.g. house, cat AND dog, 25%" class="bg-black/30 p-2 w-full mb-4">
                <div class="relative flex-grow flex flex-col">
                    <label class="font-bold mb-2">Content</label>
                    <div class="relative flex-grow">
                        <textarea oninput="Controller.updateDynamicEntryField('${entry.id}', 'content', this.value)" class="w-full h-full bg-black/30 p-2 resize-none rounded-md">${UTILITY.escapeHTML(entry.content)}</textarea>
                        <button onclick="Controller.generateDynamicEntryContentAI(event, '${entry.id}')" class="absolute top-2 right-2 text-sky-400 hover:text-sky-300 p-1 bg-sky-600/80 rounded" title="Generate with AI">${this.getAIGenIcon()}</button>
                    </div>
                </div>
                <div class="flex justify-end mt-4"><button onclick="Controller.deleteDynamicEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button></div>
            </div>`; 
        } else { 
            container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div>`; 
        } 
    },
    
    _createMessageHTML(msg, index) {
        const state = StateManager.getState();
        if (msg.type === 'lore_reveal' || msg.isHidden) return '';
        
        if (msg.type === 'system_event') {
            return `<div class="w-full text-center my-2"><p class="text-sm italic text-gray-400">${UTILITY.escapeHTML(msg.content)}</p></div>`;
        }

        const character = state.characters.find(c => c.id === msg.character_id);
        if (!character) return '';

        const userChar = state.characters.find(c => c.is_user);
        const characterName = character ? character.name : '';
        const userName = userChar ? userChar.name : 'You';
        const replacer = (text) => {
            if (typeof text !== 'string') return '';
            return text.replace(/{character}/g, characterName).replace(/{user}/g, userName);
        };

        const processedContent = replacer(msg.content);
        const contentId = `message-content-${index}`;
		const styledContent = processedContent.replace(/(["“][^"”]*["”])/g, `<span class="dialogue-quote">$1</span>`);
		let contentHTML = marked.parse(styledContent || '');
        
        let bubbleStyle = '';
        let characterNameColor = '';

		const imgSrc = UIManager.getPortraitSrc(character, msg.emotion);
		if (state.characterImageMode === 'bubble' && imgSrc) {
		  contentHTML = `<img src="${imgSrc}" class="bubble-char-image">` + contentHTML;
		}



        if (character.is_user) {
            bubbleStyle = `background-color: rgba(75, 85, 99, ${state.bubbleOpacity});`;
        } else {
            const charColor = character.color || { base: '#334155', bold: '#94a3b8' };
            const topColor = UTILITY.hexToRgba(charColor.base, state.bubbleOpacity);
            const bottomColor = UTILITY.hexToRgba(UTILITY.darkenHex(charColor.base, 10), state.bubbleOpacity);
            bubbleStyle = `background-image: linear-gradient(to bottom, ${topColor}, ${bottomColor});`;
            characterNameColor = `style="color: ${charColor.bold};"`;
        }
        
        const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

        return `
            <div class="chat-bubble-container ${msg.isNew ? 'new-message' : ''}" data-message-index="${index}" style="margin-bottom: 0rem;">
                <div class="bubble-header">
                     <p class="font-bold text-sm" ${characterNameColor}>${UTILITY.escapeHTML(character.name)}</p>
                     <span class="timestamp text-xs text-gray-500">${timestamp}</span>
                     <div class="action-btn-group flex ml-2 space-x-4">
                        <button onclick="Controller.copyMessage(${index})" class="text-gray-400 hover:text-white" title="Copy"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                        <button onclick="Controller.openModal('edit-response-modal', ${index})" class="text-gray-400 hover:text-white" title="Edit"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button onclick="Controller.deleteMessage(${index})" class="text-gray-400 hover:text-white" title="Delete"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                </div>
                <div class="bubble-body rounded-lg px-3 py-2" style="${bubbleStyle}">
                    <div id="${contentId}" class="whitespace-pre-wrap" style="color: ${state.chatTextColor}; font-family: ${state.font};">
                        ${contentHTML}
                    </div>
                </div>
            </div>`;
    },

    renderChat() {
        const state = StateManager.getState();
        if (!state || !state.chat_history) {
             document.getElementById('chat-window').innerHTML = `<div class="h-full w-full flex items-center justify-center text-gray-500 text-lg">No Narrative Loaded</div>`;
             return;
        }
        if (this.RUNTIME.streamingInterval) return; 
        
        document.body.dataset.mode = state.characterImageMode;
        this.updateSidePortrait();

		if (state.characterImageMode === 'cinematic_overlay') {
		  let latestAiImageUrl = null;

		  for (let i = state.chat_history.length - 1; i >= 0; i--) {
			const msg = state.chat_history[i];
			if (msg.type !== 'chat' || msg.isHidden) continue;
			const speaker = state.characters.find(c => c.id === msg.character_id);
			if (speaker && !speaker.is_user) {
			  const candidate = UIManager.getPortraitSrc(speaker, msg.emotion);
			  if (candidate) { latestAiImageUrl = candidate; break; }
			}
		  }

		  if (latestAiImageUrl && latestAiImageUrl !== this.RUNTIME.lastCinematicImageUrl) {
			this.RUNTIME.lastCinematicImageUrl = latestAiImageUrl;
			const bg1 = document.getElementById('cinematic-bg-1');
			const bg2 = document.getElementById('cinematic-bg-2');

			if (this.RUNTIME.activeCinematicBg === 1) {
			  bg2.style.backgroundImage = `url('${latestAiImageUrl}')`;
			  bg1.style.opacity = 0;
			  bg2.style.opacity = 1;
			  this.RUNTIME.activeCinematicBg = 2;
			} else {
			  bg1.style.backgroundImage = `url('${latestAiImageUrl}')`;
			  bg1.style.opacity = 1;
			  bg2.style.opacity = 0;
			  this.RUNTIME.activeCinematicBg = 1;
			}
		  } else if (!latestAiImageUrl && this.RUNTIME.lastCinematicImageUrl) {
			// Keep last one visible, as before
			const activeBg = document.getElementById(`cinematic-bg-${this.RUNTIME.activeCinematicBg}`);
			if (activeBg) activeBg.style.backgroundImage = `url('${this.RUNTIME.lastCinematicImageUrl}')`;
		  }
		} else {
		  // existing clear logic unchanged
		  const bg1 = document.getElementById('cinematic-bg-1');
		  const bg2 = document.getElementById('cinematic-bg-2');
		  if (bg1) { bg1.style.backgroundImage = 'none'; bg1.style.opacity = '0'; }
		  if (bg2) { bg2.style.backgroundImage = 'none'; bg2.style.opacity = '0'; }
		  this.RUNTIME.lastCinematicImageUrl = null;
		  this.RUNTIME.activeCinematicBg = 1;
		}



        document.getElementById('chat-window').innerHTML = (state.chat_history || []).map((msg, index) => this._createMessageHTML(msg, index)).join('');
        (state.chat_history || []).forEach(m => m.isNew = false);
    },
    
    renderExampleDialogueModal() {
        const state = StateManager.getState();
        const container = document.getElementById('example-dialogue-container');
        if (!container) return;

        const userChar = state.characters.find(c => c.is_user);
        const aiChars = state.characters.filter(c => !c.is_user);
        const exampleMessages = state.chat_history.map((msg, index) => ({ ...msg, originalIndex: index })).filter(msg => msg.isHidden === true);

        if (exampleMessages.length === 0) {
            container.innerHTML = `<div class="text-gray-400 text-center">No example dialogue found. Add a turn to start.</div>`;
            return;
        }

        container.innerHTML = exampleMessages.map((msg, idx) => {
            const speakerOptions = [userChar, ...aiChars].map(char => `<option value="${char.id}" ${msg.character_id === char.id ? 'selected' : ''}>${UTILITY.escapeHTML(char.name)}</option>`).join('');
            return `
                <div class="bg-black/20 p-4 rounded-lg flex items-center space-x-4">
                    <div class="flex flex-col space-y-2">
                        <button onclick="Controller.moveExampleDialogueTurn(${msg.originalIndex}, 'up')" ${idx === 0 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Up"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                        <button onclick="Controller.moveExampleDialogueTurn(${msg.originalIndex}, 'down')" ${idx === exampleMessages.length - 1 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Down"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                    </div>
                    <div class="flex-grow flex flex-col space-y-2">
                        <select onchange="Controller.updateExampleDialogueTurn(${msg.originalIndex}, 'character_id', this.value)" class="w-full bg-gray-700 border-gray-600 rounded p-2 text-sm">${speakerOptions}</select>
                        <textarea oninput="Controller.updateExampleDialogueTurn(${msg.originalIndex}, 'content', this.value)" class="w-full bg-gray-900/80 border-gray-600 p-2 resize-none rounded-md">${UTILITY.escapeHTML(msg.content)}</textarea>
                    </div>
                    <button onclick="Controller.deleteExampleDialogueTurn(${msg.originalIndex})" class="flex-shrink-0 bg-red-600/80 hover:bg-red-700/80 text-white font-bold p-2 rounded-lg" title="Delete Turn"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            `;
        }).join('');

        const textareas = container.querySelectorAll('textarea');
        textareas.forEach(textarea => {
            const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
            textarea.addEventListener('input', autoResize);
            setTimeout(autoResize, 0);
        });
    },

	updateSidePortrait() {
	  const portraitContainer = document.getElementById('character-portrait-container');
	  if (document.body.classList.contains('layout-vertical')) {
		if (portraitContainer) portraitContainer.innerHTML = '';
		return;
	  }

	  const state = StateManager.getState();
	  if (!portraitContainer || !state || !state.characters || !state.chat_history) {
		if (portraitContainer) portraitContainer.innerHTML = '';
		return;
	  }

	  // Last non-user chat message
	  const lastChatMessages = (state.chat_history || [])
		.filter(m => m.type === 'chat' && !m.isHidden && !state.characters.find(c => c.id === m.character_id)?.is_user);
	  const lastSpeakerMsg = lastChatMessages.length ? lastChatMessages[lastChatMessages.length - 1] : null;
	  const lastSpeaker = lastSpeakerMsg ? state.characters.find(c => c.id === lastSpeakerMsg.character_id) : null;

	  if (!lastSpeaker) {
		portraitContainer.innerHTML = '';
		return;
	  }

	  const mood = lastSpeakerMsg?.emotion || 'neutral';
	  const portraitUrl = UIManager.getPortraitSrc(lastSpeaker, mood);

	  // If we truly have nothing usable (unlikely), clear the container
	  if (!portraitUrl) {
		portraitContainer.innerHTML = '';
		return;
	  }

	  portraitContainer.innerHTML = `<img src="${portraitUrl}" class="max-w-full max-h-full object-contain rounded-lg">`;
	},

startStreamingResponse(charId, fullText, emotion) {
        if (this.RUNTIME.streamingInterval) clearInterval(this.RUNTIME.streamingInterval);
        const state = StateManager.getState();

        const messageIndex = state.chat_history.length;
        state.chat_history.push({ 
            character_id: charId, content: '', type: 'chat', emotion: emotion, 
            timestamp: new Date().toISOString(), isNew: true 
        });

        this.renderChat();
        
        const messageContentEl = document.getElementById(`message-content-${messageIndex}`);
        if (!messageContentEl) {
            console.error("Could not find message element to stream to.");
            return;
        }
        const bubbleEl = messageContentEl.closest('.chat-bubble-container');
        const words = fullText.split(/(\s+)/);
        let wordIndex = 0;

        this.RUNTIME.streamingInterval = setInterval(() => {
            if (wordIndex < words.length) {
                const word = words[wordIndex];
                state.chat_history[messageIndex].content += word;
                
                const userChar = state.characters.find(c => c.is_user);
                const character = state.characters.find(c => c.id === charId);
                const replacer = (text) => text.replace(/{character}/g, character.name).replace(/{user}/g, userChar.name);
                let processedContent = replacer(state.chat_history[messageIndex].content);
                
                // --- FIX ---
                // Replaced the 'boldedContent' logic with the 'styledContent' logic
                // to match the _createMessageHTML function.
                const styledContent = processedContent.replace(/(["“][^"”]*["”])/g, `<span class="dialogue-quote">$1</span>`);
                let fullHTML = marked.parse(styledContent || '');
                // --- END FIX ---
                
				const imgSrc = UIManager.getPortraitSrc(character, state.chat_history[messageIndex].emotion);
				
				if (state.characterImageMode === 'bubble' && imgSrc) {
				  fullHTML = `<img src="${imgSrc}" class="bubble-char-image">` + fullHTML;
				}

                messageContentEl.innerHTML = fullHTML;
                
                const chatWindow = document.getElementById('chat-window');
                const isScrolledToBottom = chatWindow.scrollHeight - chatWindow.clientHeight <= chatWindow.scrollTop + 50;
                if(isScrolledToBottom) {
                     bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
                wordIndex++;
            } else {
                clearInterval(this.RUNTIME.streamingInterval);
                this.RUNTIME.streamingInterval = null;
                state.chat_history[messageIndex].isNew = false;
                StateManager.saveState();
                setTimeout(() => bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
            }
        }, 2); // Speed of streaming in inverse.
    },
    
    showTypingIndicator(charId, text="is thinking...") { 
        this.hideTypingIndicator(); 
        const chatWindow=document.getElementById('chat-window'); 
        const name = (StateManager.getState().characters || []).find(c => c.id === charId)?.name || 'System'; 
        const indicator = document.createElement('div'); 
        indicator.id = 'typing-indicator'; 
        indicator.innerHTML = `<div class="mb-4 flex flex-col items-start"><p class="font-bold text-sm mb-1">${UTILITY.escapeHTML(name)}</p><div class="p-3 bg-gray-700/80 rounded-lg"><p class="italic">${text}</p></div></div>`; 
        chatWindow.appendChild(indicator); 
        chatWindow.scrollTop = chatWindow.scrollHeight; 
    },
    
    hideTypingIndicator() { 
        const el = document.getElementById('typing-indicator'); 
        if (el) el.remove(); 
    },
    
applyStyling() { 
        const state = StateManager.getState();
        const backgroundElement = document.getElementById('global-background');
        
		let backgroundUrl = ''; // Default to no background

        // 1. Check for a location-specific image first (highest priority)
        if (state.worldMap && state.worldMap.grid.length > 0) {
            const currentLoc = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
            if (currentLoc) {
                // NEW: Check local cache first
                const locationKey = `location::${currentLoc.coords.x},${currentLoc.coords.y}`;
                UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                
                if (UIManager.RUNTIME.worldImageCache[locationKey]) {
                    backgroundUrl = UIManager.RUNTIME.worldImageCache[locationKey];
                } 
                // FALLBACK: Check legacy URL (if not a local key)
                else if (currentLoc.imageUrl && !currentLoc.imageUrl.startsWith('local_idb_location')) {
                    backgroundUrl = currentLoc.imageUrl;
                }
            }
        }
        
        // 2. If no location image, check for a user-uploaded local background
        if (!backgroundUrl && UIManager.RUNTIME.globalBackgroundImageCache) {
             backgroundUrl = UIManager.RUNTIME.globalBackgroundImageCache;
        }
        // 3. If no local background, fall back to a legacy URL (if it's not our keyword)
        else if (!backgroundUrl && state.backgroundImageURL && state.backgroundImageURL !== 'local_idb_background') {
            backgroundUrl = state.backgroundImageURL;
        }

        backgroundElement.style.backgroundImage = backgroundUrl ? `url('${backgroundUrl}')` : 'none';
        
        document.getElementById('app-container').style.backdropFilter = `blur(${state.backgroundBlur || 0}px)`;
        document.documentElement.style.setProperty('--chat-font-size', `${state.textSize || 16}px`);
        document.documentElement.style.setProperty('--bubble-image-size', `${state.bubbleImageSize || 100}px`);

        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        };

        const rgb = hexToRgb(state.chatTextColor);
        if (rgb) {
            document.documentElement.style.setProperty('--border-hue-color', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4)`);
        }

        document.documentElement.style.setProperty('--chat-text-color', state.chatTextColor);
        document.documentElement.style.setProperty('--chat-font-family', state.font);
		
        const storyTitleInput = document.getElementById('story-title-input');
        const mobileStoryTitleOverlay = document.getElementById('mobile-story-title-overlay');
        if (storyTitleInput) storyTitleInput.style.color = state.chatTextColor;
        if (mobileStoryTitleOverlay) mobileStoryTitleOverlay.style.color = state.chatTextColor;
		
        this.renderChat();
    },

    renderWorldMapModal() {
        const state = StateManager.getState();
        const { activeWorldMapTab, selectedMapTile, pendingMove } = Controller.RUNTIME;
        const { worldMap } = state;
        const container = document.getElementById('world-map-modal-content');

        let contentHTML = '';
        const isMobile = window.innerHeight > window.innerWidth;

        if (activeWorldMapTab === 'move') {
            const { currentLocation } = worldMap;
            let moveGridHTML = '';
            for (let y = currentLocation.y - 1; y <= currentLocation.y + 1; y++) {
                for (let x = currentLocation.x - 1; x <= currentLocation.x + 1; x++) {
                    const isCenter = x === currentLocation.x && y === currentLocation.y;
                    const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
					let imageSrc = '';
                    if (location) {
                        const locationKey = `location::${x},${y}`;
                        UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                        
                        if (UIManager.RUNTIME.worldImageCache[locationKey]) {
                            // Use cached local image if available
                            imageSrc = UIManager.RUNTIME.worldImageCache[locationKey];
                        } else if (location.imageUrl && !location.imageUrl.startsWith('local_idb_location')) {
                            // Fallback to legacy URL if it exists and isn't a local key
                            imageSrc = location.imageUrl;
                        }
                    }
                    const bgImage = imageSrc ? `background-image: url('${imageSrc}');` : '';                    let classList = ['aspect-square', 'rounded-lg', 'flex', 'items-end', 'p-2', 'text-white', 'relative', 'overflow-hidden', 'bg-cover', 'bg-center', 'transition-all'];
                    
                    if (isCenter) {
                        classList.push('bg-indigo-800/80', 'ring-2', 'ring-indigo-300');
                    } else if (location) {
                        classList.push('bg-gray-700/80', 'cursor-pointer', 'hover:ring-2', 'hover:ring-sky-400');
                    } else {
                        classList.push('bg-black/50');
                    }

                    if (pendingMove && pendingMove.x === x && pendingMove.y === y && !isCenter) {
                        classList.push('ring-4', 'ring-yellow-400');
                    }

                    if (location) {
                        moveGridHTML += `<div 
                            class="${classList.join(' ')}"
                            style="${bgImage}"
                            ${!isCenter ? `onclick="Controller.selectPendingMove(${x}, ${y})"` : ''}>
                            <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                            <span class="relative z-10 text-sm font-bold">${UTILITY.escapeHTML(location.name)}</span>
                        </div>`;
                    } else {
                        moveGridHTML += `<div class="${classList.join(' ')}"></div>`;
                    }
                }
            }

            let detailsHTML = '';
            const pendingLocation = pendingMove ? worldMap.grid.find(l => l.coords.x === pendingMove.x && l.coords.y === pendingMove.y) : null;
            if (pendingLocation) {
                 detailsHTML = `
                    <h3 class="text-2xl font-bold">${UTILITY.escapeHTML(pendingLocation.name)}</h3>
                    <p class="text-gray-400 mt-2 flex-grow">${UTILITY.escapeHTML(pendingLocation.description)}</p>
                    <button onclick="Controller.confirmMove()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg mt-4">Confirm Move</button>
                `;
            } else {
                 const currentLocationData = worldMap.grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);
                 detailsHTML = `
                    <h3 class="text-2xl font-bold">Movement</h3>
                    <p class="text-gray-400 mt-2">You are currently at <strong>${UTILITY.escapeHTML(currentLocationData.name)}</strong>.</p>
                    <p class="text-gray-400 mt-2">Select an adjacent tile to see its details and confirm your move.</p>
                `;
            }

             contentHTML = `<div class="p-6 flex-grow grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                <div class="grid grid-cols-3 gap-2">${moveGridHTML}</div>
                <div class="flex flex-col h-full">${detailsHTML}</div>
            </div>`;

        } else { // 'worldmap' tab
            const { currentLocation, destination, path } = worldMap;
            let mapGridHTML = '';
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                    let classList = ['aspect-square', 'rounded', 'bg-gray-800/80', 'hover:bg-gray-700/80', 'cursor-pointer', 'text-xs', 'p-1', 'overflow-hidden', 'leading-tight'];
                    
                    if (currentLocation.x === x && currentLocation.y === y) classList.push('ring-2', 'ring-green-400');
                    if (destination && destination.x === x && destination.y === y) classList.push('ring-2', 'ring-red-500');
                    if (path && path.some(p => p.x === x && p.y === y)) classList.push('bg-sky-700/50');
                    if (selectedMapTile && selectedMapTile.coords.x === x && selectedMapTile.coords.y === y) classList.push('ring-2', 'ring-yellow-300');

                    mapGridHTML += `<div class="${classList.join(' ')}" onclick="Controller.selectMapTile(${x}, ${y})">${location ? UTILITY.escapeHTML(location.name) : ''}</div>`;
                }
            }

            let detailsHTML = `<div class="h-full flex items-center justify-center text-gray-500">Select a tile to view details.</div>`;
            if (selectedMapTile) {
                detailsHTML = `
                    <div class="h-full flex flex-col space-y-3">
                        <div><label class="text-sm text-gray-400">Name</label><input type="text" value="${UTILITY.escapeHTML(selectedMapTile.name)}" oninput="Controller.updateLocationDetail('name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>

                        <div>
                            <label class="text-sm text-gray-400 mt-2 block">Upload Local Image</label>
                            <span class="text-xs text-gray-500 mb-2 block">Current: ${selectedMapTile.imageUrl.startsWith('local_idb_location') ? '[Local Image]' : (selectedMapTile.imageUrl ? '[Legacy URL]' : 'None')}</span>
                            <input type="file" accept="image/*" onchange="Controller.handleWorldMapLocationImageUpload(event, ${selectedMapTile.coords.x}, ${selectedMapTile.coords.y})" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                        </div>
                        <div><label class="text-sm text-gray-400">Brief Description</label><textarea oninput="Controller.updateLocationDetail('description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded h-20 resize-none">${UTILITY.escapeHTML(selectedMapTile.description)}</textarea></div>
                        <div class="flex-grow flex flex-col">
                            <label class="text-sm text-gray-400">Full Prompt</label>
                            <div class="relative flex-grow">
                                <textarea oninput="Controller.updateLocationDetail('prompt', this.value)" class="w-full h-full bg-black/30 border-gray-600 p-2 rounded resize-none">${UTILITY.escapeHTML(selectedMapTile.prompt)}</textarea>
                                <button onclick="Controller.generateLocationPromptAI(event)" class="absolute top-2 right-2 text-sky-400 hover:text-sky-300 p-1 bg-sky-600/80 rounded" title="Generate with AI">${this.getAIGenIcon()}</button>
                            </div>
                        </div>
                        <div class="flex gap-2">
                           <button onclick="Controller.setDestination()" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg">Set Destination</button>
                           <button onclick="if(confirm('This will immediately move you to this location. Proceed?')) { Controller.moveToLocation(${selectedMapTile.coords.x}, ${selectedMapTile.coords.y}); Controller.closeModal('world-map-modal'); }" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Jump To</button>
                        </div>
                    </div>`;
            }

            const gridLayoutClass = isMobile ? 'grid-cols-1' : 'grid-cols-3';
            const detailsWrapperClass = isMobile ? 'h-64 overflow-y-auto' : 'flex flex-col';

            contentHTML = `<div class="p-6 flex-grow grid ${gridLayoutClass} gap-6 h-full min-h-0">
                <div class="col-span-2 grid grid-cols-8 gap-1">${mapGridHTML}</div>
                <div class="col-span-1 bg-black/30 rounded-lg p-4 ${detailsWrapperClass}">${detailsHTML}</div>
            </div>`;
        }

        container.innerHTML = `
            <div class="p-6 pb-0 flex justify-between items-center border-b border-gray-700">
                <div class="flex">
                    <button id="world-map-tab-move" onclick="Controller.switchWorldMapTab('move')" class="py-3 px-4 font-semibold text-lg ${activeWorldMapTab === 'move' ? 'border-b-2 border-indigo-500 text-white' : 'border-b-2 border-transparent text-gray-400 hover:text-white'}">Move</button>
                    <button id="world-map-tab-worldmap" onclick="Controller.switchWorldMapTab('worldmap')" class="py-3 px-4 font-semibold text-lg ${activeWorldMapTab === 'worldmap' ? 'border-b-2 border-indigo-500 text-white' : 'border-b-2 border-transparent text-gray-400 hover:text-white'}">World Map</button>
                </div>
                <button id="generate-world-button" onclick="Controller.generateWorldMap(event)" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-3 rounded-lg ml-4 flex-shrink-0">${this.getAIGenIcon()}</button>
            </div>
            ${contentHTML}
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('world-map-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>`;

        if (activeWorldMapTab === 'worldmap' && selectedMapTile) {
            const detailsContainer = container.querySelector('.col-span-1');
            detailsContainer.innerHTML += `
                <hr class="border-gray-600 my-4">
                <div class="flex-grow flex flex-col min-h-0">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="font-bold text-lg">Local Static Memory</h4>
                        <button onclick="Controller.addLocalStaticEntry()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded-lg text-sm">Add</button>
                    </div>
                    <div class="grid grid-cols-3 gap-4 flex-grow min-h-0">
                        <div id="local-static-entries-list" class="col-span-1 bg-black/40 rounded-lg p-2 overflow-y-auto"></div>
                        <div id="local-static-entry-details" class="col-span-2 flex flex-col"></div>
                    </div>
                </div>`;
            this.renderLocalStaticEntriesList();
            this.renderLocalStaticEntryDetails();
        }
    },

    renderLocalStaticEntriesList() {
        const { selectedMapTile, selectedLocalStaticEntryId } = Controller.RUNTIME;
        const container = document.getElementById('local-static-entries-list');
        if (!container || !selectedMapTile) return;

        const entries = selectedMapTile.local_static_entries || [];
        container.innerHTML = entries.map(entry => `
            <div onclick="Controller.selectLocalStaticEntry('${entry.id}')" 
                 class="p-2 rounded-md cursor-pointer ${selectedLocalStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}">
                <h5 class="font-semibold truncate text-sm">${UTILITY.escapeHTML(entry.title)}</h5>
            </div>
        `).join('');
    },

    renderLocalStaticEntryDetails() {
        const { selectedMapTile, selectedLocalStaticEntryId } = Controller.RUNTIME;
        const container = document.getElementById('local-static-entry-details');
        if (!container || !selectedMapTile) return;

        const entry = (selectedMapTile.local_static_entries || []).find(e => e.id === selectedLocalStaticEntryId);

        if (entry) {
            container.innerHTML = `
                <input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateLocalStaticEntryField('${entry.id}', 'title', this.value)" class="font-bold bg-black/30 p-2 w-full mb-2 text-sm rounded-md">
                <textarea oninput="Controller.updateLocalStaticEntryField('${entry.id}', 'content', this.value)" class="w-full flex-grow bg-black/30 p-2 resize-none text-sm rounded-md">${UTILITY.escapeHTML(entry.content)}</textarea>
                <div class="flex justify-end mt-2">
                    <button onclick="Controller.deleteLocalStaticEntry('${entry.id}')" class="text-xs bg-red-600/80 hover:bg-red-700/80 font-semibold py-1 px-2 rounded-lg">Delete</button>
                </div>`;
        } else {
            container.innerHTML = `<div class="text-gray-500 flex items-center justify-center h-full text-sm">Select an entry.</div>`;
        }
    },

getPortraitSrc(character, mood) {
	  const cache = UIManager.RUNTIME.characterImageCache || {};

	  const emoKey = mood ? `${character.id}::emotion::${mood}` : null;
	  if (emoKey && cache[emoKey]) return cache[emoKey];

	  // Base portrait (IDB-backed cache)
	  if (cache[character.id]) return cache[character.id];

	  // Legacy URL (pre-IDB) - Make sure it's not our local keyword
	  if (character.image_url && !character.image_url.startsWith('local_idb_')) {
          return character.image_url;
      }

	  // Return null instead of placeholder
	  return null;
	},

    openCharacterDetailModal(charId) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) {
            console.error("Character not found:", charId);
            return;
        }
        const container = document.getElementById('character-detail-modal-content');
        
const extraPortraitsHTML = (char.extra_portraits || []).map((portrait, index) => {
          const emo = portrait.emotion || 'happy';
          const fileInputId = `emo-file-${char.id}-${index}`;
          const urlInputId  = `emo-url-${char.id}-${index}`;
          const labelId     = `emo-label-${char.id}-${index}`;

          // Determine current source to show a hint (cache -> “local”)
          const cached = (UIManager.RUNTIME.characterImageCache || {})[`${char.id}::emotion::${emo}`];
          const hint   = cached ? '[local image]' : (portrait.url ? '[url]' : '[none]');

          return `
            <div class="flex flex-col space-y-2 mt-2 p-2 rounded border border-gray-700/50">
                <div class="flex items-center space-x-2">
                    <select
                        onchange="Controller.updateExtraPortrait('${char.id}', ${index}, 'emotion', this.value)"
                        class="w-1/3 bg-black/30 border-gray-600 rounded p-1 text-sm"
                    >
                        <option value="happy" ${emo === 'happy' ? 'selected' : ''}>Happy</option>
                        <option value="sad" ${emo === 'sad' ? 'selected' : ''}>Sad</option>
                        <option value="angry" ${emo === 'angry' ? 'selected' : ''}>Angry</option>
                        <option value="surprised" ${emo === 'surprised' ? 'selected' : ''}>Surprised</option>
                        <option value="neutral" ${emo === 'neutral' ? 'selected' : ''}>Neutral</option>
                    </select>
                    <input
                        id="${urlInputId}"
                        type="text"
                        value="${UTILITY.escapeHTML(portrait.url || '')}"
                        oninput="Controller.updateExtraPortrait('${char.id}', ${index}, 'url', this.value)"
                        class="w-2/3 bg-black/30 border-gray-600 p-1 text-sm"
                        placeholder="Image URL (used if no local image)"
                    >
                    <button
                        onclick="Controller.removeExtraPortrait('${char.id}', ${index})"
                        class="text-red-400 hover:text-red-300"
                        title="Remove portrait"
                    >X</button>
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-sm text-gray-400" for="${fileInputId}">
                        Upload local image for <span class="font-semibold">${emo}</span>:
                    </label>
                    <span id="${labelId}" class="text-xs text-gray-400">${hint}</span>
                </div>
                <input
                    id="${fileInputId}"
                    type="file"
                    accept="image/*"
                    onchange="Controller.handleLocalEmotionImageUpload(event, '${char.id}', ${index})"
                    class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer"
                >
            </div>
          `;
        }).join('');

        
        const tagsValue = (char.tags || []).join(', ');

        const color = char.color || { base: '#334155', bold: '#94a3b8' };

        const modalHTML = `
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold" data-char-id="${char.id}">${UTILITY.escapeHTML(char.name)}</h2>
                ${!char.is_user ? `<div class="flex items-center space-x-2"><span class="text-sm">Active</span><label class="flex items-center cursor-pointer"><div class="relative"><input type="checkbox" class="sr-only" ${char.is_active ? 'checked' : ''} onchange="Controller.toggleCharacterActive(event, '${char.id}')"><div class="w-12 h-6 bg-gray-600 rounded-full toggle-bg"></div></div></label></div>` : '<span class="text-sm font-semibold text-indigo-400">PLAYER</span>'}
            </div>
            <div class="p-6 overflow-y-auto space-y-4">
                <details open>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Primary Info</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                        <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Name</label>
                            ${!char.is_user ? `<div class="flex items-center space-x-2"><span class="text-sm">Is Narrator</span><label class="flex items-center cursor-pointer"><div class="relative"><input type="checkbox" class="sr-only" ${char.is_narrator ? 'checked' : ''} onchange="Controller.updateCharacterField('${char.id}', 'is_narrator', this.checked)"><div class="w-12 h-6 bg-gray-600 rounded-full toggle-bg"></div></div></label></div>` : ''}
                        </div>
                        <input type="text" value="${UTILITY.escapeHTML(char.name)}" oninput="Controller.updateCharacterField('${char.id}', 'name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded text-lg">
                        <div><label class="text-sm text-gray-400">Short Description (for roster card)</label><input type="text" value="${UTILITY.escapeHTML(char.short_description)}" oninput="Controller.updateCharacterField('${char.id}', 'short_description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        <div>
                            <label class="text-sm text-gray-400">Default Image URL</label>
                            <input type="text" value="${UTILITY.escapeHTML(char.image_url)}" oninput="Controller.updateCharacterField('${char.id}', 'image_url', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded" placeholder="Paste URL...">
                            <label class="text-sm text-gray-400 mt-2 block">Or Upload Local Image</label>
                            <input type="file" accept="image/*" onchange="Controller.handleLocalImageUpload(event, '${char.id}')" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                        </div>
                        ${!char.is_user ? `<div class="grid grid-cols-2 gap-4"><div><label class="text-sm text-gray-400">Bubble Base Color</label><input type="color" value="${color.base}" oninput="Controller.updateCharacterColor('${char.id}', 'base', this.value)" class="w-full h-10 p-1 bg-black/30 border-gray-600 rounded"></div><div><label class="text-sm text-gray-400">Name Color</label><input type="color" value="${color.bold}" oninput="Controller.updateCharacterColor('${char.id}', 'bold', this.value)" class="w-full h-10 p-1 bg-black/30 border-gray-600 rounded"></div></div>` : ''}
                        <div><label class="text-sm text-gray-400">Tags (comma-separated)</label><input type="text" value="${tagsValue}" oninput="Controller.updateCharacterTags('${char.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"><button onclick="Controller.generateTagsForCharacter(event, '${char.id}')" class="text-xs text-sky-400 hover:text-sky-300 mt-1 p-1 bg-sky-600/80 rounded">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Persona</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea id="persona-description-${char.id}" oninput="Controller.updateCharacterField('${char.id}', 'description', this.value); UIManager.updateTokenCount('${char.id}', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${UTILITY.escapeHTML(char.description)}</textarea>
                         <div class="flex justify-between items-center"><span class="text-right text-sm text-gray-400" id="token-counter-${char.id}">~${Math.round((char.description || '').length / 4)} tokens</span><button onclick="Controller.enhancePersonaWithAI(event, '${char.id}')" class="text-sm bg-sky-600/80 hover:bg-sky-500/80 font-semibold py-2 px-3 rounded-lg">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Model Instructions</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea oninput="Controller.updateCharacterField('${char.id}', 'model_instructions', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${UTILITY.escapeHTML(char.model_instructions)}</textarea>
                         ${!char.is_user ? `<div class="text-right"><button onclick="Controller.generateModelInstructions(event, '${char.id}')" class="text-sm bg-sky-600/80 hover:bg-sky-700/80 font-semibold py-2 px-3 rounded-lg">${this.getAIGenIcon()}</button></div>` : ''}
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Emotional Portraits</summary>
                    <div class="p-4 space-y-2 bg-black/20 rounded-b-lg">
                        <div id="extra-portraits-${char.id}">${extraPortraitsHTML}</div>
                        <button onclick="Controller.addExtraPortrait('${char.id}')" class="text-sm text-sky-400 hover:text-sky-300 mt-2">+ Add Emotional Portrait</button>
                    </div>
                </details>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-between">
                ${!char.is_user ? `<button onclick="if(confirm('Are you sure you want to delete this character?')) Controller.deleteCharacter('${char.id}')" class="bg-red-600/80 hover:bg-red-700/80 font-bold py-2 px-4 rounded-lg">Delete</button>` : '<div></div>'}
                <button onclick="Controller.closeModal('character-detail-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        `;
        container.innerHTML = modalHTML;

        container.querySelectorAll('textarea').forEach(textarea => {
            const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
            textarea.addEventListener('input', autoResize);
            setTimeout(autoResize, 0);
        });
    },

    updateTokenCount(charId, text) { 
        const counter = document.getElementById(`token-counter-${charId}`); 
        if (counter) counter.textContent = `~${Math.round((text || '').length / 4)} tokens`; 
    },

    updateAICharacterSelector() {
        const state = StateManager.getState();
        const selector = document.getElementById('ai-character-selector');
        if (!state || !state.characters) {
            selector.innerHTML = '';
            return;
        }

        const activeAiChars = state.characters.filter(c => !c.is_user && c.is_active);
        
        if (activeAiChars.length <= 1) {
            selector.style.display = 'none';
        } else {
            selector.style.display = 'block';
        }

        const currentValue = selector.value;
        let optionsHTML = `<option value="any">Any</option>`;
        optionsHTML += activeAiChars.map(c => `<option value="${c.id}">${UTILITY.escapeHTML(c.name)}</option>`).join('');
        selector.innerHTML = optionsHTML;
        
        if (currentValue && selector.querySelector(`option[value="${currentValue}"]`)) {
            selector.value = currentValue;
        }
    },

    // --- NEW & MODIFIED UI Functions for Import/Export ---

    /**
     * Renders the centralized Import/Export Hub modal.
     */
    renderIOHubModal() {
        const modalContent = document.getElementById('io-hub-modal-content');
        const library = StateManager.getLibrary();
        const storyOptions = library.stories.map(s => `<option value="${s.id}">${UTILITY.escapeHTML(s.name)}</option>`).join('');

        const hubHTML = `
            <div class="p-6 border-b border-gray-700">
                <h2 class="text-2xl font-semibold">Import / Export Hub</h2>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- === IMPORT COLUMN === -->
                    <div class="space-y-6">
                        <h3 class="text-xl font-bold border-b pb-2 border-gray-600">Import</h3>
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Import a single Story from a V2 PNG, BYAF, or Ellipsis JSON file.</p>
                            <label for="single-file-upload" class="cursor-pointer">
                                <div class="border-2 border-dashed border-gray-500 rounded-lg p-6 text-center bg-black/20 hover:bg-black/40">
                                    <p class="font-semibold text-indigo-300">Click to upload a file</p>
                                    <p class="text-xs text-gray-400 mt-1">.png, .byaf, .zip, .json</p>
                                </div>
                            </label>
                            <input id="single-file-upload" type="file" class="hidden" accept=".png,.byaf,.zip,.json" onchange="Controller.handleFileUpload(event)">
                        </div>
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Import an entire folder of V2 PNG or BYAF files at once.</p>
                            <button onclick="Controller.handleBulkImport()" class="w-full mt-2 bg-teal-600/80 hover:bg-teal-700/80 text-white font-bold py-2 px-4 rounded-lg">Select Folder to Import</button>
                        </div>
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Replace your current library with an Ellipsis Library JSON file. <span class="font-bold text-red-400">Warning: This is a destructive action.</span></p>
                            <label class="w-full mt-2 bg-red-800/80 hover:bg-red-900/80 text-white font-bold py-2 px-4 rounded-lg inline-block text-center cursor-pointer">
                                <span>Import Library File</span>
                                <input type="file" class="hidden" accept=".json" onchange="Controller.importLibrary(event)">
                            </label>
                        </div>
                    </div>

                    <!-- === EXPORT COLUMN === -->
                    <div class="space-y-4">
                        <h3 class="text-xl font-bold border-b pb-2 border-gray-600">Export</h3>
                        <div>
                            <label for="story-export-selector" class="block text-sm font-medium text-gray-300">1. Select Story to Export</label>
                            <select id="story-export-selector" class="w-full mt-1 bg-black/30 p-2 rounded-lg border-gray-600" onchange="UIManager.populateNarrativeSelector()">
                                <option value="">-- Select a Story --</option>
                                ${storyOptions}
                            </select>
                        </div>
                        <div>
                            <label for="narrative-export-selector" class="block text-sm font-medium text-gray-300">2. Select Narrative</label>
                            <select id="narrative-export-selector" class="w-full mt-1 bg-black/30 p-2 rounded-lg border-gray-600" onchange="UIManager.populateCharacterSelector()"></select>
                        </div>
                        <div id="character-export-selector-container" class="hidden">
                            <label for="character-export-selector" class="block text-sm font-medium text-gray-300">3. Select Primary Character (for V2/BYAF)</label>
                            <select id="character-export-selector" class="w-full mt-1 bg-black/30 p-2 rounded-lg border-gray-600"></select>
                        </div>
                        <div>
                            <p class="block text-sm font-medium text-gray-300 mt-2">4. Choose Export Format</p>
                            <div class="grid grid-cols-3 gap-2 mt-2">
                                <button onclick="Controller.exportStoryAs('json')" class="bg-indigo-600/80 hover:bg-indigo-700/80 text-white font-bold py-2 px-3 rounded-lg">JSON</button>
                                <button onclick="Controller.exportStoryAs('png')" class="bg-sky-600/80 hover:bg-sky-700/80 text-white font-bold py-2 px-3 rounded-lg">V2 PNG</button>
                                <button onclick="Controller.exportStoryAs('byaf')" class="bg-emerald-600/80 hover:bg-emerald-700/80 text-white font-bold py-2 px-3 rounded-lg">BYAF</button>
                            </div>
                        </div>
                         <hr class="border-gray-600 !mt-8">
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Save a backup of your entire story library.</p>
                            <button onclick="Controller.exportLibrary()" class="w-full mt-2 bg-gray-600/80 hover:bg-gray-700/80 text-white font-bold py-2 px-4 rounded-lg">Export Entire Library</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('io-hub-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button>
            </div>
        `;
        modalContent.innerHTML = hubHTML;
        this.populateNarrativeSelector();
    },

    /** Populates the narrative selector dropdown based on the selected story. */
    populateNarrativeSelector() {
        const storyId = document.getElementById('story-export-selector').value;
        const narrativeSelector = document.getElementById('narrative-export-selector');
        narrativeSelector.innerHTML = '';
        if (storyId) {
            const story = StateManager.getLibrary().stories.find(s => s.id === storyId);
            if (story && story.narratives) {
                narrativeSelector.innerHTML = story.narratives.map(n => `<option value="${n.id}">${UTILITY.escapeHTML(n.name)}</option>`).join('');
            }
        }
        this.populateCharacterSelector();
    },

    /** Populates the character selector dropdown for V2/BYAF exports. */
    populateCharacterSelector() {
        const storyId = document.getElementById('story-export-selector').value;
        const charContainer = document.getElementById('character-export-selector-container');
        const charSelector = document.getElementById('character-export-selector');
        charSelector.innerHTML = '';
        if (storyId) {
            const story = StateManager.getLibrary().stories.find(s => s.id === storyId);
            const aiChars = story.characters.filter(c => !c.is_user);
            if (aiChars.length > 0) {
                charSelector.innerHTML = aiChars.map(c => `<option value="${c.id}">${UTILITY.escapeHTML(c.name)}</option>`).join('');
                charContainer.classList.remove('hidden');
            } else {
                charContainer.classList.add('hidden');
            }
        } else {
            charContainer.classList.add('hidden');
        }
    },

    /**
     * Displays a confirmation modal that returns a Promise, allowing for async/await usage.
     * @param {string} message - The message to display.
     * @returns {Promise<boolean>} - A promise that resolves to true if confirmed, false if canceled.
     */
    showConfirmationPromise(message) {
        return new Promise((resolve) => {
            const modal = document.getElementById('confirmation-modal');
            const messageEl = document.getElementById('confirmation-modal-message');
            const confirmBtn = document.getElementById('confirmation-modal-confirm-button');
            const cancelBtn = modal.querySelector('button:not(#confirmation-modal-confirm-button)');
            
            messageEl.textContent = message;
            
            const confirmClickHandler = () => {
                cleanup();
                resolve(true);
            };
            const cancelClickHandler = () => {
                cleanup();
                resolve(false);
            };

            const cleanup = () => {
                confirmBtn.removeEventListener('click', confirmClickHandler);
                cancelBtn.removeEventListener('click', cancelClickHandler);
                modal.querySelector('.modal-overlay').removeEventListener('click', cancelClickHandler);
                Controller.closeModal('confirmation-modal');
            };
            
            confirmBtn.addEventListener('click', confirmClickHandler, { once: true });
            cancelBtn.addEventListener('click', cancelClickHandler, { once: true });
            modal.querySelector('.modal-overlay').addEventListener('click', cancelClickHandler, { once: true });

            Controller.openModal('confirmation-modal');
        });
    },

    /** Displays a full-screen loading spinner with a message. */
    showLoadingSpinner(message = 'Loading...') {
        let spinner = document.getElementById('loading-spinner');
        if (!spinner) {
            spinner = document.createElement('div');
            spinner.id = 'loading-spinner';
            spinner.className = 'fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm flex flex-col items-center justify-center';
            spinner.innerHTML = `
                <div class="w-16 h-16 border-4 border-t-indigo-500 border-gray-600 rounded-full animate-spin"></div>
                <p id="spinner-message" class="mt-4 text-white font-semibold"></p>
            `;
            document.body.appendChild(spinner);
        }
        document.getElementById('spinner-message').textContent = message;
        spinner.style.display = 'flex';
    },

    /** Hides the loading spinner. */
    hideLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
    },

    /**
     * Displays a report modal after a bulk import is complete.
     * @param {string[]} importedStoryNames - A list of names of successfully imported stories.
     * @param {Array<{name: string, reason: string}>} failedFiles - A list of files that failed to import.
     */
    showBulkImportReport(importedStoryNames, failedFiles) {
        const container = document.getElementById('report-modal-content');
        let reportHTML = `
            <div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Bulk Import Report</h2></div>
            <div class="p-6 overflow-y-auto space-y-4">
                <div>
                    <h3 class="font-bold text-lg text-green-400">Success (${importedStoryNames.length})</h3>
                    <ul class="list-disc list-inside text-sm mt-2 max-h-40 overflow-y-auto bg-black/20 p-2 rounded-md">
                        ${importedStoryNames.map(name => `<li>${UTILITY.escapeHTML(name)}</li>`).join('') || '<li>No stories were imported successfully.</li>'}
                    </ul>
                </div>
        `;

        if (failedFiles.length > 0) {
            const logContent = failedFiles.map(f => `File: ${f.name}\nReason: ${f.reason}\n---`).join('\n');
            const logBlob = new Blob([logContent], { type: 'text/plain' });
            const logUrl = URL.createObjectURL(logBlob);

            reportHTML += `
                <div>
                    <h3 class="font-bold text-lg text-red-400">Failures (${failedFiles.length})</h3>
                    <p class="text-sm mt-2">Some files could not be imported. <a href="${logUrl}" download="import_error_log.txt" class="text-indigo-400 hover:underline">Download Error Log</a> for details.</p>
                </div>
            `;
        }
        
        reportHTML += `</div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('report-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        `;
        
        container.innerHTML = reportHTML;
        Controller.openModal('report-modal');
    },

    /**
     * Displays a generic confirmation modal. (Kept for simple, non-async confirmations).
     * @param {string} message - The message to display in the modal body.
     * @param {function} onConfirmCallback - The function to execute when the confirm button is clicked.
     */
    showConfirmationModal(message, onConfirmCallback) {
        const modal = document.getElementById('confirmation-modal');
        const messageEl = document.getElementById('confirmation-modal-message');
        const confirmBtn = document.getElementById('confirmation-modal-confirm-button');
        
        if (modal && messageEl && confirmBtn) {
            messageEl.textContent = message;
            
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.onclick = () => {
                onConfirmCallback();
                Controller.closeModal('confirmation-modal');
            };
            Controller.openModal('confirmation-modal');
        } else {
            console.error("Confirmation modal elements not found.");
        }
    },

    /**
     * Changes the primary action button to "Stop Generation" mode.
     */
    setButtonToStopMode() {
        const button = document.getElementById('primary-action-btn');
        if (!button) return;
        button.onclick = () => Controller.stopGeneration();
        button.title = "Stop Generation";
        button.classList.remove('bg-indigo-600/50', 'hover:bg-indigo-600/80');
        button.classList.add('bg-red-700/60', 'hover:bg-red-700/80');
        button.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v8a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 0h8v8H6V4z" clip-rule="evenodd" /></svg>`;
		
        // [FIX] Use setTimeout to defer attaching the new event handler.
        // This prevents a race condition where the initial click also triggers the stop function.
        setTimeout(() => {
            button.onclick = () => Controller.stopGeneration();
        }, 0);
    },

    /**
     * Reverts the primary action button to its default "Send / Write for Me" mode.
     */
    setButtonToSendMode() {
        const button = document.getElementById('primary-action-btn');
        if (!button) return;
        button.onclick = () => Controller.handlePrimaryAction();
        button.title = "Send / Write for Me";
        button.classList.remove('bg-red-700/60', 'hover:bg-red-700/80');
        button.classList.add('bg-indigo-600/50', 'hover:bg-indigo-600/80');
        button.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>`;
    },
};


    <!-- PASTE content of app.js HERE -->
/**
 * =================================================================================================
 * Controller Module (The Handler)
 * =================================================================================================
 * This module handles all user-initiated events. It acts as the "brain," receiving
 * user input, telling the StateManager how to change the data, calling the APIService
 * for AI responses, and then telling the UIManager to re-render the view.
 */
const Controller = {
    // A single place for constants the controller uses.
    CONSTANTS: {
        CHARACTER_COLORS: [
            { base: '#334155', bold: '#94a3b8' }, // Slate (Blue-Grey)
            { base: '#1e3a8a', bold: '#60a5fa' }, // Blue
            { base: '#581c87', bold: '#f472b6' }, // Fuchsia
            { base: '#78350f', bold: '#fbbf24' }, // Amber
            { base: '#365314', bold: '#a3e635' }, // Lime
            { base: '#5b21b6', bold: '#a78bfa' }, // Violet
            { base: '#881337', bold: '#fb7185' }, // Rose
            { base: '#155e75', bold: '#22d3ee' }  // Cyan
        ]
    },

    // Holds temporary, non-persistent properties related to the controller's runtime behavior.
    RUNTIME: {
        activeKnowledgeTab: 'static',
        activeSettingsTab: 'appearance',
        activeWorldMapTab: 'move',
        selectedMapTile: null,
        pendingMove: null,
        turnOfArrival: 0,
        selectedLocalStaticEntryId: null,
        activeRequestAbortController: null, // For aborting AI generation requests
    },

    // --- Story & Narrative Management ---

    /**
     * Creates the initial default story and narrative when the app is launched for the first time.
     * Ensures new users have a starting point.
     */
    createDefaultStoryAndNarrative() {
        const library = StateManager.getLibrary();

        const newStory = {
            id: UTILITY.uuid(), name: "My First Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(), creator_notes: "", tags: [],
            search_index: "my first story",
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(),
            characters: [
                { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[], is_narrator: false }, 
                { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: this.CONSTANTS.CHARACTER_COLORS[0], is_narrator: true }
            ], 
            dynamic_entries: [{id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content: "This is a sample dynamic lore entry.", triggered_at_turn: null }],
            selectedStaticEntryId: null, selectedDynamicEntryId: null,
            scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
            narratives: []
        };
        
        const defaultScenario = newStory.scenarios[0];
        const newNarrative = {
            id: UTILITY.uuid(), name: `${defaultScenario.name} - Chat`, last_modified: new Date().toISOString(),
            state: {
                chat_history: [], messageCounter: 0,
                static_entries: [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
            }
        };
        
        const firstSpeaker = newStory.characters.find(c => !c.is_user);
        newNarrative.state.chat_history.push({
            character_id: firstSpeaker.id, content: defaultScenario.message, type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(),
        });
        newNarrative.state.messageCounter = 1;

        newStory.narratives.push(newNarrative);
        
        library.stories.push(newStory);
        library.active_story_id = newStory.id;
        library.active_narrative_id = newNarrative.id;

        StateManager.saveLibrary();
        window.location.reload(); 
    },

    /**
     * Creates a new, blank story in the library.
     */
    createNewStory() {
        const library = StateManager.getLibrary();
        const newStory = {
            id: UTILITY.uuid(), name: "New Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(), creator_notes: "", tags: [], search_index: "new story",
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(),
            characters: [
                { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[], is_narrator: false }, 
                { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: this.CONSTANTS.CHARACTER_COLORS[0], is_narrator: true }
            ], 
            dynamic_entries: [{id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content: "This is a sample dynamic lore entry.", triggered_at_turn: null }],
            selectedStaticEntryId: null, selectedDynamicEntryId: null,
            scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
            narratives: []
        };
        library.stories.push(newStory);
        library.active_story_id = null;
        library.active_narrative_id = null;
        StateManager.saveLibrary();
        UIManager.renderLibraryInterface();
    },

    /**
     * Creates a new narrative (chat session) from a selected scenario template.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} scenarioId - The ID of the scenario to use as a template.
     */
    createNarrativeFromScenario(storyId, scenarioId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const scenario = story.scenarios.find(sc => sc.id === scenarioId);
        if (!story || !scenario) return;

        const newNarrative = {
            id: UTILITY.uuid(),
            name: `${scenario.name} - Chat`,
            created_date: new Date().toISOString(),
            last_modified: new Date().toISOString(),
            state: {}
        };

        if (scenario.static_entries && scenario.worldMap) {
            newNarrative.state = {
                chat_history: [],
                messageCounter: 0,
                static_entries: JSON.parse(JSON.stringify(scenario.static_entries)),
                worldMap: JSON.parse(JSON.stringify(scenario.worldMap))
            };
        } else {
            newNarrative.state = {
                chat_history: [], messageCounter: 0,
                static_entries: [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
            };
        }
        
        const firstMessage = scenario.message;
        if (firstMessage) {
            const firstSpeaker = story.characters.find(c => !c.is_user && c.is_active);
            if (firstSpeaker) {
                newNarrative.state.chat_history.push({
                    character_id: firstSpeaker.id, content: firstMessage, type: 'chat',
                    emotion: 'neutral', timestamp: new Date().toISOString(), isNew: true
                });
                newNarrative.state.messageCounter = 1;
            }
        }
        if(!story.narratives) story.narratives = [];
        story.narratives.push(newNarrative);
        this.loadNarrative(storyId, newNarrative.id);
    },

    /**
     * Loads a specific narrative, making it the active session, and reloads the application.
     * @param {string} storyId - The ID of the story containing the narrative.
     * @param {string} narrativeId - The ID of the narrative to load.
     */
    loadNarrative(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        library.active_story_id = storyId;
        library.active_narrative_id = narrativeId;
        StateManager.saveLibrary();
        window.location.reload();
    },

    /**
     * Duplicates an existing narrative.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} narrativeId - The ID of the narrative to duplicate.
     */
    duplicateNarrative(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const narrative = story.narratives.find(n => n.id === narrativeId);
        if (!story || !narrative) return;
        
        const newNarrative = JSON.parse(JSON.stringify(narrative));
        newNarrative.id = UTILITY.uuid();
        newNarrative.name = `${narrative.name} (Copy)`;
        newNarrative.created_date = new Date().toISOString();
        newNarrative.last_modified = new Date().toISOString();
        
        story.narratives.push(newNarrative);
        StateManager.saveLibrary();
        UIManager.openStoryDetails(storyId);
    },

    /**
     * Deletes a narrative after user confirmation.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} narrativeId - The ID of the narrative to delete.
     */
    deleteNarrative(storyId, narrativeId) {
        UIManager.showConfirmationModal('Are you sure you want to permanently delete this narrative and all its chat history?', () => {
            const library = StateManager.getLibrary();
            const story = library.stories.find(s => s.id === storyId);
            if (story) {
                story.narratives = story.narratives.filter(n => n.id !== narrativeId);
                if (library.active_narrative_id === narrativeId) {
                    library.active_narrative_id = null;
                }
                StateManager.saveLibrary();
                UIManager.openStoryDetails(storyId);
            }
        });
    },

    /**
     * Duplicates an existing scenario.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} scenarioId - The ID of the scenario to duplicate.
     */
    duplicateScenario(storyId, scenarioId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const scenario = story.scenarios.find(sc => sc.id === scenarioId);
        if (!story || !scenario) return;
        
        const newScenario = JSON.parse(JSON.stringify(scenario));
        newScenario.id = UTILITY.uuid();
        newScenario.name = `${scenario.name} (Copy)`;
        story.scenarios.push(newScenario);
        StateManager.saveLibrary();
        UIManager.openStoryDetails(storyId);
    },
    
    /**
     * Deletes a scenario after user confirmation.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} scenarioId - The ID of the scenario to delete.
     */
    deleteScenario(storyId, scenarioId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (story) {
            if (story.scenarios.length <= 1) {
                alert("You cannot delete the last scenario.");
                return;
            }
            UIManager.showConfirmationModal('Are you sure you want to delete this scenario?', () => {
                story.scenarios = story.scenarios.filter(sc => sc.id !== scenarioId);
                StateManager.saveLibrary();
                UIManager.openStoryDetails(storyId);
            });
        }
    },

    /**
     * Deletes an entire story and all its contents after user confirmation.
     * @param {string} storyId - The ID of the story to delete.
     */
    deleteStory(storyId) {
        UIManager.showConfirmationModal('Are you sure you want to permanently delete this entire story, including all its narratives and scenarios?', () => {
            const library = StateManager.getLibrary();
            library.stories = library.stories.filter(s => s.id !== storyId);
            StateManager.updateTagCache();

            if (library.active_story_id === storyId) {
                library.active_story_id = null;
                library.active_narrative_id = null;
                StateManager.saveLibrary();
                window.location.reload();
            } else {
                StateManager.saveLibrary();
                UIManager.renderLibraryInterface();
            }
        });
    },

    /**
     * Renames a story.
     * @param {string} storyId - The ID of the story to rename.
     * @param {string} newName - The new name for the story.
     */
    renameStory(storyId, newName) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if(story) {
            story.name = newName;
            StateManager.saveLibrary();
            UIManager.renderLibraryInterface();
            if (story.id === library.active_story_id) {
                UIManager.renderAll();
            }
        }
    },

    /**
     * Prompts the user to enter a new name for a story.
     * @param {string} storyId - The ID of the story.
     */
    renameStoryPrompt(storyId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (story) {
            const currentName = story.name || '';
            const newName = prompt("Enter new name for the story:", currentName);
            if (newName && newName.trim() !== '') {
                this.renameStory(storyId, newName.trim());
            }
        }
    },

    /**
     * Duplicates an entire story object.
     * @param {string} storyId - The ID of the story to duplicate.
     */
    duplicateStory(storyId) {
        const library = StateManager.getLibrary();
        const originalStory = library.stories.find(s => s.id === storyId);
        if (!originalStory) return;

        const newStory = JSON.parse(JSON.stringify(originalStory));
        newStory.id = UTILITY.uuid();
        newStory.name = `${originalStory.name || 'Untitled Story'} (Copy)`;
        newStory.last_modified = new Date().toISOString();
        newStory.created_date = new Date().toISOString();
        
        this.updateSearchIndex(newStory);
        library.stories.push(newStory);
        StateManager.saveLibrary();
        UIManager.renderLibraryInterface();
    },

    /**
     * Updates the searchable text index for a story.
     * @param {object} story - The story object to index.
     */
    updateSearchIndex(story) {
        if (!story) return;
        let index = [story.name];
        if (story.tags) index.push(...story.tags);
        if (story.characters) {
            story.characters.forEach(char => {
                index.push(char.name);
                index.push(char.description);
                if (char.tags) index.push(...char.tags);
            });
        }
        story.search_index = index.join(' ').toLowerCase();
    },

    // --- Modal & UI State Management ---

    /**
     * Handles the opening of all modals, performing necessary setup for each.
     * @param {string} modalId - The ID of the modal to open.
     * @param {*} [contextId=null] - An optional context ID (e.g., character ID, message index).
     */
    openModal(modalId, contextId = null) { 
        const library = StateManager.getLibrary();
        const state = StateManager.getState();
        
        if ((modalId === 'knowledge-modal' || modalId === 'characters-modal' || modalId === 'settings-modal' || modalId === 'example-dialogue-modal' || modalId === 'character-detail-modal' || modalId === 'world-map-modal' || modalId === 'io-hub-modal') && (!library.active_story_id && modalId !== 'io-hub-modal')) {
             alert("Please load a narrative first.");
             return;
        }

        switch(modalId) {
            case 'story-library-modal':
                UIManager.renderLibraryInterface();
                break;
            case 'io-hub-modal':
                UIManager.renderIOHubModal();
                break;
            case 'knowledge-modal':
                this.switchKnowledgeTab('static');
                break;
            case 'world-map-modal':
                this.RUNTIME.selectedMapTile = null;
                this.RUNTIME.pendingMove = null;
                this.RUNTIME.selectedLocalStaticEntryId = null;
                this.switchWorldMapTab('move');
                break;
            case 'settings-modal':
                this.prepareSettingsModal();
                this.switchSettingsTab(this.RUNTIME.activeSettingsTab || 'appearance');
                break;
            case 'example-dialogue-modal':
                UIManager.renderExampleDialogueModal();
                break;
            case 'character-detail-modal':
                UIManager.openCharacterDetailModal(contextId);
                break;
            case 'edit-response-modal':
                this.openEditModal(contextId);
                break;
        }
        ModalManager.open(modalId);
    },
    
    /** Closes a modal. */
    closeModal(modalId) { 
        ModalManager.close(modalId);
        if (modalId === 'character-detail-modal') {
            UIManager.renderCharacters();
        }
    },

    /** Toggles the mobile navigation menu. */
    toggleMobileMenu() {
        document.getElementById('mobile-menu').classList.toggle('hidden');
    },

    /** Switches between static and dynamic tabs in the Knowledge modal. */
    switchKnowledgeTab(tabName) {
        this.RUNTIME.activeKnowledgeTab = tabName;
        UIManager.renderKnowledgeModalTabs();
    },

    /** Switches between move and world map tabs in the World Map modal. */
    switchWorldMapTab(tabName) {
        this.RUNTIME.activeWorldMapTab = tabName;
        UIManager.renderWorldMapModal();
    },

    /**
     * Switches between tabs in the Settings modal and binds necessary event listeners.
     * @param {string} tabName - The name of the tab to activate ('appearance', 'prompt', 'model').
     */
    switchSettingsTab(tabName) {
        this.RUNTIME.activeSettingsTab = tabName;
        const tabs = ['appearance', 'prompt', 'model'];
        const container = document.getElementById('settings-content-container');
        const template = document.getElementById(`settings-${tabName}-content`);
        container.innerHTML = template.innerHTML;

        tabs.forEach(tab => {
            const tabButton = document.getElementById(`settings-tab-${tab}`);
            if (tab === tabName) {
                tabButton.classList.add('border-indigo-500', 'text-white');
                tabButton.classList.remove('border-transparent', 'text-gray-400');
            } else {
                tabButton.classList.remove('border-indigo-500', 'text-white');
                tabButton.classList.add('border-transparent', 'text-gray-400');
            }
        });
        this.bindSettingsListeners();
    },

    /** Opens the settings modal directly to a specific tab. */
    openSettingsToTab(tabName) {
        this.openModal('settings-modal');
        this.switchSettingsTab(tabName);
    },

    /** Prepares the settings modal content on first open. */
    prepareSettingsModal() {
        const container = document.getElementById('settings-content-container');
        if (container.innerHTML.trim() !== '...') return; // Already populated
        
        const templates = document.getElementById('settings-templates');
        let maxHeight = 0;
        ['appearance', 'prompt', 'model'].forEach(tabName => {
            const content = templates.querySelector(`#settings-${tabName}-content`);
            if(content) {
                 document.body.appendChild(content); // Temporarily append to measure
                 maxHeight = Math.max(maxHeight, content.scrollHeight);
                 templates.appendChild(content); // Move it back
            }
        });
        container.style.minHeight = `${maxHeight}px`;
    },
	
	/** Handles the upload of a local image for the global background. */
    async handleBackgroundImageUpload(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        if (file.size > 5 * 1024 * 1024) { // 5MB Limit
            alert("Error: Image file size should not exceed 5MB.");
            event.target.value = '';
            return;
        }

        UIManager.showLoadingSpinner?.('Processing background image...');
        let savedSuccessfully = false; // Flag to track DB save success

        try {
            const blob = await ImageProcessor.processImageAsBlob(file);
            const key = 'global_background_image';

            // --- MODIFICATION: Check saveImage result ---
            savedSuccessfully = await DBService.saveImage(key, blob);

            if (!savedSuccessfully) {
                 // Throw an error if saving failed to stop execution and show alert
                 throw new Error("Failed to save the image to the browser database (IndexedDB). This might happen in private browsing mode or if storage quota is exceeded.");
            }
            // --- END MODIFICATION ---

            console.log("Image saved to IndexedDB successfully."); // Log success

            // Live-cache update
            const oldUrl = UIManager.RUNTIME.globalBackgroundImageCache;
            if (oldUrl) URL.revokeObjectURL(oldUrl);
            UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(blob);

            // Set state to use the new local image and save
            const state = StateManager.getState();
            state.backgroundImageURL = 'local_idb_background'; // Special keyword
            console.log("Saving state with backgroundImageURL =", state.backgroundImageURL);
            StateManager.saveState();

            UIManager.applyStyling(); // Re-apply to show the new background

            // Update the hint text
            const bgHint = document.getElementById('background-image-hint');
            if (bgHint) bgHint.textContent = 'Current: [Local Image]';

        } catch (err) {
            console.error("Error processing or saving background image:", err);
            alert(`Upload failed: ${err.message}`); // Show the specific error

            // --- ROLLBACK LOGIC (No change needed here, handled by throwing error) ---
            // If save failed, the state/cache updates above won't run.
            // We should ensure the hint reflects failure.
             const bgHint = document.getElementById('background-image-hint');
             const currentState = StateManager.getState()?.backgroundImageURL;
             if (bgHint) {
                 if(currentState === 'local_idb_background'){
                     // This case shouldn't happen if error is thrown correctly, but as a safeguard:
                     bgHint.textContent = 'Current: [Save Failed]';
                 } else if (currentState) {
                      bgHint.textContent = 'Current: [Legacy URL]';
                 } else {
                     bgHint.textContent = 'Current: None';
                 }
             }

        } finally {
            UIManager.hideLoadingSpinner?.();
            // Clear the file input ONLY if the save was successful
            if (savedSuccessfully) {
                event.target.value = '';
            }
        }
    },

    /** Clears the locally stored background image. */
async clearBackgroundImage() {
        UIManager.showLoadingSpinner?.('Clearing background...');
        try {
            await DBService.deleteImage('global_background_image');

            const oldUrl = UIManager.RUNTIME.globalBackgroundImageCache;
            if (oldUrl) URL.revokeObjectURL(oldUrl);
            UIManager.RUNTIME.globalBackgroundImageCache = null;

            const state = StateManager.getState();
            state.backgroundImageURL = ''; // Clear the state
            StateManager.saveState();

            UIManager.applyStyling(); // Re-apply to show the default background

            // [NEW] Update the hint text
            const bgHint = document.getElementById('background-image-hint');
            if (bgHint) bgHint.textContent = 'Current: None';

        } catch (err) {
            console.error("Error clearing background image:", err);
            alert("There was an error clearing the background.");
        } finally {
            UIManager.hideLoadingSpinner?.();
        }
    },

    /** Binds all event listeners for the interactive elements within the settings modal. */
    bindSettingsListeners() {
        const state = StateManager.getState();
        const setListener = (id, key, callback) => { 
            const input = document.getElementById(id); 
            if (!input) return;
            input.value = state[key] !== undefined ? state[key] : '';
            const debouncedCallback = debounce(function(e) { 
                state[key] = e.target.value; 
                StateManager.saveState();
                if(callback) callback();
            }.bind(this), 500);
            input.addEventListener('input', debouncedCallback); 
        };
        const setupSlider = (sliderId, valueId, stateKey, callback = null) => {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            if (!slider || !valueDisplay) return;
            slider.value = state[stateKey];
            valueDisplay.textContent = slider.value;
            slider.addEventListener('input', (e) => {
                state[stateKey] = parseFloat(e.target.value);
                valueDisplay.textContent = e.target.value;
                if(callback) callback();
            });
            slider.addEventListener('change', () => StateManager.saveState());
        };
        
        // Model Tab
		
        if(document.getElementById('gemini-api-key-input')) setListener('gemini-api-key-input', 'geminiApiKey'); 
        if(document.getElementById('openrouter-api-key-input')) setListener('openrouter-api-key-input', 'openRouterKey'); 
        if(document.getElementById('openrouter-model-input')) setListener('openrouter-model-input', 'openRouterModel'); 
        if(document.getElementById('koboldcpp-min-p-slider')) setupSlider('koboldcpp-min-p-slider', 'koboldcpp-min-p-value', 'koboldcpp_min_p');
        if(document.getElementById('koboldcpp-dry-slider')) setupSlider('koboldcpp-dry-slider', 'koboldcpp-dry-value', 'koboldcpp_dry');
		
		const bgHint = document.getElementById('background-image-hint');
        if (bgHint) {
            if (state.backgroundImageURL === 'local_idb_background') {
                bgHint.textContent = 'Current: [Local Image]';
            } else if (state.backgroundImageURL) {
                bgHint.textContent = 'Current: [Legacy URL]';
            } else {
                bgHint.textContent = 'Current: None';
            }
        }

        // Appearance Tab
		document.getElementById('background-image-upload')?.addEventListener('change', (e) => Controller.handleBackgroundImageUpload(e));
		document.getElementById('background-image-clear')?.addEventListener('click', () => Controller.clearBackgroundImage());
        if(document.getElementById('chat-text-color')) setListener('chat-text-color', 'chatTextColor', () => UIManager.applyStyling());
        if(document.getElementById('blur-slider')) setupSlider('blur-slider', 'blur-value', 'backgroundBlur', () => UIManager.applyStyling());
        if(document.getElementById('text-size-slider')) setupSlider('text-size-slider', 'text-size-value', 'textSize', () => UIManager.applyStyling());
        if(document.getElementById('bubble-image-size-slider')) setupSlider('bubble-image-size-slider', 'bubble-image-size-value', 'bubbleImageSize', () => UIManager.applyStyling());

        // Prompt Tab
        if(document.getElementById('system-prompt-input')) setListener('system-prompt-input', 'system_prompt');
        if(document.getElementById('event-master-prompt-input')) setListener('event-master-prompt-input', 'event_master_base_prompt');
        if(document.getElementById('prompt-persona-gen-input')) setListener('prompt-persona-gen-input', 'prompt_persona_gen');
        if(document.getElementById('prompt-world-map-gen-input')) setListener('prompt-world-map-gen-input', 'prompt_world_map_gen');
        if(document.getElementById('prompt-location-gen-input')) setListener('prompt-location-gen-input', 'prompt_location_gen');
        if(document.getElementById('prompt-entry-gen-input')) setListener('prompt-entry-gen-input', 'prompt_entry_gen');
        if(document.getElementById('prompt-location-memory-gen-input')) setListener('prompt-location-memory-gen-input', 'prompt_location_memory_gen');

        
        const fontSelector = document.getElementById('font-selector'); 
        if(fontSelector) {
            fontSelector.value = state.font; 
            fontSelector.addEventListener('change', (e) => this.changeFont(e.target.value));
        }

        const templateSelector = document.getElementById('koboldcpp-template-selector');
        if(templateSelector) {
            templateSelector.value = state.koboldcpp_template;
            templateSelector.addEventListener('change', (e) => {
                state.koboldcpp_template = e.target.value;
                StateManager.saveState();
            });
        }
        
        const opacitySlider = document.getElementById('bubble-opacity-slider');
        if(opacitySlider) {
            const opacityValue = document.getElementById('bubble-opacity-value');
            opacitySlider.value = state.bubbleOpacity;
            opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
            opacitySlider.addEventListener('input', (e) => {
                state.bubbleOpacity = parseFloat(e.target.value);
                opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
                UIManager.renderChat();
            });
            opacitySlider.addEventListener('change', () => StateManager.saveState());
        }
        
        document.querySelectorAll('input[name="imageDisplayMode"]').forEach(radio => {
            radio.checked = state.characterImageMode === radio.value;
            radio.addEventListener('change', (e) => this.setCharacterImageMode(e.target.value));
        });
        document.querySelectorAll('input[name="apiProvider"]').forEach(radio => {
            radio.checked = state.apiProvider === radio.value;
            radio.addEventListener('change', (e) => this.setApiProvider(e.target.value));
        });

        const geminiSettings = document.getElementById('gemini-settings');
        const openrouterSettings = document.getElementById('openrouter-settings');
        const koboldcppSettings = document.getElementById('koboldcpp-settings');
        if (geminiSettings) geminiSettings.style.display = state.apiProvider === 'gemini' ? 'block' : 'none'; 
        if (openrouterSettings) openrouterSettings.style.display = state.apiProvider === 'openrouter' ? 'block' : 'none';
        if (koboldcppSettings) koboldcppSettings.style.display = state.apiProvider === 'koboldcpp' ? 'block' : 'none';
    },
    
    /** Changes the chat font. */
    changeFont(font) { 
        StateManager.getState().font = font; 
        UIManager.applyStyling(); 
        StateManager.saveState(); 
    },
    
    /** Sets the character image display mode. */
    setCharacterImageMode(mode) {
        StateManager.getState().characterImageMode = mode;
        StateManager.saveState();
        UIManager.renderChat();
    },

    /** Sets the active AI provider. */
    setApiProvider(provider) { 
        StateManager.getState().apiProvider = provider; 
        this.bindSettingsListeners(); 
        StateManager.saveState(); 
    },
	
    // --- Chat & AI Interaction ---
    
    /** Handles the primary user action button, which can be Send, Write for Me, or Stop Generation. */
    handlePrimaryAction() { 
        if (!StateManager.getLibrary().active_story_id) { 
            UIManager.showConfirmationModal("Please load or create a story from the Story Library first.", () => this.openModal('story-library-modal')); 
            return; 
        } 
        document.getElementById('chat-input').value.trim() === '' ? this.writeForMe() : this.sendMessage(); 
    },

    /** Handles the regenerate button click, re-triggering an AI response. */
    async handleRegen() {
        const state = StateManager.getState();
        if(!StateManager.getLibrary().active_narrative_id) { alert("Load a narrative from the Story Library first."); return; }
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        
        let selectedCharId = document.getElementById('ai-character-selector').value;
        if (selectedCharId === 'any') {
            selectedCharId = this.determineNextSpeaker(false); // isMove = false
        }

        const lastMsg = state.chat_history.filter(m => m.type === 'chat').pop();
        const lastChar = lastMsg ? state.characters.find(c => c.id === lastMsg.character_id) : null;

        if (lastChar && !lastChar.is_user && lastMsg.character_id === selectedCharId) {
            this.undoLastTurn();
            await this.triggerAIResponse(selectedCharId);
        } else {
            await this.triggerAIResponse(selectedCharId);
        }
    },

    /** Sends a user message from the chat input. */
    async sendMessage() {
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        const input = document.getElementById('chat-input');
        const userChar = state.characters.find(c => c.is_user);
        const messageContent = input.value.trim();
        if (!messageContent) return;
        this.addMessageToHistory(userChar.id, messageContent);
        input.value = '';
        this.checkDynamicEntryTriggers();
        await this.triggerAIResponse(null, messageContent);
        this.checkEventMaster();
    },

    /** Triggers the AI to write a response for the user's character. */
    async writeForMe() {
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        const userChar = state.characters.find(c => c.is_user); if (!userChar) return;
        const input = document.getElementById('chat-input');
        
        UIManager.setButtonToStopMode();
        this.RUNTIME.activeRequestAbortController = new AbortController();

        try {
            const prompt = PromptBuilder.buildPrompt(userChar.id, true);
            input.value = await APIService.callAI(prompt, false, this.RUNTIME.activeRequestAbortController.signal);
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Write For Me generation stopped by user.");
            } else {
                console.error("Write for Me failed:", error);
            }
        } finally {
            UIManager.setButtonToSendMode();
            this.RUNTIME.activeRequestAbortController = null;
        }
    },

    /** Undoes the last message in the chat history. */
    undoLastTurn() { 
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        if (state.chat_history.length === 0) return; 
        const lastMessage = state.chat_history[state.chat_history.length - 1]; 
        if (lastMessage && lastMessage.type === 'chat') {
            state.messageCounter--;
        }
        state.chat_history.pop();
        this.saveAndRender(); 
    },

    /**
     * Adds a message to the active narrative's chat history.
     * @param {string} id - The ID of the character sending the message.
     * @param {string} content - The message content.
     * @param {string} [type='chat'] - The type of message ('chat', 'system_event', etc.).
     * @param {string} [emotion='neutral'] - The detected emotion for the message.
     */
    addMessageToHistory(id, content, type = 'chat', emotion = 'neutral') {
        const state = StateManager.getState();
        if (UIManager.RUNTIME.streamingInterval) {
            clearInterval(UIManager.RUNTIME.streamingInterval);
            UIManager.RUNTIME.streamingInterval = null;
            StateManager.saveState();
        }
        state.chat_history.push({ 
            character_id: id, content, type, emotion,
            timestamp: new Date().toISOString(), isNew: true 
        });
        if (type === 'chat') state.messageCounter++;
        UIManager.renderChat();
        StateManager.saveState();
        
        const chatWindow = document.getElementById('chat-window');
        const lastBubble = chatWindow.lastElementChild;
        if(lastBubble) {
            lastBubble.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    },

    /**
     * Adds a system event message (e.g., "You have moved to...") to the chat history.
     * @param {string} content - The content of the system message.
     */
    addSystemMessageToHistory(content) {
        const state = StateManager.getState();
        state.chat_history.push({
            type: 'system_event', content, timestamp: new Date().toISOString(), isNew: true
        });
        UIManager.renderChat();
        StateManager.saveState();
    },

    /** Displays the speaker scores modal for debugging. */
    showSpeakerScores(scoresData) {
        UIManager.renderSpeakerScoresModal(scoresData);
    },

    /**
     * Determines which AI character should speak next based on a weighted scoring algorithm.
     * @param {boolean} [isAfterMove=false] - A flag indicating if the determination is happening after a map move.
     * @returns {string|null} The ID of the character chosen to speak next.
     */
    determineNextSpeaker(isAfterMove = false) {
        const state = StateManager.getState();
        let pool = state.characters.filter(c => !c.is_user && c.is_active);
    
        if (pool.length === 0) {
            return null;
        }
        if (pool.length === 1) {
            return pool[0].id;
        }
    
        if (isAfterMove) {
            const narrators = pool.filter(c => c.is_narrator);
            if (narrators.length > 0) {
                return narrators[Math.floor(Math.random() * narrators.length)].id;
            }
        }
    
        const chatHistory = (state.chat_history || []).filter(m => m.type === 'chat' && !m.isHidden);
        const nonUserHistory = chatHistory.filter(m => state.characters.some(c => c.id === m.character_id && !c.is_user));
    
        if (!isAfterMove && nonUserHistory.length > 0) {
            const lastAiSpeaker = state.characters.find(c => c.id === nonUserHistory[nonUserHistory.length - 1].character_id);
            if (lastAiSpeaker && lastAiSpeaker.is_narrator) {
                const potentialPool = pool.filter(c => c.id !== lastAiSpeaker.id);
                if (potentialPool.length > 0) {
                    pool = potentialPool;
                }
            }
        }
    
        if (pool.length === 1) {
            return pool[0].id;
        }
    

		const scores = {};
		pool.forEach(c => {
			scores[c.id] = c.is_narrator ? 0 : 1;
		}); 
		
		const narratorsInPool = pool.filter(c => c.is_narrator);
        if (narratorsInPool.length > 0) {
            for (let i = chatHistory.length - 1; i >= 0; i--) {
                const message = chatHistory[i];
                const speaker = state.characters.find(c => c.id === message.character_id);
                if (speaker && speaker.is_narrator) {
                    break;
                }
                narratorsInPool.forEach(narrator => {
                    scores[narrator.id] += 0.2;
                });
            }
        }
    
         if (nonUserHistory.length >= 1) {
            const lastSpeakerId = nonUserHistory[nonUserHistory.length - 1].character_id;
            const lastSpeaker = state.characters.find(c => c.id === lastSpeakerId);
            if (scores[lastSpeakerId] !== undefined && lastSpeaker && !lastSpeaker.is_narrator) {
                 scores[lastSpeakerId] += 1;
            }
        }
        if (nonUserHistory.length >= 2) {
            const secondLastSpeakerId = nonUserHistory[nonUserHistory.length - 2].character_id;
            const secondLastSpeaker = state.characters.find(c => c.id === secondLastSpeakerId);
            if (scores[secondLastSpeakerId] !== undefined && secondLastSpeaker && !secondLastSpeaker.is_narrator) {
                scores[secondLastSpeakerId] += 0.5;
            }
        }
    
        const last2Messages = chatHistory.slice(-2);
        const last4Messages = chatHistory.slice(-4);
    
        pool.forEach(char => {
            const charName = char.name.toLowerCase();
            if (last2Messages.some(msg => msg.content.toLowerCase().includes(charName))) {
                scores[char.id] += 0.5;
            }
            if (last4Messages.some(msg => msg.content.toLowerCase().includes(charName))) {
                scores[char.id] += 0.5;
            }
        });
    
        const characters = pool;
        const weights = characters.map(c => scores[c.id]);
        
        const winner = UTILITY.weightedChoice(characters, weights, this);
        return winner ? winner.id : pool[0]?.id || null;
    },

    /**
     * Constructs the prompt, calls the APIService, and handles the AI's response or any errors.
     * @param {string|null} charId - The ID of the character to respond, or null to auto-determine.
     * @param {string} [userMessage=''] - The content of the user's last message for analysis.
     * @param {boolean} [isAfterMove=false] - Flag if this is a response after a map move.
     */
    async triggerAIResponse(charId = null, userMessage = '', isAfterMove = false) {
        const state = StateManager.getState();
        const activeAiChars = state.characters.filter(c => !c.is_user && c.is_active);
        if (activeAiChars.length === 0) {
            this.addMessageToHistory(systemSpeaker.id, "No active character. Ensure at least one character is active in the chat.");
            return;
        }
		
        const isModelConfigured = () => {
            switch (state.apiProvider) {
                case 'gemini': return !!state.geminiApiKey;
                case 'openrouter': return !!state.openRouterKey && !!state.openRouterModel;
                case 'koboldcpp': return !!state.koboldcpp_url;
                default: return false;
            }
        };
        if (!isModelConfigured()) {
            this.addMessageToHistory(activeAiChars[0].id, "The AI model is not configured. Please check your settings.");
            return;
        }
        const selectedCharId = charId || document.getElementById('ai-character-selector').value;
        let aiCharId = selectedCharId === 'any' ? this.determineNextSpeaker(isAfterMove) : selectedCharId;
        if (!aiCharId) {
            console.log("AI response skipped: No eligible speaker determined.");
            return;
        }
        
        UIManager.showTypingIndicator(aiCharId);
        UIManager.setButtonToStopMode();
        this.RUNTIME.activeRequestAbortController = new AbortController();

        try {
            const prompt = PromptBuilder.buildPrompt(aiCharId);
            const responseText = await APIService.callAI(prompt, false, this.RUNTIME.activeRequestAbortController.signal);
            let analysis = { emotion: 'neutral', locationName: null };
            if (userMessage) {
                try { analysis = await this.analyzeTurn(userMessage); } 
                catch (e) { console.error("Turn analysis failed:", e); }
            }
            UIManager.hideTypingIndicator();
            UIManager.startStreamingResponse(aiCharId, responseText, analysis.emotion);
            if (analysis.locationName) {
                const targetLocation = state.worldMap.grid.find(loc => loc.name.toLowerCase() === analysis.locationName.toLowerCase());
                const currentLocationData = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
                if (targetLocation && targetLocation.name !== currentLocationData?.name) {
                    setTimeout(() => { this.moveToLocation(targetLocation.coords.x, targetLocation.coords.y); }, 1500);
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Generation stopped by user.");
            } else {
                this.addMessageToHistory(aiCharId, `[Error: ${error.message}]`); 
            }
            UIManager.hideTypingIndicator();
        } finally {
            UIManager.setButtonToSendMode();
            this.RUNTIME.activeRequestAbortController = null;
        }
    },
    
    // --- Agent & Trigger Logic ---

    /**
     * Invokes an AI agent to analyze the recent conversation and suggest updates to the static knowledge base.
     */
    async checkWorldInfoAgent() { 
        const state = StateManager.getState();
        if (!StateManager.getLibrary().active_narrative_id) { alert("Please load a narrative first."); return; }
        UIManager.showTypingIndicator('static-entry-agent', 'Updating static knowledge...'); 
        try { 
            let p = `As Static Knowledge Master, read chat/info, update the info. Output valid JSON: { "add": [{"title": "...", "content": "..."}], "modify": [{"title": "...", "new_content": "..."}] } or {}. INFO:${JSON.stringify(state.static_entries)}CHAT:`; 
            (state.chat_history || []).filter(m=>m.type==='chat').slice(-8).forEach(msg => { const c = state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;});
            const updates = JSON.parse(await APIService.callAI(p, true)); 
            if (updates.add) updates.add.forEach(item => state.static_entries.push({id: UTILITY.uuid(), ...item})); 
            if (updates.modify) updates.modify.forEach(item => { const entry = state.static_entries.find(e => e.title.toLowerCase() === item.title.toLowerCase()); if (entry) entry.content = item.new_content; }); 
            this.saveAndRenderStaticEntries(); 
        } catch (e) { 
            console.error("Static Entry Agent failed:", e); 
            alert("The AI failed to update static entries. It may have returned an invalid format.");
        } finally { 
            UIManager.hideTypingIndicator(); 
        } 
    },
    
    /**
     * Every few turns, invokes an AI agent to generate a secret, surprising event instruction for other AI characters.
     */
    async checkEventMaster() { 
        const state = StateManager.getState();
        if (state.messageCounter > 0 && state.messageCounter % 6 === 0) try { 
            let p = state.event_master_base_prompt + '\n\n--- RECENT CHAT HISTORY ---\n'; 
            (state.chat_history || []).filter(m=>m.type==='chat').slice(-12).forEach(msg => { const c = state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;});
            state.event_master_prompt = await APIService.callAI(p); 
            StateManager.saveState(); 
            console.log("Event Master:", state.event_master_prompt); 
        } catch (e) { 
            console.error("Event Master failed:", e); 
        } 
    },
    
    /**
     * Checks the last message against all dynamic entry triggers and activates any that match.
     */
    checkDynamicEntryTriggers() {
        const state = StateManager.getState();
        const lastMessage = (state.chat_history || []).filter(m => m.type === 'chat').pop();
        if (!lastMessage) return;
        const content = lastMessage.content.toLowerCase();

        (state.dynamic_entries || []).forEach(entry => {
            if (entry.triggered_at_turn !== null && (state.messageCounter - entry.triggered_at_turn > 10)) {
                entry.triggered_at_turn = null;
            }

            if (entry.triggered_at_turn === null) {
                const { groups, chance } = this.parseTriggers(entry.triggers);
                const keywordMatch = groups.some(group => {
                    switch (group.type) {
                        case 'OR': return content.includes(group.keywords[0]);
                        case 'AND': return group.keywords.every(kw => content.includes(kw));
                        case 'XOR': const [f, s] = [content.includes(group.keywords[0]), content.includes(group.keywords[1])]; return (f && !s) || (!f && s);
                        default: return false;
                    }
                });
                if (keywordMatch || (Math.random() * 100 < chance)) {
                    entry.triggered_at_turn = state.messageCounter;
                    state.chat_history.push({ type: 'lore_reveal', title: entry.title, content: entry.content });
                    console.log(`Dynamic Entry triggered: ${entry.title}`);
                }
            }
        });
        StateManager.saveState();
        UIManager.renderDynamicEntries();
    },

    /**
     * Parses the trigger string from a dynamic entry into a structured format.
     * @param {string} triggersStr - The raw trigger string (e.g., "house, cat AND dog, 25%").
     * @returns {{groups: Array, chance: number}} - A structured object of triggers.
     */
    parseTriggers(triggersStr) {
        if (!triggersStr) return { groups: [], chance: 0 };
        const parts = triggersStr.split(',').map(s => s.trim());
        const chancePart = parts.find(p => p.match(/^\d+\s*\%$/));
        const chance = chancePart ? parseInt(chancePart.replace('%', '')) : 0;
        const keywordParts = parts.filter(p => p && !p.match(/^\d+\s*\%$/));
        const groups = keywordParts.map(part => {
            if (part.includes(' XOR ')) { const keywords = part.split(' XOR ').map(k => k.trim().toLowerCase()).filter(Boolean); if (keywords.length === 2) return { type: 'XOR', keywords }; }
            if (part.includes(' AND ')) { const keywords = part.split(' AND ').map(k => k.trim().toLowerCase()).filter(Boolean); if (keywords.length > 0) return { type: 'AND', keywords }; }
            return { type: 'OR', keywords: [part.toLowerCase()] };
        });
        return { groups, chance };
    },

    // --- CRUD and Edit Functions ---

    /** Opens the modal to edit a specific chat message. */
    openEditModal(index) {
        const state = StateManager.getState();
        const message = state.chat_history[index];
        const input = document.getElementById('edit-modal-input');
        input.value = message.content;
        const autoResize = () => { input.style.height = 'auto'; input.style.height = `${input.scrollHeight}px`; };
        if (input.autoResizeListener) input.removeEventListener('input', input.autoResizeListener);
        input.autoResizeListener = autoResize;
        input.addEventListener('input', autoResize);
        document.getElementById('edit-modal-save-button').onclick = () => this.saveEditedResponse(index);
        setTimeout(autoResize, 0);
        ModalManager.open('edit-response-modal');
    },

    /** Saves the edited content of a chat message. */
    saveEditedResponse(index) {
        const state = StateManager.getState();
        const newContent = document.getElementById('edit-modal-input').value;
        state.chat_history[index].content = newContent;
        this.saveAndRender();
        this.closeModal('edit-response-modal');
    },

    /** Uses AI to enhance a character's persona description. */
    async enhancePersonaWithAI(event, charId) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) return;

        UIManager.showConfirmationModal('This will overwrite the current persona with an AI-generated one. Are you sure?', async () => {
            const newDescription = await this._generateContentForField(event, state.prompt_persona_gen, {
                concept: char.description
            });
            
            if (newDescription !== null) {
                this.updateCharacterField(charId, 'description', newDescription);
                const personaTextarea = document.getElementById(`persona-description-${charId}`);
                if (personaTextarea) {
                    personaTextarea.value = newDescription;
                    const autoResize = () => { personaTextarea.style.height = 'auto'; personaTextarea.style.height = `${personaTextarea.scrollHeight}px`; };
                    autoResize();
                }
            }
        });
    },

    /** Uses AI to generate model instructions based on a character's persona. */
    async generateModelInstructions(event, charId) {
        UIManager.showConfirmationModal("This will overwrite the current model instructions. Are you sure?", async () => {
            const state = StateManager.getState();
            const char = state.characters.find(c => c.id === charId);
            if (!char) return;

            const staticKnowledge = (state.static_entries || []).map(e => `### ${e.title}\n${e.content}`).join('\n\n');
            const prompt = `Based on the following character persona and world information, generate a concise set of model instructions for an AI roleplaying as this character. The instructions should guide the AI on how to speak, its personality, and key traits to embody.\n\n### Character Persona:\n${char.description}\n\n### World Static Knowledge:\n${staticKnowledge}\n\n### INSTRUCTIONS:`;
            
            const newInstructions = await this._generateContentForField(event, prompt, {});
            
            if (newInstructions !== null) {
                this.updateCharacterField(charId, 'model_instructions', newInstructions);
                UIManager.openCharacterDetailModal(charId);
            }
        });
    },

    /** Helper function to manage button state and call the AI service for content generation. */
    async _generateContentForField(event, promptTemplate, context, isJson = false) {
        const button = event.target.closest('button');
        if (!button) return null;

        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '...';
        
        try {
            let prompt = promptTemplate;
            for (const key in context) {
                prompt = prompt.replace(new RegExp(`{${key}}`, 'g'), context[key]);
            }
            return await APIService.callAI(prompt, isJson);
        } catch (error) {
            console.error("AI Generation failed:", error);
            alert(`AI generation failed: ${error.message}`);
            return null;
        } finally {
            button.disabled = false;
            button.innerHTML = originalContent;
        }
    },

    /** Uses AI to generate a detailed prompt for a world map location. */
    async generateLocationPromptAI(event) {
        const state = StateManager.getState();
        const location = this.RUNTIME.selectedMapTile;
        if (!location) return;

        const newContent = await this._generateContentForField(event, state.prompt_location_gen, {
            name: location.name,
            description: location.description
        });
        
        if (newContent !== null) {
            this.updateLocationDetail('prompt', newContent);
            UIManager.renderWorldMapModal();
        }
    },

    /** Uses AI to generate content for a static knowledge entry. */
    async generateStaticEntryContentAI(event, entryId) {
        const state = StateManager.getState();
        const entry = state.static_entries.find(e => e.id === entryId);
        if (!entry) return;

        const newContent = await this._generateContentForField(event, state.prompt_entry_gen, {
            title: entry.title,
            triggers: '' // No triggers for static entries
        });

        if (newContent !== null) {
            this.updateStaticEntryField(entryId, 'content', newContent);
            UIManager.renderStaticEntryDetails();
        }
    },

    /** Uses AI to generate content for a dynamic knowledge entry. */
    async generateDynamicEntryContentAI(event, entryId) {
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === entryId);
        if (!entry) return;

        const newContent = await this._generateContentForField(event, state.prompt_entry_gen, {
            title: entry.title,
            triggers: entry.triggers
        });

        if (newContent !== null) {
            this.updateDynamicEntryField(entryId, 'content', newContent);
            UIManager.renderDynamicEntryDetails();
        }
    },

    /** Uses AI to analyze user input for emotion and location keywords. */
    async analyzeTurn(text) {
        const state = StateManager.getState();
        const locationNames = (state.worldMap?.grid || []).map(loc => loc.name);
        const locationList = locationNames.length > 0 ? `Valid locations are: [${locationNames.join(', ')}].` : 'No location data is available.';
        
        try {
            const prompt = `Analyze the text for sentiment and implied location. Respond with a valid JSON object like {"emotion": "...", "locationName": "..."}.
            - 'emotion' must be one of: neutral, happy, sad, angry, surprised.
            - 'locationName' must be one of the provided valid locations, or null if no specific location is mentioned or implied.
            ${locationList}
            TEXT: "${text}"`;
            
            const response = await APIService.callAI(prompt, true);
            const analysis = JSON.parse(response);

            const validEmotions = ['neutral', 'happy', 'sad', 'angry', 'surprised'];
            return {
                emotion: validEmotions.includes(analysis.emotion) ? analysis.emotion : 'neutral',
                locationName: locationNames.includes(analysis.locationName) ? analysis.locationName : null
            };
        } catch (error) {
            console.error("Sentiment/Location analysis failed:", error);
            return { emotion: 'neutral', locationName: null };
        }
    },
    
    /** Adds a new character to the roster. */
    addCharacter() { 
        const state = StateManager.getState();
        const aiCharCount = state.characters.filter(c => !c.is_user).length;
        const newColor = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
        const newChar = { 
            id: UTILITY.uuid(), name: "New Character", description: "", short_description: "A brief one-line summary.",
            model_instructions: "Act as {character}. Be descriptive and engaging.", image_url: "", extra_portraits: [], 
            tags: [], is_user: false, is_active: true, color: newColor, is_narrator: false
        };
        state.characters.push(newChar); 
        StateManager.saveState(); 
        UIManager.renderCharacters();
        this.openModal('character-detail-modal', newChar.id);
    },

    /** Deletes a character from the roster. */
	deleteCharacter(id) {
		UIManager.showConfirmationModal('Are you sure you want to delete this character?', () => {
			const state = StateManager.getState();
			state.characters = state.characters.filter(c => c.id !== id);
			this.closeModal('character-detail-modal');
			this.saveAndRender();
			
			DBService.deleteImage(id);

			// Also remove any emotion portraits for this character
			try {
				// Scan the cache keys directly since the character is already removed from the state
				Object.keys(UIManager.RUNTIME.characterImageCache || {}).forEach(k => {
					if (k.startsWith(`${id}::emotion::`)) {
						DBService.deleteImage(k).catch(() => {});
						URL.revokeObjectURL(UIManager.RUNTIME.characterImageCache[k]);
						delete UIManager.RUNTIME.characterImageCache[k];
					}
				});
			} catch (e) {
				console.warn('Could not clean emotion portraits for deleted character', e);
			}
		});
	},

    /** Updates a specific field of a character object (debounced). */
    updateCharacterField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === id); 
        if (char) { 
            char[field] = value; 
            StateManager.saveState(); 
            if (field === 'name') {
                UIManager.updateAICharacterSelector();
                const header = document.querySelector(`#character-detail-modal-content h2[data-char-id="${id}"]`);
                if(header) header.textContent = value;
            }
            if (field === 'name' || field === 'short_description' || field === 'image_url' || field === 'tags') {
                UIManager.renderCharacters();
            }
        } 
    }, 300),

/** Handles the upload of a local image for a world map location. */
    async handleWorldMapLocationImageUpload(event, x, y) {
      const file = event.target.files?.[0];
      if (!file) return;

      if (file.size > 5 * 1024 * 1024) { // 5MB Limit
        alert("Error: Image file size should not exceed 5MB.");
        event.target.value = '';
        return;
      }
      
      // Create a unique key for this specific tile
      const locationKey = `location::${x},${y}`;
      UIManager.showLoadingSpinner?.('Processing location image...');

      try {
        const blob = await ImageProcessor.processImageAsBlob(file);
        const saveSuccess = await DBService.saveImage(locationKey, blob);

        if (!saveSuccess) {
            throw new Error("Failed to save image to IndexedDB. This might be due to private browsing or storage limits.");
        }

        // Add to live cache
        UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
        const oldUrl = UIManager.RUNTIME.worldImageCache[locationKey];
        if (oldUrl) URL.revokeObjectURL(oldUrl);
        UIManager.RUNTIME.worldImageCache[locationKey] = URL.createObjectURL(blob);

        // Update the model to use the local key and clear the legacy URL
        const state = StateManager.getState();
        const locationInGrid = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        if (locationInGrid) {
            // Use a keyword to show it's local, not a real URL
            locationInGrid.imageUrl = `local_idb_location::${x},${y}`;
            StateManager.saveState();
        }

        // Refresh UI
        UIManager.renderWorldMapModal(); // Re-render modal to update hint
        UIManager.applyStyling(); // Apply new background if it's the current location

      } catch (err) {
        console.error("Error processing location image:", err);
        alert(`Upload failed: ${err.message}`);
      } finally {
        UIManager.hideLoadingSpinner?.();
        event.target.value = ''; // Clear file input
      }
    },

    /** Handles the upload of a local image for a character portrait. */
	async handleLocalImageUpload(event, charId) {
	  const file = event.target.files?.[0];
	  if (!file) return;

	  if (file.size > 5 * 1024 * 1024) {
		alert("Error: Image file size should not exceed 5MB.");
		event.target.value = '';
		return;
	  }

	  UIManager.showLoadingSpinner?.('Processing image...');
	  try {
		const blob = await ImageProcessor.processImageAsBlob(file);
		await DBService.saveImage(charId, blob);

		// Live-cache update (no reload)
		UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
		const oldUrl = UIManager.RUNTIME.characterImageCache[charId];
		if (oldUrl) URL.revokeObjectURL(oldUrl);
		UIManager.RUNTIME.characterImageCache[charId] = URL.createObjectURL(blob);

		// Normalize the model to IDB-backed (no external URL)
		this.updateCharacterField(charId, 'image_url', '');

		// Minimal, targeted repaints
		UIManager.renderCharacters?.();           // roster tiles
		const active = StateManager.getState?.();
		if (active?.lastSpeakerId) {
		  UIManager.updateSidePortrait?.();       // side portrait in horizontal mode
		}
		UIManager.refreshRecentMessages?.(10)     // if you have it
		  ?? UIManager.renderChat?.();            // otherwise a small full chat repaint

		// Optional UI text hint near the uploader
		const textInput = event.target.closest('div')?.querySelector('input[type="text"]');
		if (textInput) textInput.value = `[Image stored in browser]`;
	  } catch (err) {
		console.error("Error processing local image:", err);
		alert("There was an error processing the image.");
	  } finally {
		UIManager.hideLoadingSpinner?.();
	  }
	},
	
/** Handles the upload of a local image for an emotional portrait. */
    async handleLocalEmotionImageUpload(event, charId, index) {
      const file = event.target.files?.[0];
      if (!file) return;

      if (file.size > 5 * 1024 * 1024) {
        alert("Error: Image file size should not exceed 5MB.");
        event.target.value = '';
        return;
      }

      const state = StateManager.getState();
      const char = state.characters.find(c => c.id === charId);
      if (!char || !Array.isArray(char.extra_portraits) || !char.extra_portraits[index]) return;

      // Read the emotion from the model (source of truth)
      const emotion = (char.extra_portraits[index].emotion || 'neutral').toLowerCase();
      const emoKey = `${charId}::emotion::${emotion}`;

      UIManager.showLoadingSpinner?.('Processing emotion image...');
      try {
        const blob = await ImageProcessor.processImageAsBlob(file);
        await DBService.saveImage(emoKey, blob);

        // Live-cache update (no reload)
        UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
        const oldUrl = UIManager.RUNTIME.characterImageCache[emoKey];
        if (oldUrl) URL.revokeObjectURL(oldUrl);
        UIManager.RUNTIME.characterImageCache[emoKey] = URL.createObjectURL(blob);

        // Clear the URL (so getPortraitSrc prefers the local blob)
        char.extra_portraits[index].url = '';
        StateManager.saveState();

        // Targeted UI refresh so the new image shows up immediately
        const active = StateManager.getState();
        UIManager.renderCharacters?.();
        if (active?.lastSpeakerId) UIManager.updateSidePortrait?.();
        UIManager.refreshRecentMessages?.(10) ?? UIManager.renderChat?.();

        // Optional: hint in the nearby URL input box
        const textInput = event.target.closest('div')?.querySelector('input[type="text"]');
        if (textInput) textInput.value = `[Image stored in browser for "${emotion}"]`;
      } catch (err) {
        console.error("Error processing emotion image:", err);
        alert("There was an error processing the emotion image.");
      } finally {
        UIManager.hideLoadingSpinner?.();
      }
    },


    /** Updates a character's color scheme (debounced). */
    updateCharacterColor: debounce(function(charId, type, value) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (char) {
            if (!char.color || typeof char.color !== 'object') {
                char.color = { base: '#334155', bold: '#94a3b8' };
            }
            char.color[type] = value;
            StateManager.saveState();
            UIManager.renderChat();
        }
    }, 100),

    /** Updates a character's tags (debounced). */
    updateCharacterTags: debounce(function(id, value) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === id);
        if (char) {
            char.tags = value.split(',').map(t => t.trim()).filter(Boolean);
            StateManager.saveState();
            StateManager.updateTagCache();
        }
    }, 500),

    /** Uses AI to generate tags for a character based on their persona. */
    async generateTagsForCharacter(event, charId) {
        UIManager.showConfirmationModal("This will use AI to add to the current tags. Are you sure?", async () => {
            const state = StateManager.getState();
            const char = state.characters.find(c => c.id === charId);
            if (!char) return;

            const prompt = `Analyze the following character. Generate 3 to 5 relevant, one-word, comma-separated tags.\n\nCHARACTER: ${char.name}\nDESCRIPTION: ${char.description}`;
            const tagsString = await this._generateContentForField(event, prompt, {});
            
            if (tagsString !== null) {
                char.tags = (char.tags || []).concat(tagsString.split(',').map(t => t.trim().toLowerCase()));
                char.tags = [...new Set(char.tags)];
                StateManager.saveState();
                UIManager.openCharacterDetailModal(charId);
                StateManager.updateTagCache();
            }
        });
    },

    addExtraPortrait(charId) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char) { if(!char.extra_portraits) char.extra_portraits = []; char.extra_portraits.push({emotion: 'happy', url: ''}); StateManager.saveState(); UIManager.openCharacterDetailModal(charId); } },
    removeExtraPortrait(charId, index) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char && char.extra_portraits) { char.extra_portraits.splice(index, 1); StateManager.saveState(); UIManager.openCharacterDetailModal(charId); } },
    updateExtraPortrait: debounce(function(charId, index, field, value) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char && char.extra_portraits && char.extra_portraits[index]) { char.extra_portraits[index][field] = value; StateManager.saveState(); } }, 300),
    toggleCharacterActive(event, id) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === id); if (char) char.is_active = event.target.checked; StateManager.saveState(); UIManager.updateAICharacterSelector(); },
    
    addStaticEntry() { const state = StateManager.getState(); const newEntry = { id: UTILITY.uuid(), title: "New Static Entry", content: "" }; state.static_entries.push(newEntry); state.selectedStaticEntryId = newEntry.id; this.saveAndRenderStaticEntries(); },
    deleteStaticEntry(id) { const state = StateManager.getState(); state.static_entries = state.static_entries.filter(e => e.id !== id); if(state.selectedStaticEntryId === id) state.selectedStaticEntryId = null; this.saveAndRenderStaticEntries(); },
    selectStaticEntry(id) { StateManager.getState().selectedStaticEntryId = id; UIManager.renderStaticEntries(); },
    updateStaticEntryField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const entry = state.static_entries.find(e => e.id === id); 
        if (entry) { 
            entry[field] = value; 
            StateManager.saveState(); 
        } 
    }, 300),

    addDynamicEntry() { const state = StateManager.getState(); const newEntry = {id: UTILITY.uuid(), title: "New Dynamic Entry", triggers: "", content: "", triggered_at_turn: null }; state.dynamic_entries.push(newEntry); state.selectedDynamicEntryId = newEntry.id; this.saveAndRenderDynamicEntries(); },
    deleteDynamicEntry(id) { const state = StateManager.getState(); state.dynamic_entries = state.dynamic_entries.filter(e => e.id !== id); if(state.selectedDynamicEntryId === id) state.selectedDynamicEntryId = null; this.saveAndRenderDynamicEntries(); },
    selectDynamicEntry(id) { StateManager.getState().selectedDynamicEntryId = id; UIManager.renderDynamicEntries(); },
    updateDynamicEntryField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === id); 
        if (entry) { 
            entry[field] = value; 
            StateManager.saveState();
        } 
    }, 300),

    addExampleDialogueTurn() {
        const state = StateManager.getState();
        const firstAiChar = state.characters.find(c => !c.is_user);
        if (!firstAiChar) {
            alert("Cannot add example dialogue without at least one AI character.");
            return;
        }
        state.chat_history.push({ character_id: firstAiChar.id, content: "New example dialogue.", type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(), isHidden: true });
        StateManager.saveState();
        UIManager.renderExampleDialogueModal();
    },
    deleteExampleDialogueTurn(originalIndex) {
        const state = StateManager.getState();
        state.chat_history.splice(originalIndex, 1);
        StateManager.saveState();
        UIManager.renderExampleDialogueModal();
    },
    updateExampleDialogueTurn: debounce(function(originalIndex, field, value) {
        const state = StateManager.getState();
        if (state.chat_history[originalIndex]) {
            state.chat_history[originalIndex][field] = value;
            StateManager.saveState();
        }
    }, 300),
    moveExampleDialogueTurn(originalIndex, direction) {
        const state = StateManager.getState();
        const history = state.chat_history;
        const itemToMove = history[originalIndex];
        if (!itemToMove) return;

        let swapIndex = -1;
        if (direction === 'up') {
            for (let i = originalIndex - 1; i >= 0; i--) { if (history[i].isHidden) { swapIndex = i; break; } }
        } else {
            for (let i = originalIndex + 1; i < history.length; i++) { if (history[i].isHidden) { swapIndex = i; break; } }
        }

        if (swapIndex !== -1) {
            const temp = history[swapIndex];
            history[swapIndex] = itemToMove;
            history[originalIndex] = temp;
            StateManager.saveState();
            UIManager.renderExampleDialogueModal();
        }
    },

    openViewRawPromptModal() {
        if (!StateManager.getLibrary().active_narrative_id) { 
            alert("Please load a narrative first."); 
            return; 
        }
        
        let charToActId = document.getElementById('ai-character-selector').value;
        
        if (charToActId === 'any' || !charToActId) {
            console.log("View Raw Prompt: 'Any' selected, determining next speaker.");
            charToActId = this.determineNextSpeaker(false);
        }

        if (!charToActId) {
            alert("Could not determine an AI character to generate a prompt for. Please ensure at least one AI character is active.");
            return;
        }

        const prompt = PromptBuilder.buildPrompt(charToActId);
        document.getElementById('raw-prompt-content').textContent = prompt;
        this.openModal('view-raw-prompt-modal');
    },

    copyMessage(index) {
        const state = StateManager.getState();
        const message = state.chat_history[index];
        if (!message) return;
        
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = message.content;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        try {
            document.execCommand('copy');
            const copyBtn = document.querySelector(`[data-message-index='${index}'] .action-btn-group button[title='Copy']`);
            if (copyBtn) {
                const originalIcon = copyBtn.innerHTML;
                copyBtn.innerHTML = `<span class="text-xs text-green-400">Copied!</span>`;
                setTimeout(() => { copyBtn.innerHTML = originalIcon; }, 1500);
            }
        } catch (err) {
            console.error('Failed to copy text: ', err);
        }
        document.body.removeChild(tempTextarea);
    },
    
    deleteMessage(index) {
        UIManager.showConfirmationModal('Are you sure you want to permanently delete this message?', () => {
            const state = StateManager.getState();
            const messageToDelete = state.chat_history[index];
            if (messageToDelete && messageToDelete.type === 'chat') {
                state.messageCounter--;
            }
            state.chat_history.splice(index, 1);
            this.saveAndRender();
        });
    },

    stopGeneration() {
        if (this.RUNTIME.activeRequestAbortController) {
            this.RUNTIME.activeRequestAbortController.abort();
            console.log("Request aborted by user.");
        }
        
        const state = StateManager.getState();
        if (state.apiProvider === 'koboldcpp' && state.koboldcpp_url) {
            fetch(`${state.koboldcpp_url}/api/v1/generate/stop`, { method: 'POST' })
                .catch(err => console.error("Failed to send stop request to KoboldCPP:", err));
        }

        UIManager.hideTypingIndicator();
        UIManager.setButtonToSendMode();
        this.RUNTIME.activeRequestAbortController = null;
    },

    // --- World Map Functions ---
    async generateWorldMap(event) {
        UIManager.showConfirmationModal('This will overwrite the existing world map with an AI-generated one and may incur API costs. Are you sure?', async () => {
            const state = StateManager.getState();
            
            const context = {
                characters: state.characters.map(c => `${c.name}: ${c.short_description}`).join('\n'),
                static: (state.static_entries || []).map(e => `* ${e.title}: ${e.content}`).join('\n'),
                recent: (state.chat_history || []).filter(m => m.type === 'chat').slice(-3).map(m => m.content).join('\n---\n'),
            };

            const newGridData = await this._generateContentForField(event, state.prompt_world_map_gen, context, true);
            
            if (newGridData) {
                try {
                    const newWorld = JSON.parse(newGridData);
                    if (newWorld.grid && newWorld.grid.length > 0) {
                        newWorld.grid.forEach(loc => loc.local_static_entries = []);
                        state.worldMap.grid = newWorld.grid;
                        state.worldMap.currentLocation = { x: 4, y: 4 };
                        state.worldMap.destination = { x: null, y: null };
                        state.worldMap.path = [];
                        this.RUNTIME.selectedMapTile = null;
                        StateManager.saveState();
                        UIManager.renderWorldMapModal();
                        UIManager.applyStyling(); 
                    } else {
                        throw new Error("Generated data is not a valid grid.");
                    }
                } catch (e) {
                     console.error("World Map generation failed to parse JSON:", e);
                     alert("Failed to generate world map. The AI returned an invalid format.");
                }
            }
        });
    },

    moveToLocation(x, y) {
        const state = StateManager.getState();
        const targetLocation = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        if (targetLocation) {
            const previousLocationCoords = { ...state.worldMap.currentLocation };
            const turnOfDeparture = state.messageCounter;

            if (this.RUNTIME.turnOfArrival !== null && turnOfDeparture > this.RUNTIME.turnOfArrival) {
                 this.summarizeActivityForLocation(previousLocationCoords, this.RUNTIME.turnOfArrival);
            }

            state.worldMap.currentLocation = { x, y };
            this.RUNTIME.turnOfArrival = state.messageCounter;

            if (state.worldMap.destination && state.worldMap.destination.x !== null) {
                state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, state.worldMap.destination);
            } else {
                 state.worldMap.path = [];
            }
            
            this.addSystemMessageToHistory(`You have moved to ${targetLocation.name}.`);
            this.RUNTIME.selectedMapTile = null;
            this.RUNTIME.pendingMove = null;
            StateManager.saveState();
            UIManager.applyStyling();
            
            const narrator = state.characters.find(c => c.is_narrator && c.is_active);
            if (narrator) {
                this.triggerAIResponse(narrator.id, '', true);
            } else {
                this.triggerAIResponse(null, '', true);
            }
        }
    },

    async summarizeActivityForLocation(locationCoords, startTurn) {
        try {
            const state = StateManager.getState();
            const endTurn = state.messageCounter;
            
            const relevantHistory = state.chat_history.slice(startTurn, endTurn).filter(msg => msg.type === 'chat' && !msg.isHidden);

            if (relevantHistory.length === 0) {
                console.log("No new chat activity to summarize for location:", locationCoords);
                return;
            }

            const chatTranscript = relevantHistory.map(msg => {
                const char = state.characters.find(c => c.id === msg.character_id);
                return `${char ? char.name : 'Unknown'}: ${msg.content}`;
            }).join('\n');
            
            const prompt = state.prompt_location_memory_gen.replace('{transcript}', chatTranscript);
            const summaryContent = await APIService.callAI(prompt);

            const currentState = StateManager.getState();
            const location = currentState.worldMap.grid.find(loc => loc.coords.x === locationCoords.x && loc.coords.y === locationCoords.y);
            if (location) {
                if (!location.local_static_entries) {
                    location.local_static_entries = [];
                }
                const newEntry = {
                    id: UTILITY.uuid(),
                    title: `Events from turn ${startTurn} to ${endTurn}`,
                    content: summaryContent
                };
                location.local_static_entries.push(newEntry);
                StateManager.saveState();
                console.log("Location memory auto-generated for:", location.name);
            }
        } catch (error) {
            console.error("Failed to auto-generate location memory:", error);
        }
    },
    
    selectMapTile(x, y) {
        const state = StateManager.getState();
        const tile = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        this.RUNTIME.selectedMapTile = tile || null;
        this.RUNTIME.selectedLocalStaticEntryId = null;
        UIManager.renderWorldMapModal();
    },

    selectPendingMove(x, y) {
        this.RUNTIME.pendingMove = { x, y };
        UIManager.renderWorldMapModal();
    },

    confirmMove() {
        const state = StateManager.getState();
        const { pendingMove } = this.RUNTIME;
        const { currentLocation } = state.worldMap;

        if (pendingMove && (pendingMove.x !== currentLocation.x || pendingMove.y !== currentLocation.y)) {
            this.moveToLocation(pendingMove.x, pendingMove.y);
        }

        this.RUNTIME.pendingMove = null;
        this.closeModal('world-map-modal');
    },

    setDestination() {
        const state = StateManager.getState();
        const selected = this.RUNTIME.selectedMapTile;
        if (!selected) return;

        state.worldMap.destination = selected.coords;
        state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, selected.coords);
        StateManager.saveState();
        UIManager.renderWorldMapModal();
    },

    updateLocationDetail: debounce(function(field, value) {
        const state = StateManager.getState();
        const selected = this.RUNTIME.selectedMapTile;
        if (!selected) return;
        const locationInGrid = state.worldMap.grid.find(loc => loc.coords.x === selected.coords.x && loc.coords.y === selected.coords.y);
        if (locationInGrid) {
            locationInGrid[field] = value;
            StateManager.saveState();
        }
    }, 500),

    addLocalStaticEntry() {
        const location = this.RUNTIME.selectedMapTile;
        if (!location) return;
        if (!location.local_static_entries) location.local_static_entries = [];
        const newEntry = { id: UTILITY.uuid(), title: "New Local Entry", content: "" };
        location.local_static_entries.push(newEntry);
        this.RUNTIME.selectedLocalStaticEntryId = newEntry.id;
        StateManager.saveState();
        UIManager.renderLocalStaticEntriesList();
        UIManager.renderLocalStaticEntryDetails();
    },
    
    deleteLocalStaticEntry(entryId) {
        const location = this.RUNTIME.selectedMapTile;
        if (!location || !location.local_static_entries) return;
        location.local_static_entries = location.local_static_entries.filter(e => e.id !== entryId);
        if (this.RUNTIME.selectedLocalStaticEntryId === entryId) {
            this.RUNTIME.selectedLocalStaticEntryId = null;
        }
        StateManager.saveState();
        UIManager.renderLocalStaticEntriesList();
        UIManager.renderLocalStaticEntryDetails();
    },
    
    selectLocalStaticEntry(entryId) {
        this.RUNTIME.selectedLocalStaticEntryId = entryId;
        UIManager.renderLocalStaticEntriesList();
        UIManager.renderLocalStaticEntryDetails();
    },
    
    updateLocalStaticEntryField: debounce(function(entryId, field, value) {
        const location = this.RUNTIME.selectedMapTile;
        if (!location || !location.local_static_entries) return;
        const entry = location.local_static_entries.find(e => e.id === entryId);
        if (entry) {
            entry[field] = value;
            StateManager.saveState();
            if (field === 'title') {
                UIManager.renderLocalStaticEntriesList();
            }
        }
    }, 300),

    elevateNarrativeToScenario(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const narrative = story.narratives.find(n => n.id === narrativeId);
        if (!story || !narrative) return;
        
        const firstMessage = narrative.state.chat_history.find(m => !m.isHidden && m.type === 'chat');

        const newScenario = {
            id: UTILITY.uuid(),
            name: `${narrative.name} (Scenario)`,
            message: firstMessage ? firstMessage.content : "The story continues...",
            static_entries: JSON.parse(JSON.stringify(narrative.state.static_entries || [])),
            worldMap: JSON.parse(JSON.stringify(narrative.state.worldMap || {})),
        };

        story.scenarios.push(newScenario);
        StateManager.saveLibrary();
        UIManager.openStoryDetails(storyId);
    },
    
    // --- Import / Export ---

    /**
     * Handles a single file upload from the I/O Hub, routing it to the ImportExportService.
     * @param {Event} event - The file input change event.
     */
async handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        UIManager.showLoadingSpinner('Parsing file...');
		try {
			const { story: newStory, imageBlob } = await ImportExportService.parseUploadedFile(file);

			const library = StateManager.getLibrary();
            // Basic check if story name exists, handle potential duplicates
            const existingStory = library.stories.find(s => s.name && newStory.name && s.name.toLowerCase() === newStory.name.toLowerCase());
            if (existingStory) {
                const now = new Date();
				const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;                newStory.name = `${newStory.name} - ${timestamp}`;
                 console.log(`Duplicate story name found. Renaming imported story to: ${newStory.name}`);
            }

			library.stories.push(newStory);

			const primaryAiChar = newStory.characters?.find(c => !c.is_user);
			if (imageBlob && primaryAiChar && primaryAiChar.id) {
				const savedToDB = await DBService.saveImage(primaryAiChar.id, imageBlob);

                if (savedToDB) {
                    console.log(`Image saved to DB for ${primaryAiChar.id}, updating cache.`);
                    // Ensure cache exists
                    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
                    // Revoke old URL if replacing image for the same ID
                    const oldUrl = UIManager.RUNTIME.characterImageCache[primaryAiChar.id];
                    if (oldUrl) {
                        URL.revokeObjectURL(oldUrl);
                    }
                    // Add new blob URL to cache
                    UIManager.RUNTIME.characterImageCache[primaryAiChar.id] = URL.createObjectURL(imageBlob);
                } else {
                     console.warn(`Failed to save image to DB for ${primaryAiChar.id}, cache not updated.`);
                }
			}

			this.updateSearchIndex(newStory);
			StateManager.updateTagCache();
			StateManager.saveLibrary();
			UIManager.hideLoadingSpinner();
			alert(`Story "${newStory.name}" imported successfully!`);
			UIManager.renderLibraryInterface(); // Re-render library after potential rename/add
			this.closeModal('io-hub-modal');
        } catch (err) {
            UIManager.hideLoadingSpinner();
            alert(`Error importing file: ${err.message}`);
            console.error(err);
        } finally {
            event.target.value = ''; // Reset file input
        }
    },

    /**
     * Initiates the bulk import process by opening a directory picker.
     */
    async handleBulkImport() {
        if (!window.showDirectoryPicker) {
            alert("Your browser does not support directory selection. Please use a modern browser like Chrome or Edge.");
            return;
        }
        try {
            const dirHandle = await window.showDirectoryPicker();
            UIManager.showLoadingSpinner('Starting bulk import...');
            
            let processedFiles = 0;
            const failedFiles = [];
            const importedStoryNames = [];
            const library = StateManager.getLibrary();
            let totalSize = 0;

            const storageAvailable = UTILITY.checkLocalStorageQuota(totalSize);
            
		for await (const entry of dirHandle.values()) {
                // --- ADDED CHECKS ---
                if (entry.kind !== 'file' || typeof entry.name !== 'string' || !entry.name) {
                    // Skip if not a file, or if name isn't a non-empty string
                    console.warn("Skipping directory entry:", entry);
                    continue;
                }
                // --- END CHECKS ---

                // Now it's safe to use .toLowerCase()
                const lowerCaseName = entry.name.toLowerCase();

                if (lowerCaseName.endsWith('.png') || lowerCaseName.endsWith('.byaf') || lowerCaseName.endsWith('.zip')) {
                    UIManager.showLoadingSpinner(`Processing file ${++processedFiles}: ${entry.name}`);
                    let currentFileNameForError = entry.name; // Store name for potential error message
                    try {
                        const file = await entry.getFile();
                        if (!file || typeof file.name !== 'string' || !file.name) {
                             // Add a check for the File object itself, just in case
                            throw new Error("Could not retrieve a valid File object from the directory entry.");
                        }
                        currentFileNameForError = file.name; // Update with potentially more accurate name

                        const { story: newStory, imageBlob } = await ImportExportService.parseUploadedFile(file, !storageAvailable);

                        if (!newStory || typeof newStory.name !== 'string') {
                             // Check the result of parsing too
                             throw new Error("File parsed, but did not result in a valid story object with a name.");
                        }

                        // Check for existing story (uses newStory.name)
                        const existingStory = library.stories.find(s => s.name && s.name.toLowerCase() === newStory.name.toLowerCase());
                        if (existingStory) {
                            const now = new Date();
                            const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
                            newStory.name = `${newStory.name} - ${timestamp}`;
                        }

                        library.stories.push(newStory);

                        // --- IMAGE SAVING (Needs primary char ID) ---
                        const primaryAiChar = newStory.characters?.find(c => !c.is_user);
                        if (imageBlob && primaryAiChar && primaryAiChar.id) {
                            try {
                                // Use await here to ensure saving attempt before continuing loop potentially
                                const savedToDB = await DBService.saveImage(primaryAiChar.id, imageBlob);
								if (savedToDB) {
                                     console.log(`Bulk Import: Image saved to DB for ${primaryAiChar.id}, updating cache.`);
                                    // Ensure cache exists
                                    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
                                    // Revoke old URL if replacing image for the same ID (less likely in bulk import but good practice)
                                    const oldUrl = UIManager.RUNTIME.characterImageCache[primaryAiChar.id];
                                    if (oldUrl) {
                                        URL.revokeObjectURL(oldUrl);
                                    }
                                    // Add new blob URL to cache
                                    UIManager.RUNTIME.characterImageCache[primaryAiChar.id] = URL.createObjectURL(imageBlob);
                                } else {
                                     console.warn(`Bulk Import: Failed to save image to DB for ${primaryAiChar.id}, cache not updated.`);
                                }
                            } catch (dbSaveError) {
                                 console.warn(`Failed to save image to DB for ${primaryAiChar.id} (${newStory.name}) during bulk import:`, dbSaveError);
                                 // Continue import without the image
                            }
                        }
                         // --- END IMAGE SAVING ---

                        this.updateSearchIndex(newStory);
                        importedStoryNames.push(newStory.name);

                    } catch (err) {
                        // --- SAFER ERROR LOGGING ---
                        console.error(`Failed processing ${currentFileNameForError}:`, err);
                        // Ensure err.message exists, provide fallback
                        failedFiles.push({ name: currentFileNameForError, reason: (err && err.message) ? err.message : 'Unknown processing error' });
                        // --- END SAFER LOGGING ---
                    }
                }
            } // End for await loop

            StateManager.updateTagCache();
            StateManager.saveLibrary();
            UIManager.hideLoadingSpinner();
            UIManager.showBulkImportReport(importedStoryNames, failedFiles);
            UIManager.renderLibraryInterface();

        } catch (err) {
            UIManager.hideLoadingSpinner();
            console.error("Bulk import failed:", err);
            if (err.name !== 'AbortError') {
                alert(`An error occurred during bulk import: ${err.message}`);
            }
        }
    },

    /**
     * Handles the export process based on user selections in the I/O Hub.
     * @param {'json'|'png'|'byaf'} format - The desired export format.
     */
    async exportStoryAs(format) {
        const storySelector = document.getElementById('story-export-selector');
        const narrativeSelector = document.getElementById('narrative-export-selector');
        const storyId = storySelector.value;
        const narrativeId = narrativeSelector.value;

        if (!storyId || !narrativeId) {
            alert("Please select a story and a narrative to export.");
            return;
        }

        if (format !== 'json') {
            const proceed = await UIManager.showConfirmationPromise("Exporting to a non-Ellipsis format may result in data loss (e.g., extra characters, world map details). Continue?");
            if (!proceed) return;
        }

        UIManager.showLoadingSpinner(`Exporting as ${format.toUpperCase()}...`);
try {
            const library = StateManager.getLibrary();
            const story = library.stories.find(s => s.id === storyId);
            // Find narrative within the correct story object from the library
            const narrative = story?.narratives.find(n => n.id === narrativeId);
            // Get primary character if needed, also from the correct story object
            const charSelector = document.getElementById('character-export-selector');
            const primaryCharId = (format === 'png' || format === 'byaf') ? charSelector?.value : null;
            const primaryChar = primaryCharId ? story?.characters.find(c => c.id === primaryCharId) : null;


            if (!story || !narrative) {
                 throw new Error("Selected story or narrative not found.");
            }
             if ((format === 'png' || format === 'byaf') && !primaryChar) {
                 throw new Error("Primary character selection is required for PNG/BYAF export and was not found.");
             }


            let blob, filename;

            switch(format) {
                case 'json':
                    // This service function returns the Blob directly
                    blob = ImportExportService.exportStoryAsJSON(story);
                    filename = `${story.name || 'story'}.json`; // Use story name for JSON export
                    break;
                case 'png':
                    if (!primaryCharId) throw new Error("Please select a primary character for PNG export.");
                    // This service function returns a Promise<Blob>
                    blob = await ImportExportService.exportStoryAsV2(story, narrative, primaryCharId);
                    filename = `${story.name || 'story'}_${primaryChar?.name || 'character'}.png`;
                    break;
                case 'byaf':
                     if (!primaryCharId) throw new Error("Please select a primary character for BYAF export.");
                     // This service function returns a Promise<Blob>
                     blob = await ImportExportService.exportStoryAsBYAF(story, narrative, primaryCharId);
                     filename = `${story.name || 'story'}_${primaryChar?.name || 'character'}.byaf`;
                    break;
                default:
                    throw new Error("Unsupported export format.");
            }

            // Ensure blob is actually a Blob before proceeding
            if (!(blob instanceof Blob)) {
                console.error("Export function did not return a Blob:", blob);
                throw new Error(`Export process failed internally for format: ${format}. Expected a Blob.`);
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Sanitize filename (basic example, might need more robust sanitization)
            a.download = filename.replace(/[/\\?%*:|"<>]/g, '-');
            document.body.appendChild(a); // Append link to body for Firefox compatibility
            a.click();
            document.body.removeChild(a); // Clean up link
            URL.revokeObjectURL(url);

        } catch (e) {
            alert(`Export failed: ${e.message}`);
            console.error("Export error:", e);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    /**
     * Exports the entire story library as a single JSON file.
     */
    exportLibrary() {
        UIManager.showLoadingSpinner('Exporting library...');
        try {
            const data = JSON.stringify(StateManager.getLibrary(), null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ellipsis_library_backup_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        } catch (e) {
            alert(`Library export failed: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    /**
     * Imports and replaces the entire library from a JSON file.
     * @param {Event} event - The file input change event.
     */
    importLibrary(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            const proceed = await UIManager.showConfirmationPromise('WARNING: This will permanently replace your entire story library. This action cannot be undone. Are you sure?');
            if (proceed) {
                UIManager.showLoadingSpinner('Importing library...');
                try {
                    const importedLibrary = JSON.parse(e.target.result);
                    // Basic validation
                    if (!importedLibrary.stories || !importedLibrary.hasOwnProperty('active_story_id')) {
                        throw new Error("Invalid library file format.");
                    }
                    StateManager.data.library = importedLibrary;
                    StateManager.saveLibrary();
                    // Use a short delay to allow UI to update before reload
                    setTimeout(() => window.location.reload(), 500);
                } catch (err) { 
                    UIManager.hideLoadingSpinner();
                    alert(`Error importing library: ${err.message}`); 
                }
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset file input
    },

    // --- Helper & Utility Actions ---
    _ensureCharacterColors() {
        const state = StateManager.getState();
        if (!state || !state.characters) return;
        let aiCharCount = 0;
        state.characters.forEach(char => {
            if (!char.is_user) {
                 if (!char.color || typeof char.color !== 'object') { 
                    char.color = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
                 }
                aiCharCount++;
            }
        });
    },
    saveAndRender() { StateManager.saveState(); UIManager.renderAll(); },
    saveAndRenderStaticEntries() { StateManager.saveState(); UIManager.renderStaticEntries(); },
    saveAndRenderDynamicEntries() { StateManager.saveState(); UIManager.renderDynamicEntries(); },
};

/**
 * =================================================================================================
 * app Module (The Initializer)
 * =================================================================================================
 * This is the main entry point of the application. It initializes all the other modules
 * and sets up the initial event listeners.
 */
const app = {
  async init() {
    // Load data first (from localStorage as you already do)
    StateManager.loadLibrary();
    const library = StateManager.getLibrary();
    if (library.stories.length === 0) {
      Controller.createDefaultStoryAndNarrative();
      return;
    }
    StateManager.loadActiveNarrative();
    const state = StateManager.getState();

    // --- Make the UI responsive immediately (listeners + layout + send-button state) ---
    // Doing this early ensures you don't get stuck in vertical-only layout with dead buttons.
    this.setupEventListeners();            // calls updateLayout() internally on load and on resize
    UIManager.setButtonToSendMode();       // ensures the input button is in the correct mode

    // --- Try IndexedDB, but DO NOT let it block the UI ---
    let dbReady = false;
    try {
      await DBService.init();              // DBService is fail-soft; still guard with try/catch
      dbReady = true;
    } catch (e) {
      console.warn("DB init failed; proceeding without image cache", e);
    }

    // Always have a cache object—even if DB isn't ready
    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};

    // --- One-time image migration from legacy image_url/LocalStorage into IndexedDB ---
    // Define helpers locally so they don't leak globals.
    async function migrateLegacyImagesToIDB(root) {
      if (!root) return;

      // Accept either an active narrative with characters, or the full library
      const characters =
        root.characters ? root.characters :
        (root.stories && Array.isArray(root.stories))
          ? root.stories.flatMap(s => s.characters || [])
          : [];

      if (!characters || characters.length === 0) return;

      let changed = false;

      for (const char of characters) {
        try {
          // If there is already a blob in IDB for this char, skip
          const existing = await DBService.getImage(char.id);
          if (existing) continue;

          // If the character has a legacy inline/base64 or remote URL, try to fetch and store
          const url = (char.image_url || '').trim();
          if (!url) continue;

          const blob = url.startsWith('data:')
            ? dataURLToBlob(url)
            : await fetch(url, { cache: 'no-store' }).then(r => (r.ok ? r.blob() : null));

          if (blob) {
            // Save under the base key = char.id (keeps compatibility with your current hydrator)
            await DBService.saveImage(char.id, blob);

            // Normalize model to IDB-backed
            char.image_url = '';

            // Live-cache for immediate UI usage
            const oldUrl = UIManager.RUNTIME.characterImageCache[char.id];
            if (oldUrl) URL.revokeObjectURL(oldUrl);
            UIManager.RUNTIME.characterImageCache[char.id] = URL.createObjectURL(blob);

            changed = true;
          }
        } catch (e) {
          console.warn('Legacy image migration failed for char', char?.id, e);
          // leave image_url as-is; renderers will still fall back to it if present
        }
      }

      if (changed) {
        StateManager.saveLibrary?.();
        // Minimal repaint to reflect newly cached portraits
        UIManager.renderCharacters?.();
        const active = StateManager.getState?.();
        if (active?.lastSpeakerId) {
          UIManager.updateSidePortrait?.(active.lastSpeakerId);
        }
      }
    }

    function dataURLToBlob(dataUrl) {
      const [header, data] = dataUrl.split(',');
      const isBase64 = /;base64$/i.test(header);
      const mime = (header.match(/data:(.*?)(;|$)/) || [])[1] || 'application/octet-stream';
      const bytes = isBase64 ? atob(data) : decodeURIComponent(data);
      const arr = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
      return new Blob([arr], { type: mime });
    }

    // Run migration only if DB is ready
    if (dbReady) {
      try {
        await migrateLegacyImagesToIDB(
          StateManager.StateManager.getState() || StateManager.getLibrary?.()
        );
      } catch (e) {
        console.warn("Legacy image migration failed:", e);
      }
    }

    // --- Optional: hydrate character portraits from IndexedDB if available ---
    if (dbReady && state && state.characters) {
      for (const char of state.characters) {
        try {
          const blob = await DBService.getImage(char.id);
          if (blob) {
            UIManager.RUNTIME.characterImageCache[char.id] = URL.createObjectURL(blob);
          }
        } catch (e) {
          console.warn("getImage failed for", char.id, e);
        }
      }
    }
	
// Also hydrate emotion portraits into cache
    if (dbReady && state && state.characters) {
      for (const char of state.characters) {
        if (!Array.isArray(char.extra_portraits)) continue;
        for (const p of char.extra_portraits) {
          const emotion = (p.emotion || 'neutral').toLowerCase();
          const emoKey = `${char.id}::emotion::${emotion}`;
          try {
            const blob = await DBService.getImage(emoKey);
            if (blob) {
              UIManager.RUNTIME.characterImageCache[emoKey] = URL.createObjectURL(blob);
            }
          } catch (e) {
            console.warn("getImage failed for", emoKey, e);
          }
        }
      }
    }
	
// Hydrate global background image
    if (dbReady && state) { // Check if DB is ready and state is loaded
        let stateNeedsUpdate = false;
        try {
            const blob = await DBService.getImage('global_background_image');
            if (blob) {
                // Image FOUND in IDB
                console.log("Found local background image in IDB during init.");
                UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(blob);
                // Ensure state reflects reality
                if (state.backgroundImageURL !== 'local_idb_background') {
                    console.log("Correcting state: Setting backgroundImageURL to local_idb_background.");
                    state.backgroundImageURL = 'local_idb_background';
                    stateNeedsUpdate = true; // Mark state as changed
                }
            } else {
                // Image NOT found in IDB
                console.log("No local background image found in IDB during init.");
                // If state mistakenly thinks there's a local image, clear it
                if (state.backgroundImageURL === 'local_idb_background') {
                    console.log("Correcting state: Clearing backgroundImageURL because local image is missing.");
                    state.backgroundImageURL = '';
                    stateNeedsUpdate = true; // Mark state as changed
                }
                // Clear cache just in case
                UIManager.RUNTIME.globalBackgroundImageCache = null;
            }
        } catch (e) {
            console.warn("Failed during IDB background image check/load", e);
            // Fallback: If DB check fails, clear local flag if set, to avoid broken state
            if (state.backgroundImageURL === 'local_idb_background') {
                 state.backgroundImageURL = '';
                 stateNeedsUpdate = true;
            }
        }
        // Save state *only* if we made corrections during hydration
        if (stateNeedsUpdate) {
            console.log("Saving corrected state after background hydration.");
            StateManager.saveState();
        }
    }

// Hydrate world map location images
    if (dbReady && state && state.worldMap && state.worldMap.grid) {
      UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
      for (const loc of state.worldMap.grid) {
        // Only try to load images that are marked as local
        if (loc.imageUrl && loc.imageUrl.startsWith('local_idb_location')) {
          const locationKey = `location::${loc.coords.x},${loc.coords.y}`;
          try {
            const blob = await DBService.getImage(locationKey);
            if (blob) {
              UIManager.RUNTIME.worldImageCache[locationKey] = URL.createObjectURL(blob);
            } else {
              // Image missing from DB, correct the state
              console.warn(`Correcting missing location image for ${locationKey}`);
              loc.imageUrl = '';
              stateNeedsUpdate = true; // Mark for saving
            }
          } catch (e) {
            console.warn(`Failed to load location image ${locationKey} from IDB`, e);
          }
        }
      }
    }

    // --- Render the app regardless of DB status (your original logic, unchanged) ---
    if (!state || Object.keys(state).length === 0) {
      const activeStory = library.stories.find(s => s.id === library.active_story_id);
      document.getElementById('story-title-input').value = activeStory ? activeStory.name : "No Story Loaded";
      document.getElementById('mobile-story-title-overlay').value = activeStory ? activeStory.name : "No Story Loaded";
      UIManager.renderChat();
    } else {
      Controller.RUNTIME.turnOfArrival = state.messageCounter; // Initialize on load
      Controller._ensureCharacterColors();
      UIManager.applyStyling();
      UIManager.renderAll();
    }
  },

  /** Sets up all global and persistent event listeners for the application. */
  setupEventListeners() {
    this.updateLayout();
    window.addEventListener('resize', debounce(() => this.updateLayout(), 100));
        
        const titleInputHandler = debounce((e) => { 
            const state = StateManager.getState();
            if(state) {
                state.narrativeName = e.target.value;
                StateManager.saveState();
            }
        }, 500);

        document.getElementById('story-title-input').addEventListener('input', titleInputHandler);
        document.getElementById('mobile-story-title-overlay').addEventListener('input', titleInputHandler);

        const hamburgerBtn = document.getElementById('hamburger-menu-button');
        if (hamburgerBtn) { hamburgerBtn.addEventListener('click', (e) => { e.stopPropagation(); Controller.toggleMobileMenu(); }); }
        
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('mobile-menu');
            const btn = document.getElementById('hamburger-menu-button');
            if (menu && !menu.classList.contains('hidden') && !menu.contains(e.target) && !btn.contains(e.target)) { Controller.toggleMobileMenu(); }
        });
        
        const titleTrigger = document.getElementById('title-trigger-area');
        const mobileTitle = document.getElementById('mobile-story-title-overlay');
        const showTitle = () => { if(document.body.classList.contains('layout-vertical')) { clearTimeout(UIManager.RUNTIME.titleTimeout); mobileTitle.style.opacity = '1'; } };
        const hideTitle = (immediate = false) => { if(document.body.classList.contains('layout-vertical')) { clearTimeout(UIManager.RUNTIME.titleTimeout); if (document.activeElement !== mobileTitle) { if (immediate) { mobileTitle.style.opacity = '0'; } else { UIManager.RUNTIME.titleTimeout = setTimeout(() => { mobileTitle.style.opacity = '0'; }, 2500); } } } };
        
        titleTrigger.addEventListener('mouseenter', showTitle);
        titleTrigger.addEventListener('mouseleave', () => hideTitle());
        titleTrigger.addEventListener('touchstart', (e) => { e.preventDefault(); if (mobileTitle.style.opacity === '1') { hideTitle(true); } else { showTitle(); hideTitle(); } });
        
        document.getElementById('regen-btn').addEventListener('click', () => Controller.handleRegen());
        document.getElementById('undo-btn').addEventListener('click', () => Controller.undoLastTurn());
  },

  /** Updates the body class based on screen orientation for responsive styling. */
  updateLayout() {
    if (window.innerHeight > window.innerWidth) {
      document.body.classList.add('layout-vertical');
      document.body.classList.remove('layout-horizontal');
    } else {
      document.body.classList.add('layout-horizontal');
      document.body.classList.remove('layout-vertical');
    }
    UIManager.updateSidePortrait();
  },
};

// Start the application once the DOM is fully loaded.
document.addEventListener('DOMContentLoaded', () => app.init());



	</script>

    
</body>
</html>
