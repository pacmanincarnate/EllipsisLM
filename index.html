<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ellipsis LM</title>
    
    <!-- PWA and iOS Home Screen Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AI Storyteller">
    <link rel="apple-touch-icon" href="https://storage.googleapis.com/pai-images/22e56a81615f4e6691238e2124c6536b.png">

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;1,400&family=Dancing+Script:wght@400;700&family=EB+Garamond:ital,wght@0,400;1,400&family=Inter:wght@400;500;700&family=Lora:ital,wght@0,400;1,400&family=Nunito+Sans:ital,wght@0,400;1,400&family=Roboto+Slab:wght@400;700&family=Source+Code+Pro:ital,wght@0,400;1,400&display=swap" rel="stylesheet">

    <!-- Link to External Stylesheet -->
    <style>
			/* --- General Layout & Theme --- */
		:root {
			--font-primary: 'Inter', sans-serif;
			--text-primary: #e5e7eb;
			--text-secondary: #cbd5e1;
			--text-accent: #a5b4fc;
			
			--surface-glass: rgba(17, 24, 39, 0.15);
			--surface-card: rgba(55, 65, 81, 0.6);
			--surface-overlay: rgba(0, 0, 0, 0.4);
			
			--border-hue-color: rgba(75, 85, 99, 0.8); /* Default border color */
			--border-primary: var(--border-hue-color); /* Use the dynamic hue color */
			--brand-color: #6366f1; /* Indigo */
			--brand-color-toggle: #4f46e5;
			
			--scrollbar-thumb: #4b5563;
			
			--border-radius-md: 0.75rem;
			--border-radius-sm: 4px;
			
			--transition-fast: 0.2s ease-in-out;
			--transition-medium: 0.4s ease-out;
			--transition-slow: 0.5s ease-in-out;

			/* New Dynamic Variables */
			--chat-font-size: 16px;
			--bubble-image-size: 100px;
		}

		html, body {
			height: 100%;
			overflow: hidden;
		}

		body { 
			font-family: var(--font-primary); 
			color: var(--text-primary); 
		}

		.glass-bg { 
			background-color: var(--surface-glass); 
			/* The blur is now applied via inline style in ui.js */
		}

		/* --- Scrollbar Styling --- */
		::-webkit-scrollbar { width: 8px; }
		::-webkit-scrollbar-track { background: transparent; }
		::-webkit-scrollbar-thumb { 
			background: var(--scrollbar-thumb); 
			border-radius: var(--border-radius-sm); 
		}

		/* --- Component Styling --- */
		.character-card { 
			background-color: var(--surface-card); 
			backdrop-filter: blur(4px); 
			border: 1px solid var(--border-primary); 
			border-radius: var(--border-radius-md); 
		}

		.modal-overlay { 
			background-color: var(--surface-overlay); 
		}

		.toggle-bg:after { 
			content: ''; 
			position: absolute; 
			top: 0.125rem; 
			left: 0.125rem; 
			background-color: white; 
			border-radius: 9999px; 
			height: 1.25rem; 
			width: 1.25rem; 
			transition: transform var(--transition-fast); 
		}

		input:checked + .toggle-bg { 
			background-color: var(--brand-color-toggle); 
		}

		input:checked + .toggle-bg:after { 
			transform: translateX(100%); 
		}

		/* --- New Character Roster Button Styling --- */
		.char-roster-btn {
			position: relative;
			background-size: cover;
			background-position: center 25%; /* Focus on the upper part of the image */
			border-radius: 0.75rem;
			overflow: hidden;
			aspect-ratio: 3 / 4;
			transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
			border: 1px solid var(--border-primary);
			cursor: pointer;
		}
		.char-roster-btn:hover {
			transform: scale(1.03);
			box-shadow: 0 0 15px rgba(129, 140, 248, 0.4);
		}
		.char-roster-btn::after {
			content: '';
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			height: 70%;
			background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
			pointer-events: none;
		}
		.char-roster-content {
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			padding: 1rem;
			z-index: 10;
		}
		/* --- End New Character Roster Button Styling --- */


		/* --- Chat Components --- */
		#chat-window {
			display: flex;
			flex-direction: column;
			align-items: center;
		}
		#chat-window h1, 
		#chat-window h2, 
		#chat-window h3 { 
			font-weight: bold; 
			margin-bottom: 0.5rem; 
		}
		#chat-window h1 { font-size: 1.5em; } 
		#chat-window h2 { font-size: 1.25em; } 
		#chat-window h3 { font-size: 1.1em; }

		#chat-window blockquote {
			border-left: 3px solid var(--brand-color);
			padding-left: 1rem;
			margin: 0.5rem 0;
			color: var(--text-secondary);
			font-style: italic;
			font-weight: bold;
		}

		#chat-window em {
			color: var(--text-accent);
			font-style: italic;
		}

		.chat-bubble-container {
			width: 100%;
			max-width: 1200px;
		}

		.bubble-header {
			position: relative;
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 0.5rem 0.25rem; /* Increased padding */
		}

		.bubble-header .timestamp {
			position: absolute;
			left: 50%;
			transform: translateX(-50%);
		}

		.bubble-char-image {
			float: left;
			width: var(--bubble-image-size);
			height: auto;
			border-radius: 0.5rem;
			margin-right: 1rem;
			margin-bottom: 0.5rem;
		}

		.bubble-body .whitespace-pre-wrap {
			overflow: hidden; /* BFC to contain the float */
			white-space: normal;
			font-size: var(--chat-font-size);
		}
		.bubble-body .whitespace-pre-wrap p {
			margin: 0;
			white-space: normal;
		}
		.bubble-body .whitespace-pre-wrap p + p {
			margin-top: 0.75em;
		}


		/* --- Hover & Animation Effects --- */
		.chat-bubble-container:hover .action-btn-group,
		.chat-bubble-container:hover .timestamp { 
			opacity: 1; 
		}

		.action-btn-group, .timestamp { 
			opacity: 0; 
			transition: opacity var(--transition-fast);
		}

		#character-portrait-container img { 
			transition: opacity var(--transition-slow); 
		}

		@keyframes fadeIn {
			from { opacity: 0; transform: translateY(10px); }
			to { opacity: 1; transform: translateY(0); }
		}

		.chat-bubble-container.new-message {
			animation: fadeIn var(--transition-medium);
		}

		/* --- Cinematic Mode Enhancements --- */
		body[data-mode="cinematic_overlay"] #chat-window-container {
			height: 33.33vh;
			max-height: 33.33vh; /* ensure it doesn't grow */
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			margin-bottom: 0 !important;
			border-radius: 0;
			z-index: 20;
		}
		body[data-mode="cinematic_overlay"] #cinematic-overlay-bg {
			opacity: 1 !important;
			mask-image: none;
		}
		body[data-mode="cinematic_overlay"] #chat-window-container::before {
			content: '';
			position: absolute;
			top: -100px;
			left: 0;
			right: 0;
			height: 100px;
			background: linear-gradient(to bottom, transparent, rgba(0,0,0,0.3));
			pointer-events: none;
			z-index: 25;
		}


		/* --- Layout Management & Responsiveness --- */

		/* Horizontal (Desktop) Layout */
		body.layout-horizontal #app-container { padding: 0.5rem; }
		@media (min-width: 768px) { body.layout-horizontal #app-container { padding: 1.5rem; } }
		@media (min-width: 1024px) { body.layout-horizontal #app-container { padding: 2rem; } }
		body.layout-horizontal #chat-window-container { justify-content: space-between; }
		body.layout-horizontal #chat-window { width: 66.66%; }
		body.layout-horizontal #character-portrait-container { display: flex; width: 33.33%; }
		body.layout-horizontal #mobile-header-elements { display: none !important; }
		body.layout-horizontal .md\:hidden { display: none !important; }
		body.layout-horizontal .hidden.md\:flex { display: flex !important; }


		/* Vertical (Mobile) Layout */
		body.layout-vertical #app-container { padding: 0; }
		body.layout-vertical #main-header { position: fixed; top: 0; left: 0; right: 0; z-index: 50; margin: 0; padding: 0.5rem; background: transparent; pointer-events: none; }
		body.layout-vertical #hamburger-menu-button-container { opacity: 0.3; transition: opacity 0.3s ease; pointer-events: auto; }
		body.layout-vertical #hamburger-menu-button-container:hover { opacity: 1; }
		body.layout-vertical #mobile-story-title-overlay { position: fixed; top: 0; left: 0; width: 100%; z-index: 49; background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); padding: 1rem; text-align: center; opacity: 0; transition: opacity 0.3s ease; pointer-events: auto; }
		body.layout-vertical #chat-window-container { justify-content: center; border-radius: 0; margin-bottom: 0 !important; }
		body.layout-vertical #chat-window { width: 99%; }
		body.layout-vertical #character-portrait-container { display: none; }
		body.layout-vertical #chat-input-container { background-color: rgba(17, 24, 39, 0.7); backdrop-filter: blur(5px); padding: 1rem; border-top: 1px solid var(--border-primary); }
		body.layout-vertical .hidden.md\:flex { display: none !important; }
		body.layout-vertical .md\:hidden { display: flex !important; }

	</style>
</head>
<body data-mode="none" class="bg-gray-900 min-h-screen flex flex-col">
    
    <!-- This is where the main user interface will be inserted. -->
    <!-- PASTE content of main_ui.html HERE -->
	<!-- Background Image Container -->
<div id="global-background" class="fixed inset-0 -z-10 bg-gray-900 bg-cover bg-center transition-all duration-500"></div>

<!-- Main Application Container -->
<div class="w-full h-full flex flex-col glass-bg" id="app-container">
    
    <!-- Header -->
    <header class="mb-4 flex justify-between items-center" id="main-header">
        <!-- Desktop Header -->
        <div class="hidden md:flex justify-between items-center w-full">
            <input type="text" id="story-title-input" class="text-2xl font-bold bg-transparent text-white p-1 rounded focus:outline-none focus:bg-black/20 w-1/2">
            <div class="flex space-x-2">
                 <button onclick="Controller.openModal('story-library-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Story Library"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path><path d="M4 6h16M4 12h16M4 18h7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M18 18v-6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M15 12h6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button>
                 <button onclick="Controller.openModal('characters-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Characters"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21a6 6 0 00-9-5.197m0 0A5.965 5.965 0 0112 13a5.965 5.965 0 013 1.803"></path></svg></button>
                 <button onclick="Controller.openModal('world-map-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="World Map"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 9m-6 4v.01"></path></svg></button>
                 <button onclick="Controller.openModal('knowledge-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Knowledge"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253z"></path></svg></button>
                 <button onclick="Controller.openModal('settings-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Settings"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg></button>
            </div>
        </div>

        <!-- Mobile Header -->
        <div class="md:hidden flex justify-end items-center w-full">
            <div class="relative" id="hamburger-menu-button-container">
                <button id="hamburger-menu-button" class="bg-gray-700/80 hover:bg-gray-600/80 text-white p-2 rounded-lg">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
                <div id="mobile-menu" class="hidden absolute right-0 mt-2 w-56 bg-gray-800/90 backdrop-blur-md rounded-lg shadow-xl z-50">
                    <a href="#" onclick="Controller.openModal('story-library-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Story Library</a>
                    <a href="#" onclick="Controller.openModal('characters-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Characters</a>
                    <a href="#" onclick="Controller.openModal('world-map-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">World Map</a>
                    <a href="#" onclick="Controller.openModal('knowledge-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Knowledge</a>
                    <a href="#" onclick="Controller.checkWorldInfoAgent(); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Update Static</a>
                    <div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Settings</div>
                    <a href="#" onclick="Controller.openSettingsToTab('appearance'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Appearance</a>
                    <a href="#" onclick="Controller.openSettingsToTab('prompt'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Prompt</a>
                    <a href="#" onclick="Controller.openSettingsToTab('model'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Model</a>
                </div>
            </div>
        </div>
    </header>
    <!-- /Header -->

    <div id="mobile-header-elements">
         <input type="text" id="mobile-story-title-overlay" class="text-xl font-bold text-white truncate text-center bg-transparent focus:bg-black/20 w-full">
    </div>

    <!-- Main Content Area -->
    <main class="flex-grow min-h-0 flex flex-col relative">
        <div id="title-trigger-area" class="absolute top-0 left-0 w-full h-1/4 z-40"></div>
         <!-- Chat Window & Portrait -->
         <div id="chat-window-container" class="relative flex-grow flex min-h-0 mb-4 bg-black/30 rounded-lg overflow-hidden">
            <div id="cinematic-overlay-bg" class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 opacity-20 pointer-events-none" style="mask-image: radial-gradient(circle at center, black 40%, transparent 80%);"></div>
            <div id="chat-window" class="relative z-10 flex-grow p-4 overflow-y-auto"></div>
            <div id="character-portrait-container" class="flex-shrink-0 pl-4 flex-col justify-center items-center"></div>
         </div>
         <!-- /Chat Window & Portrait -->
         
         <!-- Chat Input & Controls -->
         <div id="chat-input-container" class="flex items-start space-x-2 sm:space-x-4">
             <textarea id="chat-input" class="flex-grow bg-black/30 border border-gray-600 rounded-lg p-2 resize-none" placeholder="Enter your message..." rows="4"></textarea>
             <div class="flex flex-col space-y-2">
                 <select id="ai-character-selector" class="bg-black/30 border border-gray-600 rounded-lg p-2 w-full mb-2"></select>
                 <div class="flex items-center justify-center space-x-1">
                     <button id="primary-action-btn" class="bg-indigo-600/50 hover:bg-indigo-600/80 text-white font-bold p-1.5 rounded-lg" title="Send / Write for Me"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></button>
                     <button id="regen-btn" class="bg-sky-600/40 hover:bg-sky-600/70 text-white font-bold p-1.5 rounded-lg" title="Regenerate / New Response"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 9a9 9 0 0114.65-5.32L20 5M20 15a9 9 0 01-14.65 5.32L4 19"></path></svg></button>
                     <button id="undo-btn" class="bg-gray-600/40 hover:bg-gray-500/70 text-white font-bold p-1.5 rounded-lg" title="Undo"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l4-4m-4 4l4 4"></path></svg></button>
                 </div>
             </div>
         </div>
         <!-- /Chat Input & Controls -->
    </main>
    <!-- /Main Content Area -->

</div>
<!-- /Main Application Container -->


    
    <!-- This is where all the modal dialogs and templates will be inserted. -->
    <!-- PASTE content of modals.html HERE -->
	<!-- Modals -->
<!-- Story Library Modal -->
<div id="story-library-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('story-library-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700 flex justify-between items-center"><h2 class="text-2xl font-semibold">Story Library</h2><button onclick="Controller.createNewStory()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">New Story</button></div><div id="library-content-container" class="flex-grow flex min-h-0"></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-between items-center flex-wrap gap-4"><div class="flex items-center space-x-2"><span class="font-bold text-gray-400">Import:</span><button onclick="Controller.importBYAF()" class="bg-teal-600/80 hover:bg-teal-700/80 font-bold py-2 px-4 rounded-lg">BYAF</button><button onclick="document.getElementById('import-story-file').click()" class="bg-blue-600/80 hover:bg-blue-700/80 font-bold py-2 px-4 rounded-lg">Story</button><input type="file" id="import-story-file" class="hidden" accept=".json" onchange="Controller.importStory(event)"><button onclick="document.getElementById('import-library-file').click()" class="bg-cyan-600/80 hover:bg-cyan-700/80 font-bold py-2 px-4 rounded-lg">Library</button><input type="file" id="import-library-file" class="hidden" accept=".json" onchange="Controller.importLibrary(event)"></div><div class="flex items-center space-x-2"><span class="font-bold text-gray-400">Export:</span><button onclick="Controller.exportLibrary()" class="bg-emerald-600/80 hover:bg-emerald-700/80 font-bold py-2 px-4 rounded-lg">Library</button></div><button onclick="Controller.closeModal('story-library-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button></div></div></div>

<!-- Story Details Modal (for mobile view) -->
<div id="story-details-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('story-details-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[90vh]"><div id="story-details-content-mobile" class="flex-grow flex flex-col min-h-0"></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('story-details-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Back to Library</button></div></div></div>

<!-- Characters Modal -->
<div id="characters-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('characters-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700 flex justify-between items-center"><h2 class="text-2xl font-semibold">Character Roster</h2><button onclick="Controller.addCharacter()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Character</button></div><div class="p-6 overflow-y-auto"><div id="characters-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('characters-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Individual Character Detail Modal -->
<div id="character-detail-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('character-detail-modal')"></div>
    <div id="character-detail-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[90vh]">
        <!-- Content will be injected by JS -->
    </div>
</div>

<!-- Knowledge Modal (Static & Dynamic) -->
<div id="knowledge-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('knowledge-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 pb-0 flex justify-between items-center border-b border-gray-700"><div class="flex"><button id="knowledge-tab-static" onclick="Controller.switchKnowledgeTab('static')" class="py-3 px-4 font-semibold text-lg border-b-2 border-indigo-500 text-white">Static</button><button id="knowledge-tab-dynamic" onclick="Controller.switchKnowledgeTab('dynamic')" class="py-3 px-4 font-semibold text-lg border-b-2 border-transparent text-gray-400 hover:text-white">Dynamic</button></div><button id="knowledge-add-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg ml-4 flex-shrink-0">Add Entry</button></div><div class="p-6 overflow-y-auto flex-grow"><div id="knowledge-static-content"><div id="static-entries-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full"><div id="static-entries-list" class="md:col-span-1 bg-black/30 rounded-lg p-4 overflow-y-auto"></div><div id="static-entry-details" class="md:col-span-2 bg-black/30 rounded-lg p-4"><div id="static-entry-details-content" class="h-full"><div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div></div></div></div></div><div id="knowledge-dynamic-content" class="hidden"><div id="dynamic-entries-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full"><div id="dynamic-entries-list" class="md:col-span-1 bg-black/30 rounded-lg p-4 overflow-y-auto"></div><div id="dynamic-entry-details" class="md:col-span-2 bg-black/30 rounded-lg p-4"><div id="dynamic-entry-details-content" class="h-full"><div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div></div></div></div></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('knowledge-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>
    
<!-- World Map Modal -->
<div id="world-map-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('world-map-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh]">
        <div id="world-map-modal-content" class="flex-grow flex flex-col min-h-0">
            <!-- Content will be injected by JS -->
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div id="settings-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('settings-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[90vh]"><div class="p-6 pb-0 border-b border-gray-700"><h2 class="text-2xl font-semibold mb-4">Settings</h2><div class="flex -mb-px"><button id="settings-tab-appearance" onclick="Controller.switchSettingsTab('appearance')" class="py-2 px-4 font-semibold border-b-2 border-indigo-500 text-white">Appearance</button><button id="settings-tab-prompt" onclick="Controller.switchSettingsTab('prompt')" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white">Prompt</button><button id="settings-tab-model" onclick="Controller.switchSettingsTab('model')" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white">Model</button></div></div><div class="p-6 overflow-y-auto flex-grow" id="settings-content-container">...</div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('settings-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Edit Response Modal -->
<div id="edit-response-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('edit-response-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[75vh]">
        <div class="p-6 border-b border-gray-700 flex-shrink-0">
            <h3 class="text-xl font-bold">Edit Response</h3>
        </div>
        <div class="p-6 overflow-y-auto">
            <textarea id="edit-modal-input" class="w-full bg-gray-900 border-gray-700 rounded-lg p-2 resize-none"></textarea>
        </div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4 flex-shrink-0">
            <button onclick="Controller.closeModal('edit-response-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button>
            <button id="edit-modal-save-button" class="bg-indigo-600 hover:bg-indigo-700 font-bold py-2 px-4 rounded-lg">Save</button>
        </div>
    </div>
</div>

<!-- View Raw Prompt Modal -->
<div id="view-raw-prompt-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('view-raw-prompt-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Raw Prompt</h2></div><div class="p-6 overflow-y-auto flex-grow bg-gray-900"><pre id="raw-prompt-content" class="text-sm whitespace-pre-wrap"></pre></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('view-raw-prompt-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Example Dialogue Modal -->
<div id="example-dialogue-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('example-dialogue-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]">
        <div class="p-6 border-b border-gray-700 flex justify-between items-center">
            <h2 class="text-2xl font-semibold">Edit Example Dialogue</h2>
            <button onclick="Controller.addExampleDialogueTurn()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Turn</button>
        </div>
        <div id="example-dialogue-container" class="p-6 overflow-y-auto flex-grow space-y-4">
            <!-- Dialogue turns will be rendered here by JavaScript -->
        </div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
            <button onclick="Controller.closeModal('example-dialogue-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
        </div>
    </div>
</div>
<!-- /Modals -->

<!-- Hidden template for settings tabs -->
<div id="settings-templates" class="hidden">
    <div id="settings-appearance-content" class="space-y-6">
        <div>
            <div class="grid grid-cols-2 gap-4">
                <div><label for="font-selector" class="text-gray-400 text-sm block mb-2">Chat Font</label><select id="font-selector" class="w-full bg-black/30 border-gray-600 rounded-lg p-2"><option value="'Inter', sans-serif">Inter</option><option value="'Nunito Sans', sans-serif">Nunito Sans</option><option value="'Lora', serif">Lora</option><option value="'Roboto Slab', serif">Roboto Slab</option><option value="'EB Garamond', serif">EB Garamond</option><option value="'Cormorant Garamond', serif">Cormorant Garamond</option><option value="'Source Code Pro', monospace">Source Code Pro</option><option value="'Dancing Script', cursive">Dancing Script</option></select></div>
                <div><label for="chat-text-color" class="text-gray-400 text-sm block mb-2">Chat Text Color</label><input type="color" id="chat-text-color" class="w-full bg-black/30 border-gray-600 rounded-lg p-1 h-10"></div>
            </div>
            <label for="background-image-url" class="text-gray-400 text-sm block mt-4 mb-2">Background Image URL</label><input type="text" id="background-image-url" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="https://example.com/image.png">
            <label for="bubble-opacity-slider" class="text-gray-400 text-sm block mt-4 mb-2">Chat Bubble Opacity</label><div class="flex items-center space-x-4"><input type="range" id="bubble-opacity-slider" class="w-full" min="0" max="1" step="0.05"><span id="bubble-opacity-value" class="text-sm text-gray-400 w-12 text-right"></span></div>
            <label for="blur-slider" class="text-gray-400 text-sm block mt-4 mb-2">Background Blur (px)</label><div class="flex items-center space-x-4"><input type="range" id="blur-slider" class="w-full" min="0" max="20" step="1"><span id="blur-value" class="text-sm text-gray-400 w-12 text-right"></span></div>
            <label for="text-size-slider" class="text-gray-400 text-sm block mt-4 mb-2">Text Size (px)</label><div class="flex items-center space-x-4"><input type="range" id="text-size-slider" class="w-full" min="12" max="24" step="1"><span id="text-size-value" class="text-sm text-gray-400 w-12 text-right"></span></div>
            <label for="bubble-image-size-slider" class="text-gray-400 text-sm block mt-4 mb-2">Bubble Image Size (px)</label><div class="flex items-center space-x-4"><input type="range" id="bubble-image-size-slider" class="w-full" min="50" max="150" step="5"><span id="bubble-image-size-value" class="text-sm text-gray-400 w-12 text-right"></span></div>
            <label class="text-gray-400 text-sm block mt-4 mb-2">Character Image Display</label><div class="flex space-x-4" id="character-image-display"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="none" checked><span>None</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="cinematic_overlay"><span>Cinematic</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="bubble"><span>Bubble</span></label></div>
        </div>
    </div>
    <div id="settings-prompt-content" class="space-y-6">
        <div><h3 class="text-lg font-medium mb-2">System Prompt (Global Fallback)</h3><p class="text-gray-400 text-sm mb-2">Used by AI characters who don't have their own specific instructions.</p><textarea id="system-prompt-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2 resize-y" rows="4"></textarea></div><hr class="border-gray-700"><div><h3 class="text-lg font-medium mb-2">Event Master Prompt</h3><p class="text-gray-400 text-sm mb-2">Define the base instruction for the Event Master, which injects surprise events.</p><textarea id="event-master-prompt-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2 resize-y" rows="4"></textarea></div><hr class="border-gray-700"><div class="flex space-x-2"><button onclick="Controller.openViewRawPromptModal()" class="bg-gray-600/80 hover:bg-gray-500/80 text-white font-bold py-2 px-4 rounded-lg">View Raw Prompt</button><button onclick="Controller.openModal('example-dialogue-modal')" class="bg-sky-600/80 hover:bg-sky-500/80 text-white font-bold py-2 px-4 rounded-lg">Edit Example Dialogue</button></div>
    </div>
    <div id="settings-model-content" class="space-y-6">
        <div><h3 class="text-lg font-medium mb-2">AI Provider</h3><div class="flex space-x-4"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="gemini" onchange="Controller.setApiProvider('gemini')"><span>Gemini</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="openrouter" onchange="Controller.setApiProvider('openrouter')"><span>OpenRouter</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="koboldcpp" onchange="Controller.setApiProvider('koboldcpp')"><span>KoboldCPP</span></label></div></div><div id="gemini-settings"><h3 class="text-lg font-medium">Gemini API Settings</h3><p class="text-gray-400 text-sm mb-2">Required for text generation.</p><input type="password" id="gemini-api-key-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="Enter Gemini API key"></div><div id="openrouter-settings"><h3 class="text-lg font-medium">OpenRouter API Settings</h3><p class="text-gray-400 text-sm mb-2">Your key and the model name.</p><input type="password" id="openrouter-api-key-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="Enter OpenRouter API key"><input type="text" id="openrouter-model-input" class="mt-2 w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="Enter model name"></div><div id="koboldcpp-settings"><h3 class="text-lg font-medium">KoboldCPP Settings</h3><p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure your local server is running with the <strong>--cors</strong> flag.</p><div><label for="koboldcpp-template-selector" class="text-gray-400 text-sm block mb-2">Prompt Template</label><select id="koboldcpp-template-selector" class="w-full bg-black/30 border-gray-600 rounded-lg p-2"><option value="none">None (Raw Text)</option><option value="mistral">Mistral</option><option value="chatml">ChatML</option><option value="alpaca">Alpaca</option></select></div><div><label for="koboldcpp-min-p-slider" class="text-gray-400 text-sm block mt-4 mb-2">Min P</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-min-p-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-min-p-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div><div><label for="koboldcpp-dry-slider" class="text-gray-400 text-sm block mt-4 mb-2">DRY (Repetition Penalty)</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-dry-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-dry-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div></div>
    </div>
</div>



    <!-- Application Logic - The order of these scripts is important! -->
    <script>
	// Utility function to prevent a function from being called too frequently.
const debounce = (func, wait) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; };

/**
 * =================================================================================================
 * StateManager Module
 * =================================================================================================
 * This module is the single source of truth for all application data.
 * It handles loading from and saving to localStorage, and provides controlled access
 * to the library and the active narrative state. All data mutations should happen
 * through this manager's methods to ensure consistency.
 */
const StateManager = {
    // Private data store. Should not be accessed directly from outside this module.
    data: {
        library: {
            active_story_id: null,
            active_narrative_id: null,
            stories: [],
            tag_cache: []
        },
        // This holds the state of the *currently active* narrative.
        // It's a combination of story-level settings and narrative-specific data.
        activeNarrativeState: {},
    },

    CONSTANTS: {
        LIBRARY_KEY: 'aiStorytellerLibrary',
    },

    // --- Public Getters ---
    // Provide read-only access to the state from other parts of the application.
    
    /** @returns {object} The active narrative state object. */
    getState() {
        return this.data.activeNarrativeState;
    },

    /** @returns {object} The entire story library object. */
    getLibrary() {
        return this.data.library;
    },

    // --- State Initialization and Persistence ---
    
    /**
     * Loads the entire story library from localStorage into the state manager.
     * Performs data migration for older story formats to ensure compatibility.
     * This is the first step in the application's data lifecycle.
     */
    loadLibrary() {
        const savedLibraryJSON = localStorage.getItem(this.CONSTANTS.LIBRARY_KEY);
        if (savedLibraryJSON) {
            try {
                let parsedLibrary = JSON.parse(savedLibraryJSON);

                // Define default settings for migration purposes using the new UTILITY module.
                const defaults = {
                    ...UTILITY.getDefaultApiSettings(),
                    ...UTILITY.getDefaultUiSettings(),
                    ...UTILITY.getDefaultSystemPrompts(),
                };

                // Migrate each story to the latest format, adding new fields if they don't exist.
                parsedLibrary.stories = (parsedLibrary.stories || []).map(story => {
                    const newStory = { ...defaults, ...story };

                    // Character-level migration to add new description and instruction fields.
                    if (newStory.characters) {
                        newStory.characters = newStory.characters.map(char => {
                            const newChar = { ...char };
                            if (typeof char.short_description === 'undefined') {
                                newChar.short_description = char.is_user ? "The main character." : "A brief summary of the character.";
                            }
                            if (typeof char.model_instructions === 'undefined') {
                                if (char.is_user) {
                                    newChar.model_instructions = "Write a response for {character} in a creative and descriptive style.";
                                } else {
                                    newChar.model_instructions = newStory.system_prompt || "Act as {character}. Be descriptive and engaging.";
                                }
                            }
                            return newChar;
                        });
                    }
                    return newStory;
                });
                
                this.data.library = parsedLibrary;
                // Ensure essential library properties exist.
                if (!this.data.library.tag_cache) this.data.library.tag_cache = [];
                if (!this.data.library.active_narrative_id) this.data.library.active_narrative_id = null;

            } catch (error) {
                console.error("Failed to parse library from localStorage.", error);
                // Reset to a clean slate if parsing fails.
                this.data.library = { active_story_id: null, active_narrative_id: null, stories: [], tag_cache: [] };
            }
        } else {
             // Initialize with a clean slate if no library is found.
            this.data.library = { active_story_id: null, active_narrative_id: null, stories: [], tag_cache: [] };
        }
    },
    
    /**
     * Persists the current state of the entire library to localStorage.
     * This should be called after any significant data mutation.
     */
    saveLibrary() {
        localStorage.setItem(this.CONSTANTS.LIBRARY_KEY, JSON.stringify(this.data.library));
    },
    
    /**
     * Loads the currently active narrative (identified by active_story_id and
     * active_narrative_id in the library) into the `activeNarrativeState`.
     * This combines story-level settings with narrative-specific data like chat history.
     */
    loadActiveNarrative() {
        const { active_story_id, active_narrative_id, stories } = this.data.library;
        
        if (!active_story_id || !active_narrative_id) {
            this.data.activeNarrativeState = {};
            return;
        }
        
        const activeStory = stories.find(s => s.id === active_story_id);
        if (!activeStory) {
            this.data.activeNarrativeState = {};
            return;
        }
        
        const activeNarrative = (activeStory.narratives || []).find(n => n.id === active_narrative_id);
        if (activeNarrative) {
            // Combine story-level settings with narrative-specific data.
            // This creates a single, unified state object for the active session.
            const storySettings = { ...activeStory };
            delete storySettings.narratives; // Avoid duplicating data
            delete storySettings.scenarios;
            
            this.data.activeNarrativeState = {
                ...storySettings, // Story-level settings (characters, prompts, etc.)
                ...activeNarrative.state, // Narrative-specific data (chat history, etc.)
                narrativeName: activeNarrative.name // Add narrative name for display
            };

        } else {
            this.data.activeNarrativeState = {};
        }
    },

    /**
     * Saves the current `activeNarrativeState` back into its corresponding
     * narrative and story objects within the main library, then persists the library.
     * This is the primary method for saving progress.
     */
    saveState() {
        const { active_story_id, active_narrative_id, stories } = this.data.library;
        const currentState = this.data.activeNarrativeState;

        if (!active_story_id || !active_narrative_id || !currentState) {
            console.warn("Attempted to save state without an active story/narrative.");
            return;
        }
        
        const activeStory = stories.find(s => s.id === active_story_id);
        if (activeStory) {
            const narrativeIndex = (activeStory.narratives || []).findIndex(n => n.id === active_narrative_id);
            if (narrativeIndex !== -1) {
                // 1. Isolate the parts of the state that are specific to this narrative.
                const narrativeState = {
                    chat_history: currentState.chat_history,
                    messageCounter: currentState.messageCounter,
                    static_entries: currentState.static_entries,
                    worldMap: currentState.worldMap
                };
                
                // 2. Update the narrative object in the library.
                activeStory.narratives[narrativeIndex].state = narrativeState;
                activeStory.narratives[narrativeIndex].last_modified = new Date().toISOString();
                
                // 3. Save shared settings from the active state back to the story object.
                activeStory.characters = currentState.characters;
                activeStory.dynamic_entries = currentState.dynamic_entries;
                activeStory.font = currentState.font;
                activeStory.backgroundImageURL = currentState.backgroundImageURL;
                activeStory.bubbleOpacity = currentState.bubbleOpacity;
                activeStory.chatTextColor = currentState.chatTextColor;
                activeStory.characterImageMode = currentState.characterImageMode;
                
                // Save new appearance settings
                activeStory.backgroundBlur = currentState.backgroundBlur;
                activeStory.textSize = currentState.textSize;
                activeStory.bubbleImageSize = currentState.bubbleImageSize;
                
                activeStory.system_prompt = currentState.system_prompt;
                activeStory.event_master_base_prompt = currentState.event_master_base_prompt;
                activeStory.event_master_prompt = currentState.event_master_prompt;
                activeStory.apiProvider = currentState.apiProvider;
                activeStory.geminiApiKey = currentState.geminiApiKey;
                activeStory.openRouterKey = currentState.openRouterKey;
                activeStory.openRouterModel = currentState.openRouterModel;
                activeStory.koboldcpp_template = currentState.koboldcpp_template;
                activeStory.koboldcpp_min_p = currentState.koboldcpp_min_p;
                activeStory.koboldcpp_dry = currentState.koboldcpp_dry;

                // 4. Update story metadata and persist the entire library.
                activeStory.last_modified = new Date().toISOString();
                this.saveLibrary();
            }
        }
    },

    /**
     * Scans all stories and characters to build a unique, sorted list of all tags.
     * Caches this list in the library for quick access (e.g., in filter dropdowns).
     */
    updateTagCache() {
        const allTags = new Set();
        this.data.library.stories.forEach(story => {
            if (story.tags) story.tags.forEach(tag => allTags.add(tag));
            if (story.characters) {
                story.characters.forEach(char => {
                    if (char.tags) char.tags.forEach(tag => allTags.add(tag));
                });
            }
        });
        this.data.library.tag_cache = Array.from(allTags).sort();
        this.saveLibrary(); // Persist the updated cache
    },
};

/**
 * =================================================================================================
 * APIService Module
 * =================================================================================================
 */
const APIService = {
    async callAI(prompt, isJson = false) {
        const state = StateManager.getState();
        let text = "";
        try {
            if (state.apiProvider === 'gemini') {
                text = await this.callGemini(prompt);
            } else if (state.apiProvider === 'openrouter') {
                text = await this.callOpenRouter(prompt);
            } else if (state.apiProvider === 'koboldcpp') {
                text = await this.callKoboldCPP(prompt);
            }

            if (isJson) {
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (jsonMatch && jsonMatch[0]) {
                    return jsonMatch[0];
                }
                console.error("AI did not return valid JSON for a JSON-expected call. Response:", text);
                throw new Error("AI response was not in the expected JSON format.");
            }
            return text.trim();
        } catch (error) {
            console.error(`AI call failed for provider ${state.apiProvider}:`, error);
            throw error;
        }
    },
    async callGemini(prompt) {
        const state = StateManager.getState();
        if (!state.geminiApiKey) throw new Error("Gemini API key not set.");
        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${state.geminiApiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
    },
    async callOpenRouter(prompt) {
        const state = StateManager.getState();
        if (!state.openRouterKey || !state.openRouterModel) throw new Error("OpenRouter API key or model not set.");
        const res = await fetch('https://openrouter.ai/api/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.openRouterKey}`}, body: JSON.stringify({ model: state.openRouterModel, messages: [{ role: 'user', content: prompt }] }) });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.choices[0].message.content;
    },
    async callKoboldCPP(prompt) {
        const state = StateManager.getState();
        const payload = {
            prompt: prompt, use_story: false, use_memory: false, use_authors_note: false, use_world_info: false,
            max_context_length: 4096, max_length: 200, min_p: state.koboldcpp_min_p,
            rep_pen: 1.1, rep_pen_range: 2048, rep_pen_slope: 0.7, temperature: 0.65, 
            tfs: 1, top_p: 0.92, top_k: 0, typical: 1, sampler_order: [6, 0, 1, 2, 3, 4, 5],
            mirostat: 2, mirostat_tau: 4, mirostat_eta: 0.1, dry: state.koboldcpp_dry,
        };
        const res = await fetch(`${state.koboldcpp_url}/api/v1/generate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`KoboldCPP API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.results[0].text.trim();
    },
};

/**
 * =================================================================================================
 * ModalManager Module
 * =================================================================================================
 */
const ModalManager = {
    RUNTIME: {
        carousel_interval: null,
    },
    open(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'flex';
        }
    },
    close(modalId) {
        if (this.RUNTIME.carousel_interval) {
            clearInterval(this.RUNTIME.carousel_interval);
            this.RUNTIME.carousel_interval = null;
        }
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
        }
    }
};

/**
 * =================================================================================================
 * UTILITY Module
 * =================================================================================================
 */
const UTILITY = {
    uuid() { 
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)); 
    },
    escapeHTML(str) { 
        if(typeof str !== 'string') return ''; 
        const p = document.createElement("p"); 
        p.textContent = str; 
        return p.innerHTML; 
    },
    hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; } 
        else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
        return `rgba(${+r},${+g},${+b},${alpha})`;
    },
    getDefaultApiSettings() {
        return {
            apiProvider: 'gemini', geminiApiKey: '', openRouterKey: '', openRouterModel: 'google/gemini-flash-1.5',
            koboldcpp_url: 'http://localhost:5001', koboldcpp_template: 'none', koboldcpp_min_p: 0.1, koboldcpp_dry: 0.25,
        };
    },
    getDefaultUiSettings() {
        return {
            font: "'Inter', sans-serif", backgroundImageURL: '', bubbleOpacity: 0.85,
            chatTextColor: '#e5e7eb', characterImageMode: 'none',
            backgroundBlur: 5, textSize: 16, bubbleImageSize: 100,
        };
    },
    getDefaultSystemPrompts() {
        return {
            system_prompt: 'You are a master storyteller. Follow instructions precisely.',
            event_master_base_prompt: 'You are a secret Event Master. Read the chat. Generate a brief, secret instruction for AI characters to introduce a logical but unexpected event.',
            event_master_prompt: '', 
        };
    },
    findPath(grid, startCoords, endCoords) {
        const toKey = ({ x, y }) => `${x},${y}`;
        const fromKey = (key) => { const [x, y] = key.split(',').map(Number); return { x, y }; };

        const nodes = grid.map(loc => ({
            ...loc,
            g: Infinity, // cost from start to current node
            h: Infinity, // heuristic: estimated cost from current node to end
            f: Infinity, // g + h
            parent: null,
        }));

        const startNode = nodes.find(n => n.coords.x === startCoords.x && n.coords.y === startCoords.y);
        const endNode = nodes.find(n => n.coords.x === endCoords.x && n.coords.y === endCoords.y);

        if (!startNode || !endNode) return [];

        const heuristic = (a, b) => Math.abs(a.coords.x - b.coords.x) + Math.abs(a.coords.y - b.coords.y);

        let openSet = [startNode];
        let closedSet = new Set();

        startNode.g = 0;
        startNode.h = heuristic(startNode, endNode);
        startNode.f = startNode.h;

        while (openSet.length > 0) {
            openSet.sort((a, b) => a.f - b.f);
            let currentNode = openSet.shift();

            if (currentNode === endNode) {
                let path = [];
                let temp = currentNode;
                while (temp) {
                    path.push(temp.coords);
                    temp = temp.parent;
                }
                return path.reverse();
            }

            closedSet.add(toKey(currentNode.coords));

            const neighbors = nodes.filter(n => {
                const dx = Math.abs(n.coords.x - currentNode.coords.x);
                const dy = Math.abs(n.coords.y - currentNode.coords.y);
                return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
            });

            for (let neighbor of neighbors) {
                if (closedSet.has(toKey(neighbor.coords))) continue;

                let tentativeG = currentNode.g + 1; // Distance between neighbors is 1

                if (tentativeG < neighbor.g) {
                    neighbor.parent = currentNode;
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    }
                }
            }
        }
        return []; // No path found
    },
};

/**
 * =================================================================================================
 * PromptBuilder Module
 * =================================================================================================
 */
const PromptBuilder = {
    _getReplacer(contextCharacter) {
        const state = StateManager.getState();
        const userChar = state.characters.find(c => c.is_user);
        const characterName = contextCharacter ? contextCharacter.name : '';
        const userName = userChar ? userChar.name : 'You';
        return (text) => {
            if (typeof text !== 'string') return '';
            let processedText = text.replace(/{character}/g, characterName);
            processedText = processedText.replace(/{user}/g, userName);
            return processedText;
        };
    },
    buildPrompt(charToActId, isForUser = false) {
        const state = StateManager.getState();
        const charToAct = state.characters.find(c => c.id === charToActId);
        const replacer = this._getReplacer(charToAct);
        const modelInstructions = charToAct.model_instructions || state.system_prompt;

        let locationContext = '';
        if (state.worldMap && state.worldMap.grid.length > 0) {
            const { grid, currentLocation, path } = state.worldMap;
            const currentLoc = grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);
            if (currentLoc) {
                locationContext += `CURRENT LOCATION: ${currentLoc.name}\n${currentLoc.prompt}\n\n`;
                const directions = [
                    { dir: 'North', x: 0, y: -1 }, { dir: 'South', x: 0, y: 1 },
                    { dir: 'East', x: 1, y: 0 }, { dir: 'West', x: -1, y: 0 },
                    { dir: 'Northeast', x: 1, y: -1 }, { dir: 'Northwest', x: -1, y: -1 },
                    { dir: 'Southeast', x: 1, y: 1 }, { dir: 'Southwest', x: -1, y: 1 }
                ];
                let adjacentInfo = 'ADJACENT LOCATIONS:\n';
                directions.forEach(({ dir, x, y }) => {
                    const adjLoc = grid.find(l => l.coords.x === currentLocation.x + x && l.coords.y === currentLocation.y + y);
                    if (adjLoc) adjacentInfo += `- (${dir}): ${adjLoc.name} - ${adjLoc.description}\n`;
                });
                locationContext += adjacentInfo;
            }
            if (path && path.length > 0) {
                const pathNames = path.map(p => grid.find(l => l.coords.x === p.x && l.coords.y === p.y)?.name).filter(Boolean).join(' -> ');
                locationContext += `\nTRAVEL PATH TO DESTINATION: ${pathNames}\n`;
            }
        }
        
        const components = {
            system_prompt: replacer(modelInstructions),
            event_master_prompt: replacer(state.event_master_prompt),
            static_entries: (state.static_entries || []).map(l => `Title: ${l.title}\nContent: ${replacer(l.content)}`).join('\n\n'),
            characters: (state.characters || []).filter(c => c.is_active).map(c => `[Character: ${c.name}]\nDescription: ${replacer(c.description)}`).join('\n\n'),
            history: (state.chat_history || []).slice(-10),
            charToAct: charToAct,
            isForUser: isForUser,
            location_context: locationContext,
        };
        
        if (state.event_master_prompt) { 
            state.event_master_prompt = ''; 
            StateManager.saveState(); 
        }

        if (state.apiProvider === 'koboldcpp') { 
            return this.buildKoboldTemplatedPrompt(components, replacer); 
        }
        return this.buildDefaultPrompt(components, replacer);
    },
    buildDefaultPrompt(components, replacer) {
        const state = StateManager.getState();
        let p = components.system_prompt + "\n\n";
        if (components.event_master_prompt) p += "--- SECRET EVENT MASTER INSTRUCTION ---\n" + components.event_master_prompt + "\n\n";
        if (components.location_context) p += "--- LOCATION CONTEXT ---\n" + components.location_context + "\n\n";
        p += "--- STATIC KNOWLEDGE ---\n" + components.static_entries + "\n\n";
        p += "--- CHARACTERS ---\n" + components.characters + "\n\n";
        p += "--- RECENT CONVERSATION & EVENTS ---\n";
        components.history.forEach(msg => { 
            if (msg.type === 'chat') {
                const char = state.characters.find(c => c.id === msg.character_id); 
                if (char) p += `[Speaker: ${char.name}]\n${replacer(msg.content)}\n\n`;
            } else if (msg.type === 'lore_reveal') {
                p += `[System Note: Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}\n\n`;
            }
        });
        p += "\n--- INSTRUCTION ---\n";
        p += components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;
        p += " Do not repeat the character's name in the response itself.\n[CHARACTER_TO_ACT]: " + components.charToAct.name;
        return p;
    },
    buildKoboldTemplatedPrompt(components, replacer) {
        const state = StateManager.getState();
        const template = state.koboldcpp_template;
        if (template === 'none') return this.buildDefaultPrompt(components, replacer);

        let system = [components.system_prompt];
        if (components.event_master_prompt) system.push("SECRET EVENT INSTRUCTION:\n" + components.event_master_prompt);
        if (components.location_context) system.push("LOCATION CONTEXT:\n" + components.location_context);
        system.push("STATIC KNOWLEDGE:\n" + components.static_entries);
        system.push("CHARACTERS:\n" + components.characters);
        const system_prompt_str = system.join('\n\n');
        
        const history_str = components.history.map(msg => {
            if (msg.type === 'chat') {
                const char = state.characters.find(c => c.id === msg.character_id); 
                if (char) return `${char.is_user ? 'user' : 'assistant'}:${char.name}:\n${replacer(msg.content)}`;
            } else if (msg.type === 'lore_reveal') {
                return `system:Dynamic Entry Revealed - ${msg.title}:\n${replacer(msg.content)}`;
            }
        }).filter(Boolean).join('\n');

        let instruction = components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;
        instruction += " Do not repeat the character's name in the response itself.";

        switch (template) {
            case 'mistral':
                return `<s>[INST] ${system_prompt_str}\n\n${history_str}\n\n${instruction} [/INST]`;
            case 'chatml':
                const history_chatml = components.history.map(msg => {
                    const role = msg.type === 'lore_reveal' ? 'system' : (state.characters.find(c=>c.id === msg.character_id)?.is_user ? 'user' : 'assistant');
                    const content = msg.type === 'lore_reveal' ? `[Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}` : `${state.characters.find(c=>c.id === msg.character_id)?.name}:\n${replacer(msg.content)}`;
                    return `<|im_start|>${role}\n${content}<|im_end|>`;
                }).join('\n');
                return `<|im_start|>system\n${system_prompt_str}<|im_end|>\n${history_chatml}\n<|im_start|>user\n${instruction}<|im_end|>\n<|im_start|>assistant\n${components.charToAct.name}:\n`;
            case 'alpaca':
                 return `### Instruction:\n${system_prompt_str}\n\n${history_str}\n\n${instruction}\n\n### Response:\n`;
            default:
                return this.buildDefaultPrompt(components, replacer);
        }
    },
};

/**
 * =================================================================================================
 * ImportExportService Module
 * =================================================================================================
 */
const ImportExportService = {
    formatStoryForExport(story) {
        return JSON.stringify(story, null, 2);
    },
    formatLibraryForExport(library) {
        return JSON.stringify(library, null, 2);
    },
    parseStoryFile(jsonString) {
        const importedStory = JSON.parse(jsonString);
        if (importedStory.characters && importedStory.scenarios && importedStory.narratives) {
            const defaults = {
                ...UTILITY.getDefaultApiSettings(),
                ...UTILITY.getDefaultUiSettings(),
                ...UTILITY.getDefaultSystemPrompts(),
            };
            const newStory = { ...defaults, ...importedStory, id: UTILITY.uuid() };
            return newStory;
        } else {
            throw new Error('Invalid story file. Must be a valid story object.');
        }
    },
    parseLibraryFile(jsonString) {
         const importedLibrary = JSON.parse(jsonString);
         if (importedLibrary.stories && importedLibrary.hasOwnProperty('active_story_id')) {
             return importedLibrary;
         } else {
             throw new Error('Invalid library file.');
         }
    },
    async parseBYAF(zipData, fileName) {
        const zip = await JSZip.loadAsync(zipData);
        
        const manifestFile = zip.file('manifest.json');
        if (!manifestFile) throw new Error("manifest.json not found.");
        const manifestData = JSON.parse(await manifestFile.async('string'));

        if (!manifestData.characters || manifestData.characters.length === 0) throw new Error("No character in manifest.");
        
        const charFilePath = manifestData.characters[0];
        const charFileEntry = zip.file(charFilePath);
        if (!charFileEntry) throw new Error(`Character file not found: ${charFilePath}`);
        const byafCharData = JSON.parse(await charFileEntry.async('string'));

        let byafScenarioData = {};
        const scenarioPath = manifestData.scenarios && manifestData.scenarios.length > 0 ? manifestData.scenarios[0] : 'scenario.json';
        const scenarioFileEntry = zip.file(scenarioPath);
        if(scenarioFileEntry) {
           byafScenarioData = JSON.parse(await scenarioFileEntry.async('string'));
        }
        
        const characterName = byafCharData.name || "Unnamed Character";
        const newStory = {
            id: UTILITY.uuid(), name: byafScenarioData?.title || byafCharData.name || `Chat with ${characterName}`,
            last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
            creator_notes: `[Imported from BYAF file: ${fileName}]`, tags: byafCharData.tags || [],
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(),
            characters: [], dynamic_entries: [], scenarios: [], narratives: []
        };

        const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[] };
        
        const fullDescription = (byafCharData.description || byafCharData.persona || '').replace(/{character}/g, characterName);
        const firstSentence = fullDescription.split('.')[0] + '.';

        const newCharacter = {
            id: UTILITY.uuid(), name: characterName, description: fullDescription, short_description: firstSentence,
            model_instructions: "Act as {character}. Be descriptive and engaging.",
            image_url: '', extra_portraits: [], tags: byafCharData.tags || [], is_user: false, is_active: true
        };

        if (byafCharData.system_prompt) newCharacter.model_instructions = byafCharData.system_prompt.replace(/{character}/g, characterName);
        if (byafScenarioData.formattingInstructions) newCharacter.model_instructions = byafScenarioData.formattingInstructions.replace(/{character}/g, characterName).replace(/{user}/g, userChar.name);
        newStory.characters = [userChar, newCharacter];
        
        const firstMes = (byafScenarioData.firstMessages && byafScenarioData.firstMessages[0]?.text) || byafCharData.first_mes || `The story of ${characterName} begins.`;
        const newScenario = { id: UTILITY.uuid(), name: "Imported Start", message: firstMes.replace(/{character}/g, characterName).replace(/{user}/g, userChar.name) };
        newStory.scenarios.push(newScenario);
        
        const newNarrative = {
            id: UTILITY.uuid(), name: "Imported Chat", last_modified: new Date().toISOString(),
            state: {
                chat_history: [], messageCounter: 0,
                static_entries: byafScenarioData.narrative ? [{id: UTILITY.uuid(), title: "Initial Scene", content: byafScenarioData.narrative.replace(/{character}/g, characterName)}] : []
            }
        };
        
        if (byafScenarioData.exampleMessages && byafScenarioData.exampleMessages[0]?.text) {
            const exampleText = byafScenarioData.exampleMessages[0].text;
            const charNameIdMap = {'#{character}:': newCharacter.id, '#{user}:': userChar.id};
            const regex = /(#\{(?:character|user)\}:)([\s\S]*?)(?=#\{|$)/g;
            for (const match of exampleText.matchAll(regex)) {
                if (charNameIdMap[match[1]] && match[2].trim()) {
                    newNarrative.state.chat_history.push({ 
                        character_id: charNameIdMap[match[1]], 
                        content: match[2].trim().replace(/{character}/g, characterName).replace(/{user}/g, userChar.name), 
                        type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(), isHidden: true
                    });
                }
            }
        }
        
        const firstSpeaker = newStory.characters.find(c => !c.is_user && c.is_active);
        if(firstSpeaker) newNarrative.state.chat_history.push({ character_id: firstSpeaker.id, content: newScenario.message, type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString() });
        newNarrative.state.messageCounter = newNarrative.state.chat_history.filter(m => !m.isHidden).length;
        newStory.narratives.push(newNarrative);

        return newStory;
    },
};


    /**
 * =================================================================================================
 * UIManager Module (The View)
 * =================================================================================================
 * This module is exclusively responsible for all direct DOM manipulation. It reads data
 * from the StateManager to render the UI but does not modify the application's state itself.
 */
const UIManager = {
    // Holds temporary, non-persistent properties related to the app's runtime behavior.
    RUNTIME: {
        streamingInterval: null,
        titleTimeout: null,
    },

    getAIGenIcon() {
        return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-wand-2"><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.21 1.21 0 0 0 1.72 0L21.64 5.36a1.21 1.21 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 18h-4"/><path d="M11 3H9"/></svg>`;
    },
    
    renderAll() { 
        const library = StateManager.getLibrary();
        const activeStory = library.stories.find(s => s.id === library.active_story_id);
        if (activeStory) {
            const activeNarrative = (activeStory.narratives || []).find(n => n.id === library.active_narrative_id);
            document.getElementById('story-title-input').value = activeNarrative ? `${activeStory.name}: ${activeNarrative.name}` : activeStory.name;
            const mobileTitle = document.getElementById('mobile-story-title-overlay');
            if (mobileTitle) mobileTitle.value = activeNarrative ? `${activeStory.name}: ${activeNarrative.name}` : activeStory.name;
        }
        this.renderCharacters(); 
        this.renderStaticEntries(); 
        this.renderDynamicEntries(); 
        this.renderChat(); 
        this.updateAICharacterSelector(); 
    },

    renderLibraryInterface(filterState = {}) {
        const library = StateManager.getLibrary();
        const container = document.getElementById('library-content-container');
        const { searchTerm = '', sortBy = 'last_modified', filterTag = '' } = filterState;

        const isTallScreen = window.innerHeight > window.innerWidth;

        // --- Filter, Search, Sort Logic ---
        let stories = [...library.stories];
        if (searchTerm) {
            const lowerCaseSearch = searchTerm.toLowerCase();
            stories = stories.filter(s => s.search_index && s.search_index.includes(lowerCaseSearch));
        }
        if (filterTag) {
            stories = stories.filter(s => {
                const storyTags = new Set(s.tags || []);
                (s.characters || []).forEach(c => (c.tags || []).forEach(t => storyTags.add(t)));
                return storyTags.has(filterTag);
            });
        }
        stories.sort((a, b) => {
            if (sortBy === 'name') return (a.name || '').localeCompare(b.name || '');
            if (sortBy === 'created_date') return new Date(b.created_date) - new Date(a.created_date);
            return new Date(b.last_modified) - new Date(a.last_modified);
        });

        // --- Controls HTML ---
        const tagOptions = library.tag_cache.map(tag => `<option value="${tag}" ${filterTag === tag ? 'selected':''}>${tag}</option>`).join('');
        const controlsHTML = `
            <div class="p-6 border-b border-gray-700 space-y-4">
                <input type="search" placeholder="Search stories..." value="${searchTerm}" oninput="UIManager.renderLibraryInterface({searchTerm: this.value, sortBy: document.getElementById('sort-by').value, filterTag: document.getElementById('filter-by-tag').value})" class="w-full bg-black/30 p-2 rounded-lg border-gray-600">
                <div class="flex space-x-4">
                    <select id="sort-by" onchange="UIManager.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: this.value, filterTag: document.getElementById('filter-by-tag').value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="last_modified" ${sortBy === 'last_modified' ? 'selected' : ''}>Modified</option>
                        <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Name</option>
                        <option value="created_date" ${sortBy === 'created_date' ? 'selected' : ''}>Created</option>
                    </select>
                    <select id="filter-by-tag" onchange="UIManager.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: document.getElementById('sort-by').value, filterTag: this.value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="">Tag</option>
                        ${tagOptions}
                    </select>
                </div>
            </div>`;

        // --- Story List HTML ---
        const storyListHTML = stories.map(story => {
            const displayName = story.name || 'Untitled Story';
            const isActiveStory = story.id === library.active_story_id;
            return `
            <div class="p-4 rounded-lg flex justify-between items-center cursor-pointer ${isActiveStory ? 'bg-indigo-600/30' : 'bg-gray-700/50 hover:bg-gray-600/50'}" onclick="UIManager.openStoryDetails('${story.id}')">
                <div>
                    <h3 class="font-semibold text-lg">${UTILITY.escapeHTML(displayName)}</h3>
                    <p class="text-sm text-gray-400">Modified: ${new Date(story.last_modified).toLocaleString()}</p>
                </div>
                ${isActiveStory ? '<span class="text-xs text-indigo-300 font-bold">ACTIVE</span>' : ''}
            </div>
        `}).join('<hr class="border-gray-700 my-2">');

        // --- Assemble Final Layout ---
        if (isTallScreen) {
             container.innerHTML = `<div class="flex flex-col flex-grow min-h-0">${controlsHTML}<div class="p-6 overflow-y-auto">${storyListHTML}</div></div>`;
        } else {
            container.innerHTML = `
                <div class="w-[450px] flex-shrink-0 border-r border-gray-700 flex flex-col">${controlsHTML}<div class="p-6 overflow-y-auto flex-grow">${storyListHTML}</div></div>
                <div id="story-details-content-desktop" class="flex-grow p-6 flex text-gray-500"><div class="w-full h-full flex items-center justify-center">Select a story to see details...</div></div>
            `;
        }
    },

    openStoryDetails(storyId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (!story) return;

        const scenariosHTML = (story.scenarios || []).map(scenario => `
            <div class="bg-gray-700/30 p-3 rounded-lg flex justify-between items-center gap-2">
                <p class="font-semibold flex-grow">${UTILITY.escapeHTML(scenario.name)}</p>
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button onclick="Controller.createNarrativeFromScenario('${story.id}', '${scenario.id}')" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold p-2 rounded-lg" title="Load Scenario (Creates New Narrative)"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg></button>
                    <button onclick="Controller.duplicateScenario('${story.id}', '${scenario.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold p-2 rounded-lg" title="Duplicate Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                    <button onclick="Controller.deleteScenario('${story.id}', '${scenario.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold p-2 rounded-lg" title="Delete Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            </div>
        `).join('');

        const narrativesHTML = (story.narratives || []).sort((a, b) => new Date(b.last_modified) - new Date(a.last_modified)).map(narrative => `
            <div class="bg-gray-700/60 p-3 rounded-lg flex justify-between items-center gap-2">
                <div class="flex-grow">
                    <p class="font-semibold">${UTILITY.escapeHTML(narrative.name)}</p>
                    <p class="text-xs text-gray-400">Modified: ${new Date(narrative.last_modified).toLocaleString()}</p>
                </div>
                ${narrative.id === library.active_narrative_id && story.id === library.active_story_id ? '<span class="text-xs text-sky-300 font-bold flex-shrink-0">ACTIVE</span>' : ''}
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button onclick="Controller.elevateNarrativeToScenario('${story.id}', '${narrative.id}')" class="bg-teal-600 hover:bg-teal-500 text-white font-bold p-2 rounded-lg" title="Elevate to Scenario"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg></button>
                    <button onclick="Controller.loadNarrative('${story.id}', '${narrative.id}')" class="bg-green-600 hover:bg-green-500 text-white font-bold p-2 rounded-lg" title="Load Narrative"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>
                    <button onclick="Controller.duplicateNarrative('${story.id}', '${narrative.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold p-2 rounded-lg" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                    <button onclick="Controller.deleteNarrative('${story.id}', '${narrative.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold p-2 rounded-lg" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            </div>
        `).join('');

        const detailsHTML = `
            <div class="relative w-full h-full bg-black/20 overflow-hidden flex flex-col">
                <div class="relative w-full aspect-video flex-shrink-0">
                     <div id="details-carousel" class="w-full h-full"></div>
                     <div class="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-black/80 via-black/30 to-transparent pointer-events-none z-10"></div>
                     <h3 class="absolute top-4 left-4 text-white text-2xl font-bold drop-shadow-lg z-20">${UTILITY.escapeHTML(story.name || 'Untitled Story')}</h3>
                </div>
                <div class="p-6 flex-grow overflow-y-auto space-y-6 min-h-0">
                     <div>
                        <h4 class="font-bold text-lg mb-2 text-indigo-300">Scenarios (Templates)</h4>
                        <div class="space-y-2">${scenariosHTML || '<p class="text-sm text-gray-400">No scenarios in this story.</p>'}</div>
                     </div>
                     <hr class="border-gray-600">
                     <div>
                        <h4 class="font-bold text-lg mb-2 text-sky-300">Narratives (Chats)</h4>
                        <div class="space-y-2">${narrativesHTML || '<p class="text-sm text-gray-400">No narratives yet. Load a scenario to start one.</p>'}</div>
                     </div>
                      <hr class="border-gray-600">
                     <div class="flex space-x-2">
                        <button onclick="Controller.renameStoryPrompt('${story.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg" title="Rename"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button onclick="Controller.duplicateStory('${story.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                        <button onclick="Controller.exportStory('${story.id}')" class="bg-green-600/80 hover:bg-green-700/80 text-white font-bold py-2 px-3 rounded-lg" title="Export Story"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg></button>
                        <button onclick="Controller.deleteStory('${story.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-3 rounded-lg" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                     </div>
                </div>
            </div>
        `;

        if (window.innerHeight > window.innerWidth) {
            document.getElementById('story-details-content-mobile').innerHTML = detailsHTML;
            Controller.openModal('story-details-modal');
            this.startCarousel(story.characters, 'details-carousel');
        } else {
            document.getElementById('story-details-content-desktop').innerHTML = detailsHTML;
            this.startCarousel(story.characters, 'details-carousel');
        }
    },

    startCarousel(characters, containerId) {
        if (ModalManager.RUNTIME.carousel_interval) clearInterval(ModalManager.RUNTIME.carousel_interval);
        
        const container = document.getElementById(containerId);
        if (!container) return;

        const images = (characters || []).map(c => c.image_url).filter(Boolean);
        if (images.length === 0) {
            container.innerHTML = `<div class="w-full h-full flex items-center justify-center bg-gray-900 text-gray-500">No character images</div>`;
            return;
        }

        container.innerHTML = `
            <img id="${containerId}-img1" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 1;">
            <img id="${containerId}-img2" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 0;">
        `;
        
        let currentIndex = 0;
        let activeImg = 1;

        const img1 = document.getElementById(`${containerId}-img1`);
        const img2 = document.getElementById(`${containerId}-img2`);
        img1.src = images[currentIndex];
        
        ModalManager.RUNTIME.carousel_interval = setInterval(() => {
            currentIndex = (currentIndex + 1) % images.length;
            if (activeImg === 1) {
                img2.src = images[currentIndex];
                img1.style.opacity = 0;
                img2.style.opacity = 1;
                activeImg = 2;
            } else {
                img1.src = images[currentIndex];
                img1.style.opacity = 1;
                img2.style.opacity = 0;
                activeImg = 1;
            }
        }, 4000);
    },
    
    renderCharacters() { 
        const state = StateManager.getState();
        const container = document.getElementById('characters-container');
        if (!state.characters) {
            container.innerHTML = '';
            return;
        }
        container.innerHTML = state.characters.map(char => {
            const tagsHTML = (char.tags || []).map(tag => `<span class="bg-indigo-500/50 text-indigo-200 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${UTILITY.escapeHTML(tag)}</span>`).join('');
            return `
                <div onclick="Controller.openModal('character-detail-modal', '${char.id}')" 
                     class="char-roster-btn" 
                     style="background-image: url('${char.image_url || 'https://placehold.co/600x800/111827/4b5563?text=?'}')">
                    <div class="char-roster-content text-white">
                        <h3 class="font-bold text-lg truncate">${UTILITY.escapeHTML(char.name)}</h3>
                        <p class="text-sm text-gray-300 italic truncate">${UTILITY.escapeHTML(char.short_description)}</p>
                        <div class="mt-2 h-6 overflow-hidden">${tagsHTML}</div>
                    </div>
                </div>
            `;
        }).join('');
    },

    renderKnowledgeModalTabs() {
        const tabName = Controller.RUNTIME.activeKnowledgeTab;
        const staticTab = document.getElementById('knowledge-tab-static');
        const dynamicTab = document.getElementById('knowledge-tab-dynamic');
        const staticContent = document.getElementById('knowledge-static-content');
        const dynamicContent = document.getElementById('knowledge-dynamic-content');
        const addButton = document.getElementById('knowledge-add-button');

        if (tabName === 'static') {
            staticContent.classList.remove('hidden');
            dynamicContent.classList.add('hidden');
            staticTab.classList.add('border-indigo-500', 'text-white');
            staticTab.classList.remove('border-transparent', 'text-gray-400');
            dynamicTab.classList.add('border-transparent', 'text-gray-400');
            dynamicTab.classList.remove('border-indigo-500', 'text-white');
            addButton.onclick = () => Controller.addStaticEntry();
            this.renderStaticEntries();
        } else { // dynamic
            dynamicContent.classList.remove('hidden');
            staticContent.classList.add('hidden');
            dynamicTab.classList.add('border-indigo-500', 'text-white');
            dynamicTab.classList.remove('border-transparent', 'text-gray-400');
            staticTab.classList.add('border-transparent', 'text-gray-400');
            staticTab.classList.remove('border-indigo-500', 'text-white');
            addButton.onclick = () => Controller.addDynamicEntry();
            this.renderDynamicEntries();
        }
    },
    
    renderStaticEntries() { 
        const state = StateManager.getState(); 
        document.getElementById('static-entries-list').innerHTML = (state.static_entries || []).map(entry => `<div onclick="Controller.selectStaticEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${state.selectedStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}"><h4 class="font-semibold truncate">${UTILITY.escapeHTML(entry.title)}</h4></div>`).join(''); 
        this.renderStaticEntryDetails(); 
    },
    
    renderStaticEntryDetails() { 
        const state = StateManager.getState(); 
        const container = document.getElementById('static-entry-details-content'); 
        const entry = (state.static_entries || []).find(e => e.id === state.selectedStaticEntryId); 
        if (entry) { 
            container.innerHTML = `<input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateStaticEntryField('${entry.id}', 'title', this.value)" class="text-xl font-bold bg-black/30 p-2 w-full mb-4"><textarea oninput="Controller.updateStaticEntryField('${entry.id}', 'content', this.value)" class="w-full h-4/5 bg-black/30 p-2 resize-none">${UTILITY.escapeHTML(entry.content)}</textarea><div class="flex justify-end mt-4"><button onclick="Controller.deleteStaticEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button></div>`; 
        } else { 
            container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div>`; 
        } 
    },
    
    renderDynamicEntries() { 
        const state = StateManager.getState(); 
        document.getElementById('dynamic-entries-list').innerHTML = (state.dynamic_entries || []).map(entry => `<div onclick="Controller.selectDynamicEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${state.selectedDynamicEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} flex justify-between items-center"><h4 class="font-semibold truncate">${UTILITY.escapeHTML(entry.title)}</h4> ${entry.triggered_at_turn !== null ? '<span class="text-xs text-sky-300">ACTIVE</span>' : ''}</div>`).join(''); 
        this.renderDynamicEntryDetails(); 
    },
    
    renderDynamicEntryDetails() { 
        const state = StateManager.getState();
        const container = document.getElementById('dynamic-entry-details-content'); 
        const entry = (state.dynamic_entries || []).find(e => e.id === state.selectedDynamicEntryId); 
        if (entry) { 
            container.innerHTML = `<div class="flex flex-col h-full">
                <label class="font-bold">Title</label>
                <input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateDynamicEntryField('${entry.id}', 'title', this.value)" class="text-xl font-bold bg-black/30 p-2 w-full mb-4">
                <label class="font-bold mb-2">Triggers (Keywords, AND, XOR, % Chance)</label>
                <input type="text" value="${UTILITY.escapeHTML(entry.triggers)}" oninput="Controller.updateDynamicEntryField('${entry.id}', 'triggers', this.value)" placeholder="e.g. house, cat AND dog, 25%" class="bg-black/30 p-2 w-full mb-4">
                <label class="font-bold">Content</label>
                <textarea oninput="Controller.updateDynamicEntryField('${entry.id}', 'content', this.value)" class="w-full flex-grow bg-black/30 p-2 resize-none">${UTILITY.escapeHTML(entry.content)}</textarea>
                <div class="flex justify-end mt-4"><button onclick="Controller.deleteDynamicEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button></div>
            </div>`; 
        } else { 
            container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div>`; 
        } 
    },
    
    _createMessageHTML(msg, index) {
        const state = StateManager.getState();
        if (msg.type === 'lore_reveal' || msg.isHidden) return '';
        
        if (msg.type === 'system_event') {
            return `<div class="w-full text-center my-2"><p class="text-sm italic text-gray-400">${UTILITY.escapeHTML(msg.content)}</p></div>`;
        }

        const character = state.characters.find(c => c.id === msg.character_id);
        if (!character) return '';

        const userChar = state.characters.find(c => c.is_user);
        const characterName = character ? character.name : '';
        const userName = userChar ? userChar.name : 'You';
        const replacer = (text) => {
            if (typeof text !== 'string') return '';
            return text.replace(/{character}/g, characterName).replace(/{user}/g, userName);
        };

        const processedContent = replacer(msg.content);
        const contentId = `message-content-${index}`;
        const boldedContent = processedContent.replace(/(["])([^"]*)(["])/g, '**$1$2$3**');
        let contentHTML = marked.parse(boldedContent || '');
        
        let bubbleColor;
        let characterNameColor = '';

        if (state.characterImageMode === 'bubble' && character.image_url) {
            contentHTML = `<img src="${character.image_url}" class="bubble-char-image">` + contentHTML;
        }

        if (character.is_user) {
            bubbleColor = `rgba(75, 85, 99, ${state.bubbleOpacity})`; 
        } else {
            const charColor = character.color || { base: '#334155', bold: '#94a3b8' };
            bubbleColor = UTILITY.hexToRgba(charColor.base, state.bubbleOpacity);
            characterNameColor = `style="color: ${charColor.bold};"`;
        }
        
        const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

        return `
            <div class="chat-bubble-container ${msg.isNew ? 'new-message' : ''} mb-4" data-message-index="${index}">
                <div class="bubble-header">
                     <p class="font-bold text-sm" ${characterNameColor}>${UTILITY.escapeHTML(character.name)}</p>
                     <span class="timestamp text-xs text-gray-500">${timestamp}</span>
                     <div class="action-btn-group flex ml-2 space-x-4">
                        <button onclick="Controller.copyMessage(${index})" class="text-gray-400 hover:text-white" title="Copy"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                        <button onclick="Controller.openModal('edit-response-modal', ${index})" class="text-gray-400 hover:text-white" title="Edit"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                    </div>
                </div>
                <div class="bubble-body rounded-lg px-3 py-2" style="background-color: ${bubbleColor};">
                    <div id="${contentId}" class="whitespace-pre-wrap" style="color: ${state.chatTextColor}; font-family: ${state.font};">
                        ${contentHTML}
                    </div>
                </div>
            </div>`;
    },

    renderChat() {
        const state = StateManager.getState();
        if (!state || !state.chat_history) {
             document.getElementById('chat-window').innerHTML = `<div class="h-full w-full flex items-center justify-center text-gray-500 text-lg">No Narrative Loaded</div>`;
             return;
        }
        if (this.RUNTIME.streamingInterval) return; 
        
        document.body.dataset.mode = state.characterImageMode;
        this.updateSidePortrait();

        const cinematicBg = document.getElementById('cinematic-overlay-bg');
        if (state.characterImageMode === 'cinematic_overlay') {
            const lastChatMessages = state.chat_history.filter(m => m.type === 'chat' && !m.isHidden);
            const lastSpeakerMsg = lastChatMessages.length > 0 ? lastChatMessages[lastChatMessages.length - 1] : null;
            const lastSpeaker = lastSpeakerMsg ? state.characters.find(c => c.id === lastSpeakerMsg.character_id) : null;
            
            if (lastSpeaker && lastSpeaker.image_url) {
                const lastEmotion = lastSpeakerMsg.emotion || 'neutral';
                let portraitUrl = lastSpeaker.image_url;
                if (lastEmotion !== 'neutral' && lastSpeaker.extra_portraits) {
                    const emotionalPortrait = lastSpeaker.extra_portraits.find(p => p.emotion === lastEmotion);
                    if (emotionalPortrait) portraitUrl = emotionalPortrait.url;
                }
                cinematicBg.style.backgroundImage = `url('${portraitUrl}')`;
            } else {
               cinematicBg.style.backgroundImage = 'none';
            }
        } else {
            cinematicBg.style.backgroundImage = 'none';
        }

        document.getElementById('chat-window').innerHTML = (state.chat_history || []).map((msg, index) => this._createMessageHTML(msg, index)).join('');
        (state.chat_history || []).forEach(m => m.isNew = false);
    },
    
    renderExampleDialogueModal() {
        const state = StateManager.getState();
        const container = document.getElementById('example-dialogue-container');
        if (!container) return;

        const userChar = state.characters.find(c => c.is_user);
        const aiChars = state.characters.filter(c => !c.is_user);
        const exampleMessages = state.chat_history.map((msg, index) => ({ ...msg, originalIndex: index })).filter(msg => msg.isHidden === true);

        if (exampleMessages.length === 0) {
            container.innerHTML = `<div class="text-gray-400 text-center">No example dialogue found. Add a turn to start.</div>`;
            return;
        }

        container.innerHTML = exampleMessages.map((msg, idx) => {
            const speakerOptions = [userChar, ...aiChars].map(char => `<option value="${char.id}" ${msg.character_id === char.id ? 'selected' : ''}>${UTILITY.escapeHTML(char.name)}</option>`).join('');
            return `
                <div class="bg-black/20 p-4 rounded-lg flex items-center space-x-4">
                    <div class="flex flex-col space-y-2">
                        <button onclick="Controller.moveExampleDialogueTurn(${msg.originalIndex}, 'up')" ${idx === 0 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Up"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                        <button onclick="Controller.moveExampleDialogueTurn(${msg.originalIndex}, 'down')" ${idx === exampleMessages.length - 1 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Down"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                    </div>
                    <div class="flex-grow flex flex-col space-y-2">
                        <select onchange="Controller.updateExampleDialogueTurn(${msg.originalIndex}, 'character_id', this.value)" class="w-full bg-gray-700 border-gray-600 rounded p-2 text-sm">${speakerOptions}</select>
                        <textarea oninput="Controller.updateExampleDialogueTurn(${msg.originalIndex}, 'content', this.value)" class="w-full bg-gray-900/80 border-gray-600 p-2 resize-none rounded-md">${UTILITY.escapeHTML(msg.content)}</textarea>
                    </div>
                    <button onclick="Controller.deleteExampleDialogueTurn(${msg.originalIndex})" class="flex-shrink-0 bg-red-600/80 hover:bg-red-700/80 text-white font-bold p-2 rounded-lg" title="Delete Turn"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            `;
        }).join('');

        const textareas = container.querySelectorAll('textarea');
        textareas.forEach(textarea => {
            const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
            textarea.addEventListener('input', autoResize);
            setTimeout(autoResize, 0);
        });
    },

    updateSidePortrait() {
        const portraitContainer = document.getElementById('character-portrait-container');
        if(document.body.classList.contains('layout-vertical')) {
            portraitContainer.innerHTML = '';
            return;
        }
        
        const state = StateManager.getState();
        if (!state || !state.characters || !state.chat_history) {
            portraitContainer.innerHTML = '';
            return;
        }

        const lastChatMessages = (state.chat_history || []).filter(m => m.type === 'chat' && !m.isHidden && !state.characters.find(c=>c.id === m.character_id)?.is_user);
        const lastSpeakerMsg = lastChatMessages.length > 0 ? lastChatMessages[lastChatMessages.length - 1] : null;
        const lastSpeaker = lastSpeakerMsg ? state.characters.find(c => c.id === lastSpeakerMsg.character_id) : null;
        
        if (lastSpeaker && lastSpeaker.image_url) {
             const lastEmotion = lastSpeakerMsg.emotion || 'neutral';
             let portraitUrl = lastSpeaker.image_url;
             if (lastEmotion !== 'neutral' && lastSpeaker.extra_portraits) {
                 const emotionalPortrait = lastSpeaker.extra_portraits.find(p => p.emotion === lastEmotion);
                 if (emotionalPortrait && emotionalPortrait.url) portraitUrl = emotionalPortrait.url;
             }
             portraitContainer.innerHTML = `<img src="${portraitUrl}" class="max-w-full max-h-full object-contain">`;
        } else {
            portraitContainer.innerHTML = '';
        }
    },

    startStreamingResponse(charId, fullText, emotion) {
        if (this.RUNTIME.streamingInterval) clearInterval(this.RUNTIME.streamingInterval);
        const state = StateManager.getState();

        const messageIndex = state.chat_history.length;
        state.chat_history.push({ 
            character_id: charId, content: '', type: 'chat', emotion: emotion, 
            timestamp: new Date().toISOString(), isNew: true 
        });

        this.renderChat();
        
        const messageContentEl = document.getElementById(`message-content-${messageIndex}`);
        if (!messageContentEl) {
            console.error("Could not find message element to stream to.");
            return;
        }
        const bubbleEl = messageContentEl.closest('.chat-bubble-container');
        const words = fullText.split(/(\s+)/);
        let wordIndex = 0;

        this.RUNTIME.streamingInterval = setInterval(() => {
            if (wordIndex < words.length) {
                const word = words[wordIndex];
                state.chat_history[messageIndex].content += word;
                
                const userChar = state.characters.find(c => c.is_user);
                const character = state.characters.find(c => c.id === charId);
                const replacer = (text) => text.replace(/{character}/g, character.name).replace(/{user}/g, userChar.name);
                let processedContent = replacer(state.chat_history[messageIndex].content);
                
                const boldedContent = processedContent.replace(/(["])([^"]*)(["])/g, '**$1$2$3**');
                let fullHTML = marked.parse(boldedContent);
                
                if (state.characterImageMode === 'bubble' && character?.image_url) {
                    fullHTML = `<img src="${character.image_url}" class="bubble-char-image">` + fullHTML;
                }
                
                messageContentEl.innerHTML = fullHTML;
                
                const chatWindow = document.getElementById('chat-window');
                const isScrolledToBottom = chatWindow.scrollHeight - chatWindow.clientHeight <= chatWindow.scrollTop + 50;
                if(isScrolledToBottom) {
                     bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
                wordIndex++;
            } else {
                clearInterval(this.RUNTIME.streamingInterval);
                this.RUNTIME.streamingInterval = null;
                state.chat_history[messageIndex].isNew = false;
                StateManager.saveState();
                setTimeout(() => bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
            }
        }, 5); 
    },
    
    showTypingIndicator(charId, text="is thinking...") { 
        this.hideTypingIndicator(); 
        const chatWindow=document.getElementById('chat-window'); 
        const name = (StateManager.getState().characters || []).find(c => c.id === charId)?.name || 'System'; 
        const indicator = document.createElement('div'); 
        indicator.id = 'typing-indicator'; 
        indicator.innerHTML = `<div class="mb-4 flex flex-col items-start"><p class="font-bold text-sm mb-1">${UTILITY.escapeHTML(name)}</p><div class="p-3 bg-gray-700/80 rounded-lg"><p class="italic">${text}</p></div></div>`; 
        chatWindow.appendChild(indicator); 
        chatWindow.scrollTop = chatWindow.scrollHeight; 
    },
    
    hideTypingIndicator() { 
        const el = document.getElementById('typing-indicator'); 
        if (el) el.remove(); 
    },
    
    applyStyling() { 
        const state = StateManager.getState();
        const backgroundElement = document.getElementById('global-background');
        const appContainer = document.getElementById('app-container');
        
        let backgroundUrl = state.backgroundImageURL || '';
        if (state.worldMap && state.worldMap.grid.length > 0) {
            const currentLoc = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
            if (currentLoc && currentLoc.imageUrl) {
                backgroundUrl = currentLoc.imageUrl;
            }
        }
        
        backgroundElement.style.backgroundImage = backgroundUrl ? `url('${backgroundUrl}')` : 'none';
        
        // Dynamic CSS Variables
        document.documentElement.style.setProperty('--chat-font-size', `${state.textSize}px`);
        document.documentElement.style.setProperty('--bubble-image-size', `${state.bubbleImageSize}px`);
        appContainer.style.backdropFilter = `blur(${state.backgroundBlur}px)`;
        
        // Border Color from Text Color
        const hex = state.chatTextColor || '#e5e7eb';
        let r = 0, g = 0, b = 0;
        if (hex.length === 4) { 
            r = parseInt(hex[1] + hex[1], 16);
            g = parseInt(hex[2] + hex[2], 16);
            b = parseInt(hex[3] + hex[3], 16);
        } else if (hex.length === 7) {
            r = parseInt(hex.substring(1, 3), 16);
            g = parseInt(hex.substring(3, 5), 16);
            b = parseInt(hex.substring(5, 7), 16);
        }
        document.documentElement.style.setProperty('--border-hue-color', `rgba(${r}, ${g}, ${b}, 0.4)`);

        this.renderChat();
    },

    renderWorldMapModal() {
        const state = StateManager.getState();
        const { activeWorldMapTab, selectedMapTile, pendingMove } = Controller.RUNTIME;
        const { worldMap } = state;
        const container = document.getElementById('world-map-modal-content');

        if (!worldMap || !worldMap.grid || worldMap.grid.length === 0) {
            container.innerHTML = `<div class="h-full flex flex-col items-center justify-center p-6 text-center">
                <p class="text-gray-400 mb-4">The world map is empty.</p>
                <button id="generate-world-button" onclick="Controller.generateWorldMap()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">${this.getAIGenIcon()}</button>
            </div>`;
            return;
        }

        let contentHTML = '';
        if (activeWorldMapTab === 'move') {
            const { currentLocation } = worldMap;
            let moveGridHTML = '';
            for (let y = currentLocation.y - 1; y <= currentLocation.y + 1; y++) {
                for (let x = currentLocation.x - 1; x <= currentLocation.x + 1; x++) {
                    const isCenter = x === currentLocation.x && y === currentLocation.y;
                    const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                    const bgImage = location?.imageUrl ? `background-image: url('${location.imageUrl}');` : '';
                    let classList = ['aspect-square', 'rounded-lg', 'flex', 'items-end', 'p-2', 'text-white', 'relative', 'overflow-hidden', 'bg-cover', 'bg-center', 'transition-all'];
                    
                    if (isCenter) {
                        classList.push('bg-indigo-800/80', 'ring-2', 'ring-indigo-300');
                    } else if (location) {
                        classList.push('bg-gray-700/80', 'cursor-pointer', 'hover:ring-2', 'hover:ring-sky-400');
                    } else {
                        classList.push('bg-black/50');
                    }

                    if (pendingMove && pendingMove.x === x && pendingMove.y === y && !isCenter) {
                        classList.push('ring-4', 'ring-yellow-400');
                    }

                    if (location) {
                        moveGridHTML += `<div 
                            class="${classList.join(' ')}"
                            style="${bgImage}"
                            ${!isCenter ? `onclick="Controller.selectPendingMove(${x}, ${y})"` : ''}>
                            <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                            <span class="relative z-10 text-sm font-bold">${UTILITY.escapeHTML(location.name)}</span>
                        </div>`;
                    } else {
                        moveGridHTML += `<div class="${classList.join(' ')}"></div>`;
                    }
                }
            }

            let detailsHTML = '';
            const pendingLocation = pendingMove ? worldMap.grid.find(l => l.coords.x === pendingMove.x && l.coords.y === pendingMove.y) : null;
            if (pendingLocation) {
                 detailsHTML = `
                    <h3 class="text-2xl font-bold">${UTILITY.escapeHTML(pendingLocation.name)}</h3>
                    <p class="text-gray-400 mt-2 flex-grow">${UTILITY.escapeHTML(pendingLocation.description)}</p>
                    <button onclick="Controller.confirmMove()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg mt-4">Confirm Move</button>
                `;
            } else {
                 const currentLocationData = worldMap.grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);
                 detailsHTML = `
                    <h3 class="text-2xl font-bold">Movement</h3>
                    <p class="text-gray-400 mt-2">You are currently at <strong>${UTILITY.escapeHTML(currentLocationData.name)}</strong>.</p>
                    <p class="text-gray-400 mt-2">Select an adjacent tile to see its details and confirm your move.</p>
                `;
            }

             contentHTML = `<div class="p-6 flex-grow grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                <div class="grid grid-cols-3 gap-2">${moveGridHTML}</div>
                <div class="flex flex-col h-full">${detailsHTML}</div>
            </div>`;

        } else { // 'worldmap' tab
            const { currentLocation, destination, path } = worldMap;
            let mapGridHTML = '';
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                    let classList = ['aspect-square', 'rounded', 'bg-gray-800/80', 'hover:bg-gray-700/80', 'cursor-pointer', 'text-xs', 'p-1', 'overflow-hidden', 'leading-tight'];
                    
                    if (currentLocation.x === x && currentLocation.y === y) classList.push('ring-2', 'ring-green-400');
                    if (destination.x === x && destination.y === y) classList.push('ring-2', 'ring-red-500');
                    if (path.some(p => p.x === x && p.y === y)) classList.push('bg-sky-700/50');
                    if (selectedMapTile && selectedMapTile.coords.x === x && selectedMapTile.coords.y === y) classList.push('ring-2', 'ring-yellow-300');

                    mapGridHTML += `<div class="${classList.join(' ')}" onclick="Controller.selectMapTile(${x}, ${y})">${location ? UTILITY.escapeHTML(location.name) : ''}</div>`;
                }
            }

            let detailsHTML = `<div class="h-full flex items-center justify-center text-gray-500">Select a tile to view details.</div>`;
            if (selectedMapTile) {
                detailsHTML = `
                    <div class="h-full flex flex-col space-y-3">
                        <div><label class="text-sm text-gray-400">Name</label><input type="text" value="${UTILITY.escapeHTML(selectedMapTile.name)}" oninput="Controller.updateLocationDetail('name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        <div><label class="text-sm text-gray-400">Image URL</label><input type="text" value="${UTILITY.escapeHTML(selectedMapTile.imageUrl)}" oninput="Controller.updateLocationDetail('imageUrl', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        <div><label class="text-sm text-gray-400">Brief Description</label><textarea oninput="Controller.updateLocationDetail('description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded h-20 resize-none">${UTILITY.escapeHTML(selectedMapTile.description)}</textarea></div>
                        <div class="flex-grow flex flex-col"><label class="text-sm text-gray-400">Full Prompt</label><textarea oninput="Controller.updateLocationDetail('prompt', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded flex-grow resize-none">${UTILITY.escapeHTML(selectedMapTile.prompt)}</textarea></div>
                        <button onclick="Controller.setDestination()" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg">Set as Destination</button>
                    </div>`;
            }

            contentHTML = `<div class="p-6 flex-grow grid grid-cols-3 gap-6 h-full">
                <div class="col-span-2 grid grid-cols-8 gap-1">${mapGridHTML}</div>
                <div class="col-span-1 bg-black/30 rounded-lg p-4">${detailsHTML}</div>
            </div>`;
        }

        container.innerHTML = `
            <div class="p-6 pb-0 flex justify-between items-center border-b border-gray-700">
                <div class="flex">
                    <button id="world-map-tab-move" onclick="Controller.switchWorldMapTab('move')" class="py-3 px-4 font-semibold text-lg ${activeWorldMapTab === 'move' ? 'border-b-2 border-indigo-500 text-white' : 'border-b-2 border-transparent text-gray-400 hover:text-white'}">Move</button>
                    <button id="world-map-tab-worldmap" onclick="Controller.switchWorldMapTab('worldmap')" class="py-3 px-4 font-semibold text-lg ${activeWorldMapTab === 'worldmap' ? 'border-b-2 border-indigo-500 text-white' : 'border-b-2 border-transparent text-gray-400 hover:text-white'}">World Map</button>
                </div>
                <button id="generate-world-button" onclick="Controller.generateWorldMap()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg ml-4 flex-shrink-0">${this.getAIGenIcon()}</button>
            </div>
            ${contentHTML}
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('world-map-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>`;
    },

    openCharacterDetailModal(charId) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) {
            console.error("Character not found:", charId);
            return;
        }
        const container = document.getElementById('character-detail-modal-content');
        
        const extraPortraitsHTML = (char.extra_portraits || []).map((portrait, index) => `
            <div class="flex items-center space-x-2 mt-2">
                <select onchange="Controller.updateExtraPortrait('${char.id}', ${index}, 'emotion', this.value)" class="w-1/3 bg-black/30 border-gray-600 rounded p-1 text-sm">
                    <option value="happy" ${portrait.emotion === 'happy' ? 'selected' : ''}>Happy</option>
                    <option value="sad" ${portrait.emotion === 'sad' ? 'selected' : ''}>Sad</option>
                    <option value="angry" ${portrait.emotion === 'angry' ? 'selected' : ''}>Angry</option>
                    <option value="surprised" ${portrait.emotion === 'surprised' ? 'selected' : ''}>Surprised</option>
                </select>
                <input type="text" value="${UTILITY.escapeHTML(portrait.url)}" oninput="Controller.updateExtraPortrait('${char.id}', ${index}, 'url', this.value)" class="w-2/3 bg-black/30 border-gray-600 p-1 text-sm" placeholder="URL...">
                <button onclick="Controller.removeExtraPortrait('${char.id}', ${index})" class="text-red-400 hover:text-red-300">X</button>
            </div>
        `).join('');
        
        const tagsValue = (char.tags || []).join(', ');

        const modalHTML = `
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold" data-char-id="${char.id}">${UTILITY.escapeHTML(char.name)}</h2>
                ${!char.is_user ? `<div class="flex items-center space-x-2"><span class="text-sm">Active</span><label class="flex items-center cursor-pointer"><div class="relative"><input type="checkbox" class="sr-only" ${char.is_active ? 'checked' : ''} onchange="Controller.toggleCharacterActive(event, '${char.id}')"><div class="w-12 h-6 bg-gray-600 rounded-full toggle-bg"></div></div></label></div>` : '<span class="text-sm font-semibold text-indigo-400">PLAYER</span>'}
            </div>
            <div class="p-6 overflow-y-auto space-y-4">
                <details open>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Primary Info</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                        <div><label class="text-sm text-gray-400">Name</label><input type="text" value="${UTILITY.escapeHTML(char.name)}" oninput="Controller.updateCharacterField('${char.id}', 'name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded text-lg"></div>
                        <div><label class="text-sm text-gray-400">Short Description (for roster card)</label><input type="text" value="${UTILITY.escapeHTML(char.short_description)}" oninput="Controller.updateCharacterField('${char.id}', 'short_description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        <div><label class="text-sm text-gray-400">Default Image URL</label><input type="text" value="${UTILITY.escapeHTML(char.image_url)}" oninput="Controller.updateCharacterField('${char.id}', 'image_url', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        <div><label class="text-sm text-gray-400">Tags (comma-separated)</label><div class="flex items-center space-x-2"><input type="text" value="${tagsValue}" oninput="Controller.updateCharacterTags('${char.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"><button onclick="Controller.generateTagsForCharacter(event, '${char.id}')" class="p-2 bg-gray-600/80 hover:bg-gray-500/80 rounded-lg" title="Auto-Tag with AI">${this.getAIGenIcon()}</button></div></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Persona</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea oninput="Controller.updateCharacterField('${char.id}', 'description', this.value); UIManager.updateTokenCount('${char.id}', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${UTILITY.escapeHTML(char.description)}</textarea>
                         <div class="flex justify-between items-center"><span class="text-right text-sm text-gray-400" id="token-counter-${char.id}">~${Math.round((char.description || '').length / 4)} tokens</span><button onclick="Controller.enhancePersonaWithAI(event, '${char.id}')" class="bg-gray-600/80 hover:bg-gray-500/80 font-semibold p-2 rounded-lg" title="Enhance Persona with AI">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Model Instructions</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea oninput="Controller.updateCharacterField('${char.id}', 'model_instructions', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${UTILITY.escapeHTML(char.model_instructions)}</textarea>
                         ${!char.is_user ? `<div class="text-right"><button onclick="Controller.generateModelInstructions(event, '${char.id}')" class="bg-sky-600/80 hover:bg-sky-700/80 font-semibold p-2 rounded-lg" title="Generate Instructions with AI">${this.getAIGenIcon()}</button></div>` : ''}
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Emotional Portraits</summary>
                    <div class="p-4 space-y-2 bg-black/20 rounded-b-lg">
                        <div id="extra-portraits-${char.id}">${extraPortraitsHTML}</div>
                        <button onclick="Controller.addExtraPortrait('${char.id}')" class="text-sm text-sky-400 hover:text-sky-300 mt-2">+ Add Emotional Portrait</button>
                    </div>
                </details>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-between">
                ${!char.is_user ? `<button onclick="if(confirm('Are you sure you want to delete this character?')) Controller.deleteCharacter('${char.id}')" class="bg-red-600/80 hover:bg-red-700/80 font-bold py-2 px-4 rounded-lg">Delete</button>` : '<div></div>'}
                <button onclick="Controller.closeModal('character-detail-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        `;
        container.innerHTML = modalHTML;

        container.querySelectorAll('textarea').forEach(textarea => {
            const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
            textarea.addEventListener('input', autoResize);
            setTimeout(autoResize, 0);
        });
    },

    updateTokenCount(charId, text) { 
        const counter = document.getElementById(`token-counter-${charId}`); 
        if (counter) counter.textContent = `~${Math.round((text || '').length / 4)} tokens`; 
    },

    updateAICharacterSelector() {
        const state = StateManager.getState();
        const selector = document.getElementById('ai-character-selector');
        if (!state || !state.characters) {
            selector.innerHTML = '';
            return;
        }
        const currentValue = selector.value;
        selector.innerHTML = state.characters.filter(c => !c.is_user && c.is_active).map(c => `<option value="${c.id}">${UTILITY.escapeHTML(c.name)}</option>`).join('');
        if (currentValue && selector.querySelector(`option[value="${currentValue}"]`)) {
            selector.value = currentValue;
        }
    },
};


    /**
 * =================================================================================================
 * Controller Module (The Handler)
 * =================================================================================================
 * This module handles all user-initiated events. It acts as the "brain," receiving
 * user input, telling the StateManager how to change the data, calling the APIService
 * for AI responses, and then telling the UIManager to re-render the view.
 */
const Controller = {
    // A single place for constants the controller uses.
    CONSTANTS: {
        CHARACTER_COLORS: [
            { base: '#334155', bold: '#94a3b8' }, // Slate (Blue-Grey)
            { base: '#1e3a8a', bold: '#60a5fa' }, // Blue
            { base: '#581c87', bold: '#f472b6' }, // Fuchsia
            { base: '#78350f', bold: '#fbbf24' }, // Amber
            { base: '#365314', bold: '#a3e635' }, // Lime
            { base: '#5b21b6', bold: '#a78bfa' }, // Violet
            { base: '#881337', bold: '#fb7185' }, // Rose
            { base: '#155e75', bold: '#22d3ee' }  // Cyan
        ]
    },

    // Holds temporary, non-persistent properties related to the controller's runtime behavior.
    RUNTIME: {
        activeKnowledgeTab: 'static',
        activeSettingsTab: 'appearance',
        activeWorldMapTab: 'move',
        selectedMapTile: null,
        pendingMove: null,
    },

    // --- Story & Narrative Management ---
    createDefaultStoryAndNarrative() {
        const library = StateManager.getLibrary();

        const newStory = {
            id: UTILITY.uuid(), name: "My First Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(), creator_notes: "", tags: [],
            search_index: "my first story",
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(),
            characters: [
                { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[] }, 
                { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: this.CONSTANTS.CHARACTER_COLORS[0] }
            ], 
            dynamic_entries: [{id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content: "This is a sample dynamic lore entry.", triggered_at_turn: null }],
            selectedStaticEntryId: null, selectedDynamicEntryId: null,
            scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
            narratives: []
        };
        
        const defaultScenario = newStory.scenarios[0];
        const newNarrative = {
            id: UTILITY.uuid(), name: `${defaultScenario.name} - Chat`, last_modified: new Date().toISOString(),
            state: {
                chat_history: [], messageCounter: 0,
                static_entries: [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                worldMap: { grid: [], currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
            }
        };
        
        const firstSpeaker = newStory.characters.find(c => !c.is_user);
        newNarrative.state.chat_history.push({
            character_id: firstSpeaker.id, content: defaultScenario.message, type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(),
        });
        newNarrative.state.messageCounter = 1;

        newStory.narratives.push(newNarrative);
        
        library.stories.push(newStory);
        library.active_story_id = newStory.id;
        library.active_narrative_id = newNarrative.id;

        StateManager.saveLibrary();
        window.location.reload(); 
    },

    createNewStory() {
        const library = StateManager.getLibrary();
        const newStory = {
            id: UTILITY.uuid(), name: "New Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(), creator_notes: "", tags: [], search_index: "new story",
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(),
            characters: [
                { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[] }, 
                { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: this.CONSTANTS.CHARACTER_COLORS[0] }
            ], 
            dynamic_entries: [{id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content: "This is a sample dynamic lore entry.", triggered_at_turn: null }],
            selectedStaticEntryId: null, selectedDynamicEntryId: null,
            scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
            narratives: []
        };
        library.stories.push(newStory);
        library.active_story_id = null;
        library.active_narrative_id = null;
        StateManager.saveLibrary();
        UIManager.renderLibraryInterface();
    },

    createNarrativeFromScenario(storyId, scenarioId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const scenario = story.scenarios.find(sc => sc.id === scenarioId);
        if (!story || !scenario) return;

        const newNarrative = {
            id: UTILITY.uuid(),
            name: `${scenario.name} - Chat`,
            created_date: new Date().toISOString(),
            last_modified: new Date().toISOString(),
            state: {}
        };

        // If scenario has state, use it. Otherwise, create default.
        if (scenario.static_entries && scenario.worldMap) {
            newNarrative.state = {
                chat_history: [],
                messageCounter: 0,
                static_entries: JSON.parse(JSON.stringify(scenario.static_entries)),
                worldMap: JSON.parse(JSON.stringify(scenario.worldMap))
            };
        } else {
            newNarrative.state = {
                chat_history: [], messageCounter: 0,
                static_entries: [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                worldMap: { grid: [], currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
            };
        }
        
        const firstMessage = scenario.message;
        if (firstMessage) {
            const firstSpeaker = story.characters.find(c => !c.is_user && c.is_active);
            if (firstSpeaker) {
                newNarrative.state.chat_history.push({
                    character_id: firstSpeaker.id, content: firstMessage, type: 'chat',
                    emotion: 'neutral', timestamp: new Date().toISOString(), isNew: true
                });
                newNarrative.state.messageCounter = 1;
            }
        }
        if(!story.narratives) story.narratives = [];
        story.narratives.push(newNarrative);
        this.loadNarrative(storyId, newNarrative.id);
    },

    loadNarrative(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        library.active_story_id = storyId;
        library.active_narrative_id = narrativeId;
        StateManager.saveLibrary();
        window.location.reload();
    },

    duplicateNarrative(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const narrative = story.narratives.find(n => n.id === narrativeId);
        if (!story || !narrative) return;
        
        const newNarrative = JSON.parse(JSON.stringify(narrative)); // Deep copy
        newNarrative.id = UTILITY.uuid();
        newNarrative.name = `${narrative.name} (Copy)`;
        newNarrative.created_date = new Date().toISOString();
        newNarrative.last_modified = new Date().toISOString();
        
        story.narratives.push(newNarrative);
        StateManager.saveLibrary();
        UIManager.openStoryDetails(storyId);
    },

    deleteNarrative(storyId, narrativeId) {
        if (!confirm("Are you sure you want to delete this narrative and all its history?")) return;
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (story) {
            story.narratives = story.narratives.filter(n => n.id !== narrativeId);
            if (library.active_narrative_id === narrativeId) {
                library.active_narrative_id = null;
            }
            StateManager.saveLibrary();
            UIManager.openStoryDetails(storyId);
        }
    },

    duplicateScenario(storyId, scenarioId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const scenario = story.scenarios.find(sc => sc.id === scenarioId);
        if (!story || !scenario) return;
        
        const newScenario = JSON.parse(JSON.stringify(scenario));
        newScenario.id = UTILITY.uuid();
        newScenario.name = `${scenario.name} (Copy)`;
        story.scenarios.push(newScenario);
        StateManager.saveLibrary();
        UIManager.openStoryDetails(storyId);
    },
    
    deleteScenario(storyId, scenarioId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (story) {
            if (story.scenarios.length <= 1) {
                alert("You cannot delete the last scenario.");
                return;
            }
            if (!confirm("Are you sure you want to delete this scenario?")) return;
            story.scenarios = story.scenarios.filter(sc => sc.id !== scenarioId);
            StateManager.saveLibrary();
            UIManager.openStoryDetails(storyId);
        }
    },

    deleteStory(storyId) {
        const library = StateManager.getLibrary();
        library.stories = library.stories.filter(s => s.id !== storyId);
        StateManager.updateTagCache();

        if (library.active_story_id === storyId) {
            library.active_story_id = null;
            library.active_narrative_id = null;
            StateManager.saveLibrary();
            window.location.reload();
        } else {
            StateManager.saveLibrary();
            UIManager.renderLibraryInterface();
        }
    },

    renameStory(storyId, newName) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if(story) {
            story.name = newName;
            StateManager.saveLibrary();
            UIManager.renderLibraryInterface();
            if (story.id === library.active_story_id) {
                document.getElementById('story-title-input').value = newName;
                const mobileTitle = document.getElementById('mobile-story-title-overlay');
                if (mobileTitle) mobileTitle.value = newName;
            }
        }
    },

    renameStoryPrompt(storyId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (story) {
            const currentName = story.name || '';
            const newName = prompt("Enter new name for the story:", currentName);
            if (newName && newName.trim() !== '') {
                this.renameStory(storyId, newName.trim());
            }
        }
    },

    duplicateStory(storyId) {
        const library = StateManager.getLibrary();
        const originalStory = library.stories.find(s => s.id === storyId);
        if (!originalStory) return;

        const newStory = JSON.parse(JSON.stringify(originalStory));
        newStory.id = UTILITY.uuid();
        newStory.name = `${originalStory.name || 'Untitled Story'} (Copy)`;
        newStory.last_modified = new Date().toISOString();
        newStory.created_date = new Date().toISOString();
        
        this.updateSearchIndex(newStory);
        library.stories.push(newStory);
        StateManager.saveLibrary();
        UIManager.renderLibraryInterface();
    },

    updateSearchIndex(story) {
        if (!story) return;
        let index = [story.name];
        if (story.tags) index.push(...story.tags);
        if (story.characters) {
            story.characters.forEach(char => {
                index.push(char.name);
                index.push(char.description);
                if (char.tags) index.push(...char.tags);
            });
        }
        story.search_index = index.join(' ').toLowerCase();
    },

    // --- Modal & UI State Management ---

    openModal(modalId, contextId = null) { 
        const library = StateManager.getLibrary();
        const state = StateManager.getState();
        
        if ((modalId === 'knowledge-modal' || modalId === 'characters-modal' || modalId === 'settings-modal' || modalId === 'example-dialogue-modal' || modalId === 'character-detail-modal' || modalId === 'world-map-modal') && (!library.active_narrative_id || Object.keys(state).length === 0)) {
             alert("Please load a narrative first.");
             return;
        }

        switch(modalId) {
            case 'story-library-modal':
                UIManager.renderLibraryInterface();
                break;
            case 'knowledge-modal':
                this.switchKnowledgeTab('static');
                break;
            case 'world-map-modal':
                this.RUNTIME.selectedMapTile = null;
                this.RUNTIME.pendingMove = null;
                this.switchWorldMapTab('move');
                break;
            case 'settings-modal':
                this.prepareSettingsModal();
                this.switchSettingsTab(this.RUNTIME.activeSettingsTab || 'appearance');
                break;
            case 'example-dialogue-modal':
                UIManager.renderExampleDialogueModal();
                break;
            case 'character-detail-modal':
                UIManager.openCharacterDetailModal(contextId);
                break;
            case 'edit-response-modal':
                this.openEditModal(contextId);
                break;
        }
        ModalManager.open(modalId);
    },
    
    closeModal(modalId) { 
        ModalManager.close(modalId);
        if (modalId === 'character-detail-modal') {
            UIManager.renderCharacters();
        }
    },

    toggleMobileMenu() {
        document.getElementById('mobile-menu').classList.toggle('hidden');
    },

    switchKnowledgeTab(tabName) {
        this.RUNTIME.activeKnowledgeTab = tabName;
        UIManager.renderKnowledgeModalTabs();
    },

    switchWorldMapTab(tabName) {
        this.RUNTIME.activeWorldMapTab = tabName;
        UIManager.renderWorldMapModal();
    },

    switchSettingsTab(tabName) {
        this.RUNTIME.activeSettingsTab = tabName;
        const tabs = ['appearance', 'prompt', 'model'];
        const container = document.getElementById('settings-content-container');
        const template = document.getElementById(`settings-${tabName}-content`);
        container.innerHTML = template.innerHTML;

        tabs.forEach(tab => {
            const tabButton = document.getElementById(`settings-tab-${tab}`);
            if (tab === tabName) {
                tabButton.classList.add('border-indigo-500', 'text-white');
                tabButton.classList.remove('border-transparent', 'text-gray-400');
            } else {
                tabButton.classList.remove('border-indigo-500', 'text-white');
                tabButton.classList.add('border-transparent', 'text-gray-400');
            }
        });
        this.bindSettingsListeners();
    },

    openSettingsToTab(tabName) {
        this.openModal('settings-modal');
        this.switchSettingsTab(tabName);
    },

    prepareSettingsModal() {
        const container = document.getElementById('settings-content-container');
        if (container.innerHTML.trim() !== '...') return; // Already populated
        
        const templates = document.getElementById('settings-templates');
        let maxHeight = 0;
        ['appearance', 'prompt', 'model'].forEach(tabName => {
            const content = templates.querySelector(`#settings-${tabName}-content`);
            if(content) {
                 document.body.appendChild(content); // Temporarily append to measure
                 maxHeight = Math.max(maxHeight, content.scrollHeight);
                 templates.appendChild(content); // Move it back
            }
        });
        container.style.minHeight = `${maxHeight}px`;
    },

    bindSettingsListeners() {
        const state = StateManager.getState();
        const setListener = (id, key, callback) => { 
            const input = document.getElementById(id); 
            if (!input) return;
            input.value = state[key] !== undefined ? state[key] : '';
            const debouncedCallback = debounce(function(e) { 
                state[key] = e.target.value; 
                StateManager.saveState();
                if(callback) callback();
            }.bind(this), 500);
            input.addEventListener('input', debouncedCallback); 
        };
        const setupSlider = (sliderId, valueId, stateKey, callback = null) => {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            if (!slider || !valueDisplay) return;
            slider.value = state[stateKey];
            valueDisplay.textContent = slider.value;
            slider.addEventListener('input', (e) => {
                state[stateKey] = parseFloat(e.target.value);
                valueDisplay.textContent = e.target.value;
                if(callback) callback();
            });
            slider.addEventListener('change', () => StateManager.saveState());
        };
        
        if(document.getElementById('gemini-api-key-input')) setListener('gemini-api-key-input', 'geminiApiKey'); 
        if(document.getElementById('openrouter-api-key-input')) setListener('openrouter-api-key-input', 'openRouterKey'); 
        if(document.getElementById('openrouter-model-input')) setListener('openrouter-model-input', 'openRouterModel'); 
        if(document.getElementById('system-prompt-input')) setListener('system-prompt-input', 'system_prompt');
        if(document.getElementById('event-master-prompt-input')) setListener('event-master-prompt-input', 'event_master_base_prompt');
        if(document.getElementById('background-image-url')) setListener('background-image-url', 'backgroundImageURL', () => UIManager.applyStyling());
        if(document.getElementById('chat-text-color')) setListener('chat-text-color', 'chatTextColor', () => UIManager.applyStyling());
        
        // Kobold Sliders
        if(document.getElementById('koboldcpp-min-p-slider')) setupSlider('koboldcpp-min-p-slider', 'koboldcpp-min-p-value', 'koboldcpp_min_p');
        if(document.getElementById('koboldcpp-dry-slider')) setupSlider('koboldcpp-dry-slider', 'koboldcpp-dry-value', 'koboldcpp_dry');
        
        // New Appearance Sliders
        if(document.getElementById('blur-slider')) setupSlider('blur-slider', 'blur-value', 'backgroundBlur', () => UIManager.applyStyling());
        if(document.getElementById('text-size-slider')) setupSlider('text-size-slider', 'text-size-value', 'textSize', () => UIManager.applyStyling());
        if(document.getElementById('bubble-image-size-slider')) setupSlider('bubble-image-size-slider', 'bubble-image-size-value', 'bubbleImageSize', () => UIManager.applyStyling());

        const fontSelector = document.getElementById('font-selector'); 
        if(fontSelector) {
            fontSelector.value = state.font; 
            fontSelector.addEventListener('change', (e) => this.changeFont(e.target.value));
        }

        const templateSelector = document.getElementById('koboldcpp-template-selector');
        if(templateSelector) {
            templateSelector.value = state.koboldcpp_template;
            templateSelector.addEventListener('change', (e) => {
                state.koboldcpp_template = e.target.value;
                StateManager.saveState();
            });
        }
        
        const opacitySlider = document.getElementById('bubble-opacity-slider');
        if(opacitySlider) {
            const opacityValue = document.getElementById('bubble-opacity-value');
            opacitySlider.value = state.bubbleOpacity;
            opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
            opacitySlider.addEventListener('input', (e) => {
                state.bubbleOpacity = parseFloat(e.target.value);
                opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
                UIManager.renderChat();
            });
            opacitySlider.addEventListener('change', () => StateManager.saveState());
        }
        
        document.querySelectorAll('input[name="imageDisplayMode"]').forEach(radio => {
            radio.checked = state.characterImageMode === radio.value;
            radio.addEventListener('change', (e) => this.setCharacterImageMode(e.target.value));
        });
        document.querySelectorAll('input[name="apiProvider"]').forEach(radio => {
            radio.checked = state.apiProvider === radio.value;
            radio.addEventListener('change', (e) => this.setApiProvider(e.target.value));
        });

         document.getElementById('gemini-settings').style.display = state.apiProvider === 'gemini' ? 'block' : 'none'; 
         document.getElementById('openrouter-settings').style.display = state.apiProvider === 'openrouter' ? 'block' : 'none';
         document.getElementById('koboldcpp-settings').style.display = state.apiProvider === 'koboldcpp' ? 'block' : 'none';
    },
    
    changeFont(font) { 
        StateManager.getState().font = font; 
        UIManager.applyStyling(); 
        StateManager.saveState(); 
    },
    
    setCharacterImageMode(mode) {
        StateManager.getState().characterImageMode = mode;
        StateManager.saveState();
        UIManager.renderChat();
    },

    setApiProvider(provider) { 
        StateManager.getState().apiProvider = provider; 
        this.bindSettingsListeners(); 
        StateManager.saveState(); 
    },

    // --- Chat & AI Interaction ---
    handlePrimaryAction() { 
        if(!StateManager.getLibrary().active_narrative_id) { 
            alert("Load a narrative from the Story Library first."); 
            return; 
        } 
        document.getElementById('chat-input').value.trim() === '' ? this.writeForMe() : this.sendMessage(); 
    },

    async handleRegen() {
        const state = StateManager.getState();
        if(!StateManager.getLibrary().active_narrative_id) { alert("Load a narrative from the Story Library first."); return; }
        if (UIManager.RUNTIME.streamingInterval) return;
        const selectedCharId = document.getElementById('ai-character-selector').value;
        const lastMsg = state.chat_history.filter(m => m.type === 'chat').pop();
        const lastChar = lastMsg ? state.characters.find(c => c.id === lastMsg.character_id) : null;

        if (lastChar && !lastChar.is_user && lastMsg.character_id === selectedCharId) {
            this.undoLastTurn();
            await this.triggerAIResponse(selectedCharId);
        } else {
            await this.triggerAIResponse(selectedCharId);
        }
    },

    async sendMessage() {
        if (UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        const input = document.getElementById('chat-input');
        const userChar = state.characters.find(c => c.is_user);
        const messageContent = input.value.trim();
        this.addMessageToHistory(userChar.id, messageContent);
        input.value = '';
        this.checkDynamicEntryTriggers();
        await this.triggerAIResponse(null, messageContent);
        this.checkEventMaster();
    },

    async writeForMe() {
        if (UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        const userChar = state.characters.find(c => c.is_user); if (!userChar) return;
        const btn = document.getElementById('primary-action-btn');
        const input = document.getElementById('chat-input');
        const originalPlaceholder = input.placeholder;
        btn.disabled = true;
        input.placeholder = 'AI is writing...';
        try {
            const prompt = PromptBuilder.buildPrompt(userChar.id, true);
            input.value = await APIService.callAI(prompt);
        } catch (error) {
            console.error("Write for Me failed:", error);
        } finally {
            btn.disabled = false;
            input.placeholder = originalPlaceholder;
        }
    },

    undoLastTurn() { 
        if (UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        if (state.chat_history.length === 0) return; 
        const lastMessage = state.chat_history.pop(); 
        if (lastMessage.type === 'chat') state.messageCounter--; 
        this.saveAndRender(); 
    },

    addMessageToHistory(id, content, type = 'chat', emotion = 'neutral') {
        const state = StateManager.getState();
        if (UIManager.RUNTIME.streamingInterval) {
            clearInterval(UIManager.RUNTIME.streamingInterval);
            UIManager.RUNTIME.streamingInterval = null;
            StateManager.saveState();
        }
        state.chat_history.push({ 
            character_id: id, content, type, emotion,
            timestamp: new Date().toISOString(), isNew: true 
        });
        if (type === 'chat') state.messageCounter++;
        UIManager.renderChat();
        StateManager.saveState();
        
        const chatWindow = document.getElementById('chat-window');
        const lastBubble = chatWindow.lastElementChild;
        if(lastBubble) {
            lastBubble.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    },

    addSystemMessageToHistory(content) {
        const state = StateManager.getState();
        state.chat_history.push({
            type: 'system_event', content, timestamp: new Date().toISOString(), isNew: true
        });
        UIManager.renderChat();
        StateManager.saveState();
    },

    async triggerAIResponse(charId = null, userMessage = '') {
        const aiCharId = charId || document.getElementById('ai-character-selector').value;
        if (!aiCharId) return;
        UIManager.showTypingIndicator(aiCharId);

        try {
            const prompt = PromptBuilder.buildPrompt(aiCharId);
            const responseText = await APIService.callAI(prompt);
            
            // New: Analyze user's turn for emotion and location
            let analysis = { emotion: 'neutral', locationName: null };
            if (userMessage) {
                try {
                    analysis = await this.analyzeTurn(userMessage);
                } catch (e) {
                    console.error("Turn analysis failed:", e);
                }
            }
            
            UIManager.hideTypingIndicator();
            UIManager.startStreamingResponse(aiCharId, responseText, analysis.emotion);

            if (analysis.locationName) {
                const state = StateManager.getState();
                const targetLocation = state.worldMap.grid.find(loc => loc.name.toLowerCase() === analysis.locationName.toLowerCase());
                const currentLocationData = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
                if (targetLocation && targetLocation.name !== currentLocationData?.name) {
                    setTimeout(() => { // Delay auto-move for better UX
                        this.moveToLocation(targetLocation.coords.x, targetLocation.coords.y);
                    }, 1500);
                }
            }

        } catch (error) { 
            UIManager.hideTypingIndicator();
            this.addMessageToHistory(aiCharId, `[Error: ${error.message}]`); 
        }
    },
    
    // --- Agent & Trigger Logic ---

    async checkWorldInfoAgent() { 
        const state = StateManager.getState();
        if (!StateManager.getLibrary().active_narrative_id) { alert("Please load a narrative first."); return; }
        UIManager.showTypingIndicator('static-entry-agent', 'Updating static knowledge...'); 
        try { 
            let p = `As Static Knowledge Master, read chat/info, update the info. Output valid JSON: { "add": [{"title": "...", "content": "..."}], "modify": [{"title": "...", "new_content": "..."}] } or {}. INFO:${JSON.stringify(state.static_entries)}CHAT:`; 
            (state.chat_history || []).filter(m=>m.type==='chat').slice(-8).forEach(msg => { const c = state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;});
            const updates = JSON.parse(await APIService.callAI(p, true)); 
            if (updates.add) updates.add.forEach(item => state.static_entries.push({id: UTILITY.uuid(), ...item})); 
            if (updates.modify) updates.modify.forEach(item => { const entry = state.static_entries.find(e => e.title.toLowerCase() === item.title.toLowerCase()); if (entry) entry.content = item.new_content; }); 
            this.saveAndRenderStaticEntries(); 
        } catch (e) { 
            console.error("Static Entry Agent failed:", e); 
            alert("The AI failed to update static entries. It may have returned an invalid format.");
        } finally { 
            UIManager.hideTypingIndicator(); 
        } 
    },
    
    async checkEventMaster() { 
        const state = StateManager.getState();
        if (state.messageCounter > 0 && state.messageCounter % 6 === 0) try { 
            let p = state.event_master_base_prompt + '\n\n--- RECENT CHAT HISTORY ---\n'; 
            (state.chat_history || []).filter(m=>m.type==='chat').slice(-12).forEach(msg => { const c = state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;});
            state.event_master_prompt = await APIService.callAI(p); 
            StateManager.saveState(); 
            console.log("Event Master:", state.event_master_prompt); 
        } catch (e) { 
            console.error("Event Master failed:", e); 
        } 
    },
    
    checkDynamicEntryTriggers() {
        const state = StateManager.getState();
        const lastMessage = (state.chat_history || []).filter(m => m.type === 'chat').pop();
        if (!lastMessage) return;
        const content = lastMessage.content.toLowerCase();

        (state.dynamic_entries || []).forEach(entry => {
            if (entry.triggered_at_turn !== null && (state.messageCounter - entry.triggered_at_turn > 10)) {
                entry.triggered_at_turn = null;
            }

            if (entry.triggered_at_turn === null) {
                const { groups, chance } = this.parseTriggers(entry.triggers);
                const keywordMatch = groups.some(group => {
                    switch (group.type) {
                        case 'OR': return content.includes(group.keywords[0]);
                        case 'AND': return group.keywords.every(kw => content.includes(kw));
                        case 'XOR': const [f, s] = [content.includes(group.keywords[0]), content.includes(group.keywords[1])]; return (f && !s) || (!f && s);
                        default: return false;
                    }
                });
                if (keywordMatch || (Math.random() * 100 < chance)) {
                    entry.triggered_at_turn = state.messageCounter;
                    state.chat_history.push({ type: 'lore_reveal', title: entry.title, content: entry.content });
                    console.log(`Dynamic Entry triggered: ${entry.title}`);
                }
            }
        });
        StateManager.saveState();
        UIManager.renderDynamicEntries();
    },

    parseTriggers(triggersStr) {
        if (!triggersStr) return { groups: [], chance: 0 };
        const parts = triggersStr.split(',').map(s => s.trim());
        const chancePart = parts.find(p => p.match(/^\d+\s*\%$/));
        const chance = chancePart ? parseInt(chancePart.replace('%', '')) : 0;
        const keywordParts = parts.filter(p => p && !p.match(/^\d+\s*\%$/));
        const groups = keywordParts.map(part => {
            if (part.includes(' XOR ')) { const keywords = part.split(' XOR ').map(k => k.trim().toLowerCase()).filter(Boolean); if (keywords.length === 2) return { type: 'XOR', keywords }; }
            if (part.includes(' AND ')) { const keywords = part.split(' AND ').map(k => k.trim().toLowerCase()).filter(Boolean); if (keywords.length > 0) return { type: 'AND', keywords }; }
            return { type: 'OR', keywords: [part.toLowerCase()] };
        });
        return { groups, chance };
    },

    // --- CRUD and Edit Functions ---
    openEditModal(index) {
        const state = StateManager.getState();
        const message = state.chat_history[index];
        const input = document.getElementById('edit-modal-input');
        input.value = message.content;
        const autoResize = () => { input.style.height = 'auto'; input.style.height = `${input.scrollHeight}px`; };
        if (input.autoResizeListener) input.removeEventListener('input', input.autoResizeListener);
        input.autoResizeListener = autoResize;
        input.addEventListener('input', autoResize);
        document.getElementById('edit-modal-save-button').onclick = () => this.saveEditedResponse(index);
        setTimeout(autoResize, 0);
        ModalManager.open('edit-response-modal');
    },

    saveEditedResponse(index) {
        const state = StateManager.getState();
        const newContent = document.getElementById('edit-modal-input').value;
        state.chat_history[index].content = newContent;
        this.saveAndRender();
        this.closeModal('edit-response-modal');
    },

    async enhancePersonaWithAI(event, charId) {
        if (!confirm("This will overwrite the current persona. Are you sure?")) return;
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) return;

        const button = event.target.closest('button');
        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '...';

        try {
            const prompt = `Embellish this character concept into a rich description. CONCEPT: "${char.description}"`;
            const newDescription = await APIService.callAI(prompt);
            this.updateCharacterField(charId, 'description', newDescription);
            UIManager.openCharacterDetailModal(charId);
        } catch (error) {
            alert(`AI Error: ${error.message}`);
        } finally {
            button.disabled = false;
            button.innerHTML = originalContent;
        }
    },

    async generateModelInstructions(event, charId) {
        if (!confirm("This will overwrite the current model instructions. Are you sure?")) return;
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) return;

        const button = event.target.closest('button');
        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '...';

        const staticKnowledge = (state.static_entries || []).map(e => `### ${e.title}\n${e.content}`).join('\n\n');
        const prompt = `Based on the following character persona and world information, generate a concise set of model instructions for an AI roleplaying as this character. The instructions should guide the AI on how to speak, its personality, and key traits to embody.\n\n### Character Persona:\n${char.description}\n\n### World Static Knowledge:\n${staticKnowledge}\n\n### INSTRUCTIONS:`;

        try {
            const newInstructions = await APIService.callAI(prompt);
            this.updateCharacterField(charId, 'model_instructions', newInstructions);
            UIManager.openCharacterDetailModal(charId);
        } catch (e) {
            console.error("Instruction generation failed:", e);
            alert("Failed to generate instructions.");
        } finally {
            button.disabled = false;
            button.innerHTML = originalContent;
        }
    },

    async analyzeTurn(text) {
        const state = StateManager.getState();
        const locationNames = (state.worldMap?.grid || []).map(loc => loc.name);
        const locationList = locationNames.length > 0 ? `Valid locations are: [${locationNames.join(', ')}].` : 'No location data is available.';
        
        try {
            const prompt = `Analyze the text for sentiment and implied location. Respond with a valid JSON object like {"emotion": "...", "locationName": "..."}.
            - 'emotion' must be one of: neutral, happy, sad, angry, surprised.
            - 'locationName' must be one of the provided valid locations, or null if no specific location is mentioned or implied.
            ${locationList}
            TEXT: "${text}"`;
            
            const response = await APIService.callAI(prompt, true);
            const analysis = JSON.parse(response);

            const validEmotions = ['neutral', 'happy', 'sad', 'angry', 'surprised'];
            return {
                emotion: validEmotions.includes(analysis.emotion) ? analysis.emotion : 'neutral',
                locationName: locationNames.includes(analysis.locationName) ? analysis.locationName : null
            };
        } catch (error) {
            console.error("Sentiment/Location analysis failed:", error);
            return { emotion: 'neutral', locationName: null };
        }
    },
    
    addCharacter() { 
        const state = StateManager.getState();
        const aiCharCount = state.characters.filter(c => !c.is_user).length;
        const newColor = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
        const newChar = { 
            id: UTILITY.uuid(), name: "New Character", description: "", short_description: "A brief one-line summary.",
            model_instructions: "Act as {character}. Be descriptive and engaging.", image_url: "", extra_portraits: [], 
            tags: [], is_user: false, is_active: true, color: newColor 
        };
        state.characters.push(newChar); 
        StateManager.saveState(); 
        UIManager.renderCharacters();
        this.openModal('character-detail-modal', newChar.id);
    },

    deleteCharacter(id) { 
        const state = StateManager.getState();
        state.characters = state.characters.filter(c => c.id !== id);
        this.closeModal('character-detail-modal'); 
        this.saveAndRender(); 
    },

    updateCharacterField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === id); 
        if (char) { 
            char[field] = value; 
            StateManager.saveState(); 
            if (field === 'name') {
                UIManager.updateAICharacterSelector();
                const header = document.querySelector(`#character-detail-modal-content h2[data-char-id="${id}"]`);
                if(header) header.textContent = value;
            }
        } 
    }, 300),

    updateCharacterTags: debounce(function(id, value) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === id);
        if (char) {
            char.tags = value.split(',').map(t => t.trim()).filter(Boolean);
            StateManager.saveState();
            StateManager.updateTagCache();
        }
    }, 500),

    async generateTagsForCharacter(event, charId) {
        if (!confirm("This will add to the current tags. Are you sure?")) return;
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) return;

        const button = event.target.closest('button');
        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '...';

        const prompt = `Analyze the following character. Generate 3 to 5 relevant, one-word, comma-separated tags.\n\nCHARACTER: ${char.name}\nDESCRIPTION: ${char.description}`;
        try {
            const tagsString = await APIService.callAI(prompt);
            char.tags = (char.tags || []).concat(tagsString.split(',').map(t => t.trim().toLowerCase()));
            char.tags = [...new Set(char.tags)]; // remove duplicates
            StateManager.saveState();
            UIManager.openCharacterDetailModal(charId); // Re-render the modal to show new tags
            StateManager.updateTagCache();
        } catch (e) {
            console.error("Tag generation failed:", e);
            alert("Failed to generate tags.");
        } finally {
            button.disabled = false;
            button.innerHTML = originalContent;
        }
    },

    addExtraPortrait(charId) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char) { if(!char.extra_portraits) char.extra_portraits = []; char.extra_portraits.push({emotion: 'happy', url: ''}); StateManager.saveState(); UIManager.openCharacterDetailModal(charId); } },
    removeExtraPortrait(charId, index) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char && char.extra_portraits) { char.extra_portraits.splice(index, 1); StateManager.saveState(); UIManager.openCharacterDetailModal(charId); } },
    updateExtraPortrait: debounce(function(charId, index, field, value) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char && char.extra_portraits && char.extra_portraits[index]) { char.extra_portraits[index][field] = value; StateManager.saveState(); } }, 300),
    toggleCharacterActive(event, id) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === id); if (char) char.is_active = event.target.checked; StateManager.saveState(); UIManager.updateAICharacterSelector(); },
    
    addStaticEntry() { const state = StateManager.getState(); const newEntry = { id: UTILITY.uuid(), title: "New Static Entry", content: "" }; state.static_entries.push(newEntry); state.selectedStaticEntryId = newEntry.id; this.saveAndRenderStaticEntries(); },
    deleteStaticEntry(id) { const state = StateManager.getState(); state.static_entries = state.static_entries.filter(e => e.id !== id); if(state.selectedStaticEntryId === id) state.selectedStaticEntryId = null; this.saveAndRenderStaticEntries(); },
    selectStaticEntry(id) { StateManager.getState().selectedStaticEntryId = id; UIManager.renderStaticEntries(); },
    updateStaticEntryField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const entry = state.static_entries.find(e => e.id === id); 
        if (entry) { 
            entry[field] = value; 
            StateManager.saveState(); 
            if (field === 'title') {
                UIManager.renderStaticEntries();
            }
        } 
    }, 300),

    addDynamicEntry() { const state = StateManager.getState(); const newEntry = {id: UTILITY.uuid(), title: "New Dynamic Entry", triggers: "", content: "", triggered_at_turn: null }; state.dynamic_entries.push(newEntry); state.selectedDynamicEntryId = newEntry.id; this.saveAndRenderDynamicEntries(); },
    deleteDynamicEntry(id) { const state = StateManager.getState(); state.dynamic_entries = state.dynamic_entries.filter(e => e.id !== id); if(state.selectedDynamicEntryId === id) state.selectedDynamicEntryId = null; this.saveAndRenderDynamicEntries(); },
    selectDynamicEntry(id) { StateManager.getState().selectedDynamicEntryId = id; UIManager.renderDynamicEntries(); },
    updateDynamicEntryField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === id); 
        if (entry) { 
            entry[field] = value; 
            StateManager.saveState(); 
            if (field === 'title') {
                UIManager.renderDynamicEntries();
            }
        } 
    }, 300),

    addExampleDialogueTurn() {
        const state = StateManager.getState();
        const firstAiChar = state.characters.find(c => !c.is_user);
        if (!firstAiChar) {
            alert("Cannot add example dialogue without at least one AI character.");
            return;
        }
        state.chat_history.push({ character_id: firstAiChar.id, content: "New example dialogue.", type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(), isHidden: true });
        StateManager.saveState();
        UIManager.renderExampleDialogueModal();
    },
    deleteExampleDialogueTurn(originalIndex) {
        const state = StateManager.getState();
        state.chat_history.splice(originalIndex, 1);
        StateManager.saveState();
        UIManager.renderExampleDialogueModal();
    },
    updateExampleDialogueTurn: debounce(function(originalIndex, field, value) {
        const state = StateManager.getState();
        if (state.chat_history[originalIndex]) {
            state.chat_history[originalIndex][field] = value;
            StateManager.saveState();
        }
    }, 300),
    moveExampleDialogueTurn(originalIndex, direction) {
        const state = StateManager.getState();
        const history = state.chat_history;
        const itemToMove = history[originalIndex];
        if (!itemToMove) return;

        let swapIndex = -1;
        if (direction === 'up') {
            for (let i = originalIndex - 1; i >= 0; i--) { if (history[i].isHidden) { swapIndex = i; break; } }
        } else {
            for (let i = originalIndex + 1; i < history.length; i++) { if (history[i].isHidden) { swapIndex = i; break; } }
        }

        if (swapIndex !== -1) {
            const temp = history[swapIndex];
            history[swapIndex] = itemToMove;
            history[originalIndex] = temp;
            StateManager.saveState();
            UIManager.renderExampleDialogueModal();
        }
    },

    openViewRawPromptModal() {
        if (!StateManager.getLibrary().active_narrative_id) { alert("Please load a narrative from the Story Library first."); return; }
        const selectedCharId = document.getElementById('ai-character-selector').value;
        if (!selectedCharId) { alert("Please select an AI character from the dropdown first."); return; }
        const prompt = PromptBuilder.buildPrompt(selectedCharId);
        document.getElementById('raw-prompt-content').textContent = prompt;
        this.openModal('view-raw-prompt-modal');
    },

    copyMessage(index) {
        const state = StateManager.getState();
        const message = state.chat_history[index];
        if (!message) return;
        
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = message.content;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        try {
            document.execCommand('copy');
            const copyBtn = document.querySelector(`[data-message-index='${index}'] .action-btn-group button[title='Copy']`);
            if (copyBtn) {
                const originalIcon = copyBtn.innerHTML;
                copyBtn.innerHTML = `<span class="text-xs text-green-400">Copied!</span>`;
                setTimeout(() => { copyBtn.innerHTML = originalIcon; }, 1500);
            }
        } catch (err) {
            console.error('Failed to copy text: ', err);
        }
        document.body.removeChild(tempTextarea);
    },
    
    // --- World Map Functions ---
    async generateWorldMap() {
        if (!confirm("This will overwrite the existing world map and may incur API costs. Are you sure?")) {
            return;
        }
        const state = StateManager.getState();
        
        const btn = document.getElementById('generate-world-button');
        btn.disabled = true;
        btn.innerHTML = '...';

        try {
            const context = {
                characters: state.characters.map(c => `${c.name}: ${c.short_description}`).join('\n'),
                static: (state.static_entries || []).map(e => `* ${e.title}: ${e.content}`).join('\n'),
                dynamic: (state.dynamic_entries || []).map(e => `* ${e.title}: ${e.content}`).join('\n'),
                recent: (state.chat_history || []).filter(m => m.type === 'chat').slice(-3).map(m => m.content).join('\n---\n'),
            };
            const contextString = `CHARACTERS:\n${context.characters}\n\nSTATIC LORE:\n${context.static}\n\nDYNAMIC LORE:\n${context.dynamic}\n\nRECENT EVENTS:\n${context.recent}`;

            const prompt = `Based on the following story context, generate a genre-appropriate 8x8 grid of interconnected fantasy locations. The central location (4,4) should be a neutral starting point. Attempt to include locations mentioned in the context.
            CONTEXT:\n${contextString}\n\nRespond with a valid JSON object: { "grid": [ { "coords": {"x":int, "y":int}, "name": "string", "description": "string (one-line summary)", "prompt": "string (a rich, detailed paragraph for the AI)", "imageUrl": "" } ] }.
            The grid must contain exactly 64 locations.`;
            
            const response = await APIService.callAI(prompt, true);
            const newWorld = JSON.parse(response);
            if (newWorld.grid && newWorld.grid.length === 64) {
                state.worldMap.grid = newWorld.grid;
                state.worldMap.currentLocation = { x: 4, y: 4 };
                state.worldMap.destination = { x: null, y: null };
                state.worldMap.path = [];
                this.RUNTIME.selectedMapTile = null;
                StateManager.saveState();
                UIManager.renderWorldMapModal();
                UIManager.applyStyling(); 
            } else {
                throw new Error("Generated data is not a valid 64-item grid.");
            }
        } catch (e) {
            console.error("World Map generation failed:", e);
            alert("Failed to generate world map. The AI may have returned an invalid format.");
        } finally {
            btn.disabled = false;
            btn.innerHTML = UIManager.getAIGenIcon();
        }
    },

    moveToLocation(x, y) {
        const state = StateManager.getState();
        const targetLocation = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        if (targetLocation) {
            state.worldMap.currentLocation = { x, y };
            state.worldMap.path = [];
            state.worldMap.destination = { x: null, y: null };
            this.addSystemMessageToHistory(`You have moved to ${targetLocation.name}.`);
            this.RUNTIME.selectedMapTile = null;
            this.RUNTIME.pendingMove = null;
            StateManager.saveState();
            UIManager.applyStyling(); // Update background on move
            this.triggerAIResponse(); // Trigger a narrative response to the move
        }
    },
    
    selectMapTile(x, y) {
        const state = StateManager.getState();
        const tile = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        this.RUNTIME.selectedMapTile = tile || null;
        UIManager.renderWorldMapModal();
    },

    selectPendingMove(x, y) {
        this.RUNTIME.pendingMove = { x, y };
        UIManager.renderWorldMapModal();
    },

    confirmMove() {
        const state = StateManager.getState();
        const { pendingMove } = this.RUNTIME;
        const { currentLocation } = state.worldMap;

        if (pendingMove && (pendingMove.x !== currentLocation.x || pendingMove.y !== currentLocation.y)) {
            this.moveToLocation(pendingMove.x, pendingMove.y);
        }

        this.RUNTIME.pendingMove = null;
        this.closeModal('world-map-modal');
    },

    setDestination() {
        const state = StateManager.getState();
        const selected = this.RUNTIME.selectedMapTile;
        if (!selected) return;

        state.worldMap.destination = selected.coords;
        state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, selected.coords);
        StateManager.saveState();
        UIManager.renderWorldMapModal();
    },

    updateLocationDetail: debounce(function(field, value) {
        const state = StateManager.getState();
        const selected = this.RUNTIME.selectedMapTile;
        if (!selected) return;
        const locationInGrid = state.worldMap.grid.find(loc => loc.coords.x === selected.coords.x && loc.coords.y === selected.coords.y);
        if (locationInGrid) {
            locationInGrid[field] = value;
            StateManager.saveState();
        }
    }, 500),

    elevateNarrativeToScenario(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        const narrative = story.narratives.find(n => n.id === narrativeId);
        if (!story || !narrative) return;
        
        const firstMessage = narrative.state.chat_history.find(m => !m.isHidden && m.type === 'chat');

        const newScenario = {
            id: UTILITY.uuid(),
            name: `${narrative.name} (Scenario)`,
            message: firstMessage ? firstMessage.content : "The story continues...",
            static_entries: JSON.parse(JSON.stringify(narrative.state.static_entries || [])),
            worldMap: JSON.parse(JSON.stringify(narrative.state.worldMap || {})),
        };

        story.scenarios.push(newScenario);
        StateManager.saveLibrary();
        UIManager.openStoryDetails(storyId);
    },

    // --- Import / Export ---
    exportStory(storyId) { 
        const storyToExp = StateManager.getLibrary().stories.find(s => s.id === storyId);
        if (!storyToExp) return alert("Could not find story to export.");
        
        const storyName = storyToExp.name || 'Untitled_Story';
        const data = ImportExportService.formatStoryForExport(storyToExp);
        const blob = new Blob([data], {type: 'application/json'}); 
        const url = URL.createObjectURL(blob); 
        const a = document.createElement('a'); 
        a.href = url; a.download = `${storyName.replace(/ /g, '_')}.json`; 
        a.click(); 
        URL.revokeObjectURL(url); 
    },
    importStory(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const newStory = ImportExportService.parseStoryFile(e.target.result);
                const library = StateManager.getLibrary();
                library.stories.push(newStory);
                StateManager.updateTagCache();
                StateManager.saveLibrary();
                UIManager.renderLibraryInterface();
                alert(`'${newStory.name}' imported successfully!`);
            } catch (err) {
                alert(`Error importing: ${err.message}`);
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    },
    importBYAF() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.zip,.byaf';
        input.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const newStory = await ImportExportService.parseBYAF(e.target.result, file.name);
                    const library = StateManager.getLibrary();
                    library.stories.push(newStory);
                    this.updateSearchIndex(newStory);
                    StateManager.updateTagCache();
                    StateManager.saveLibrary();
                    alert(`'${newStory.name}' imported successfully! Loading now.`);
                    const newNarrative = newStory.narratives[0];
                    this.loadNarrative(newStory.id, newNarrative.id);
                } catch (err) {
                    alert(`Error importing BYAF file: ${err.message}`);
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
        };
        input.click();
    },
    exportLibrary() {
        const data = ImportExportService.formatLibraryForExport(StateManager.getLibrary());
        const blob = new Blob([data], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ai_storyteller_library_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    },
    importLibrary(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            if (!confirm('WARNING: This will replace your entire story library. Are you sure you want to continue?')) {
                return;
            }
            try {
                const importedLibrary = ImportExportService.parseLibraryFile(e.target.result);
                StateManager.data.library = importedLibrary; // Directly replace library
                StateManager.saveLibrary();
                window.location.reload();
            } catch (err) {
                alert(`Error importing library: ${err.message}`);
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    },
    
    // --- Helper & Utility Actions ---
    _ensureCharacterColors() {
        const state = StateManager.getState();
        if (!state || !state.characters) return;
        let aiCharCount = 0;
        state.characters.forEach(char => {
            if (!char.is_user) {
                 if (!char.color) {
                    char.color = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
                }
                aiCharCount++;
            }
        });
    },

    saveAndRender() { StateManager.saveState(); UIManager.renderAll(); },
    saveAndRenderStaticEntries() { StateManager.saveState(); UIManager.renderStaticEntries(); },
    saveAndRenderDynamicEntries() { StateManager.saveState(); UIManager.renderDynamicEntries(); },
};

/**
 * =================================================================================================
 * app Module (The Initializer)
 * =================================================================================================
 * This is the main entry point of the application. It initializes all the other modules
 * and sets up the initial event listeners.
 */
const app = {
    init() {
        StateManager.loadLibrary();
        const library = StateManager.getLibrary();

        if (library.stories.length === 0) {
            Controller.createDefaultStoryAndNarrative();
            return;
        }

        StateManager.loadActiveNarrative();
        const state = StateManager.getState();
        
        if (!state || Object.keys(state).length === 0) { 
            const activeStory = library.stories.find(s => s.id === library.active_story_id);
             document.getElementById('story-title-input').value = activeStory ? activeStory.name : "No Story Loaded";
             document.getElementById('mobile-story-title-overlay').value = activeStory ? activeStory.name : "No Story Loaded";
             UIManager.renderChat();
        } else {
            Controller._ensureCharacterColors();
            UIManager.applyStyling();
            UIManager.renderAll();
        }
        
        this.setupEventListeners();
    },
    
    setupEventListeners() {
        const library = StateManager.getLibrary();
        this.updateLayout();
        window.addEventListener('resize', debounce(() => this.updateLayout(), 100));

        const storyTitleInput = document.getElementById('story-title-input');
        storyTitleInput.addEventListener('input', debounce((e) => {
            Controller.renameStory(library.active_story_id, e.target.value);
        }, 500));
        
        const mobileStoryTitleInput = document.getElementById('mobile-story-title-overlay');
        mobileStoryTitleInput.addEventListener('input', debounce((e) => {
             Controller.renameStory(library.active_story_id, e.target.value);
        }, 500));

        const hamburgerBtn = document.getElementById('hamburger-menu-button');
        if (hamburgerBtn) {
            hamburgerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                Controller.toggleMobileMenu();
            });
        }
        
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('mobile-menu');
            const btn = document.getElementById('hamburger-menu-button');
            if (menu && !menu.classList.contains('hidden') && !menu.contains(e.target) && !btn.contains(e.target)) {
                Controller.toggleMobileMenu();
            }
        });

        // Mobile Title Overlay Logic
        const titleTrigger = document.getElementById('title-trigger-area');
        const mobileTitle = document.getElementById('mobile-story-title-overlay');
        
        const showTitle = () => {
            if(document.body.classList.contains('layout-vertical')) {
                clearTimeout(UIManager.RUNTIME.titleTimeout);
                mobileTitle.style.opacity = '1';
            }
        };
        const hideTitle = (immediate = false) => {
             if(document.body.classList.contains('layout-vertical')) {
                clearTimeout(UIManager.RUNTIME.titleTimeout);
                if (document.activeElement !== mobileTitle) {
                    if (immediate) {
                         mobileTitle.style.opacity = '0';
                    } else {
                        UIManager.RUNTIME.titleTimeout = setTimeout(() => { mobileTitle.style.opacity = '0'; }, 2500);
                    }
                }
            }
        };
        titleTrigger.addEventListener('mouseenter', showTitle);
        titleTrigger.addEventListener('mouseleave', () => hideTitle());
        titleTrigger.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (mobileTitle.style.opacity === '1') {
                hideTitle(true);
            } else {
                showTitle();
                hideTitle();
            }
        });

        // Correctly bind chat control buttons
        document.getElementById('primary-action-btn').addEventListener('click', () => Controller.handlePrimaryAction());
        document.getElementById('regen-btn').addEventListener('click', () => Controller.handleRegen());
        document.getElementById('undo-btn').addEventListener('click', () => Controller.undoLastTurn());
    },
    
    updateLayout() {
        if (window.innerHeight > window.innerWidth) {
            document.body.classList.add('layout-vertical');
            document.body.classList.remove('layout-horizontal');
        } else {
            document.body.classList.add('layout-horizontal');
            document.body.classList.remove('layout-vertical');
        }
         UIManager.updateSidePortrait();
    },
};

// Start the application once the DOM is fully loaded.
document.addEventListener('DOMContentLoaded', () => app.init());


	</script>
    
</body>
</html>
