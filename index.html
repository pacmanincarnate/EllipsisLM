<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI Chat</title>
    
    <!-- PWA and iOS Home Screen Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AI Storyteller">
    <link rel="apple-touch-icon" href="https://storage.googleapis.com/pai-images/22e56a81615f4e6691238e2124c6536b.png">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- JSZip for BYAF import -->
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    
    <!-- Marked.js for Markdown Support -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;1,400&family=EB+Garamond:ital,wght@0,400;1,400&family=Inter:wght@400;500;700&family=Lora:ital,wght@0,400;1,400&family=Roboto+Slab:wght@400;700&family=Source+Code+Pro:ital,wght@0,400;1,400&display=swap" rel="stylesheet">

    <style>
        /* --- General Layout & Theme --- */
        :root {
            --font-primary: 'Inter', sans-serif;
            --text-primary: #e5e7eb;
            --text-secondary: #cbd5e1;
            --text-accent: #a5b4fc;
            
            --surface-glass: rgba(17, 24, 39, 0.15);
            --surface-card: rgba(55, 65, 81, 0.6);
            --surface-overlay: rgba(0, 0, 0, 0.7);
            
            --border-primary: rgba(75, 85, 99, 0.8);
            --brand-color: #6366f1; /* Indigo */
            --brand-color-toggle: #4f46e5;
            
            --scrollbar-thumb: #4b5563;
            
            --border-radius-md: 0.75rem;
            --border-radius-sm: 4px;
            
            --transition-fast: 0.2s ease-in-out;
            --transition-medium: 0.4s ease-out;
            --transition-slow: 0.5s ease-in-out;
        }

        body { 
            font-family: var(--font-primary); 
            color: var(--text-primary); 
        }

        .glass-bg { 
            background-color: var(--surface-glass); 
            backdrop-filter: blur(5px); 
        }

        /* --- Scrollbar Styling --- */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { 
            background: var(--scrollbar-thumb); 
            border-radius: var(--border-radius-sm); 
        }
        
        /* --- Component Styling --- */
        .character-card { 
            background-color: var(--surface-card); 
            backdrop-filter: blur(4px); 
            border: 1px solid var(--border-primary); 
            border-radius: var(--border-radius-md); 
        }

        .modal-overlay { 
            background-color: var(--surface-overlay); 
        }

        .toggle-bg:after { 
            content: ''; 
            position: absolute; 
            top: 0.125rem; 
            left: 0.125rem; 
            background-color: white; 
            border-radius: 9999px; 
            height: 1.25rem; 
            width: 1.25rem; 
            transition: transform var(--transition-fast); 
        }

        input:checked + .toggle-bg { 
            background-color: var(--brand-color-toggle); 
        }

        input:checked + .toggle-bg:after { 
            transform: translateX(100%); 
        }

        /* --- Chat Components --- */
        #chat-window h1, 
        #chat-window h2, 
        #chat-window h3 { 
            font-weight: bold; 
            margin-bottom: 0.5rem; 
        }
        #chat-window h1 { font-size: 1.5em; } 
        #chat-window h2 { font-size: 1.25em; } 
        #chat-window h3 { font-size: 1.1em; }
        
        #chat-window blockquote {
            border-left: 3px solid var(--brand-color);
            padding-left: 1rem;
            margin: 0.5rem 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        #chat-window em {
            color: var(--text-accent);
            font-style: italic;
        }

        /* --- Hover & Animation Effects --- */
        .chat-bubble-container:hover .action-btn-group,
        .chat-bubble-container:hover .timestamp { 
            opacity: 1; 
        }
        
        .action-btn-group, .timestamp { 
            opacity: 0; 
            transition: opacity var(--transition-fast);
        }

        #character-portrait-container img { 
            transition: opacity var(--transition-slow); 
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-bubble-container.new-message {
            animation: fadeIn var(--transition-medium);
        }

        /* --- Layout Management & Responsiveness --- */
        #chat-window-container {
            display: flex;
            justify-content: center;
            align-items: center; /* Vertically center content when not in float mode */
        }

        #chat-window {
            width: 100%;
            max-width: 1500px;
        }

        /* Hide the portrait container by default on medium+ screens to ensure chat is centered. */
        @media (min-width: 768px) {
            #character-portrait-container {
                display: none;
            }
        }

        @media (min-width: 1024px) {
            /* For floating portrait mode on large screens, override the above styles */
            body[data-mode="floating_portrait"] #chat-window-container {
                justify-content: space-between;
                align-items: stretch; /* Override vertical centering for float mode */
            }
            body[data-mode="floating_portrait"] #chat-window {
                max-width: none;
            }
            body[data-mode="floating_portrait"] #character-portrait-container {
                /* Show the container and make it a flex item */
                display: flex;
            }
        }
    </style>
</head>
<body data-mode="none" class="bg-gray-900 min-h-screen flex flex-col">
    <!-- Background Image Container -->
    <div id="global-background" class="fixed inset-0 -z-10 bg-gray-900 bg-cover bg-center transition-all duration-500"></div>

    <!-- Main Application Container -->
    <div class="w-full h-screen p-2 md:p-6 lg:p-8 flex flex-col glass-bg">
        
        <!-- Header -->
        <header class="mb-4 flex justify-between items-center">
            <!-- Desktop Header -->
            <div class="hidden md:flex justify-between items-center w-full">
                <input type="text" id="story-title-input" class="text-2xl font-bold bg-transparent text-white p-1 rounded focus:outline-none focus:bg-black/20 w-1/2">
                <div class="flex space-x-2">
                     <button onclick="app.openModal('story-library-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Story Library"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path><path d="M4 6h16M4 12h16M4 18h7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M18 18v-6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M15 12h6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button>
                     <button onclick="app.openModal('characters-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Characters"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21a6 6 0 00-9-5.197m0 0A5.965 5.965 0 0112 13a5.965 5.965 0 013 1.803"></path></svg></button>
                     <button onclick="app.openModal('knowledge-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Knowledge"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253z"></path></svg></button>
                     <button onclick="app.openModal('settings-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Settings"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg></button>
                </div>
            </div>

            <!-- Mobile Header -->
            <div class="md:hidden flex justify-between items-center w-full">
                <h1 id="story-title-mobile" class="text-xl font-bold text-white truncate px-2"></h1>
                <div class="relative">
                    <button id="hamburger-menu-button" class="bg-gray-700/80 hover:bg-gray-600/80 text-white p-2 rounded-lg">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                    </button>
                    <div id="mobile-menu" class="hidden absolute right-0 mt-2 w-48 bg-gray-800/90 backdrop-blur-md rounded-lg shadow-xl z-50">
                        <a href="#" onclick="app.openModal('story-library-modal'); app.toggleMobileMenu(); return false;" class="block px-4 py-2 text-white hover:bg-gray-700">Story Library</a>
                        <a href="#" onclick="app.openModal('characters-modal'); app.toggleMobileMenu(); return false;" class="block px-4 py-2 text-white hover:bg-gray-700">Characters</a>
                        <a href="#" onclick="app.openModal('knowledge-modal'); app.toggleMobileMenu(); return false;" class="block px-4 py-2 text-white hover:bg-gray-700">Knowledge</a>
                        <a href="#" onclick="app.openModal('settings-modal'); app.toggleMobileMenu(); return false;" class="block px-4 py-2 text-white hover:bg-gray-700">Settings</a>
                    </div>
                </div>
            </div>
        </header>
        <!-- /Header -->

        <!-- Main Content Area -->
        <main class="flex-grow min-h-0 flex flex-col">
             <!-- Chat Window & Portrait -->
             <div id="chat-window-container" class="relative flex-grow flex min-h-0 mb-4 bg-black/30 rounded-lg overflow-hidden">
                <div id="cinematic-overlay-bg" class="absolute inset-0 bg-contain bg-no-repeat bg-left-center transition-opacity duration-1000 opacity-20 pointer-events-none" style="mask-image: linear-gradient(to right, black 60%, transparent 100%);"></div>
                <div id="chat-window" class="relative z-10 flex-grow p-4 overflow-y-auto"></div>
                <div id="character-portrait-container" class="hidden md:flex flex-shrink-0 w-1/3 pl-4 flex-col justify-center items-center"></div>
             </div>
             <!-- /Chat Window & Portrait -->
             
             <!-- Chat Input & Controls -->
             <div id="chat-input-container" class="flex items-start space-x-4">
                 <textarea id="chat-input" class="flex-grow bg-black/30 border border-gray-600 rounded-lg p-2 resize-none" placeholder="Enter your message, or tap '→' to have AI write for you..." rows="4"></textarea>
                 <div class="flex flex-col space-y-2">
                     <select id="ai-character-selector" class="bg-black/30 border border-gray-600 rounded-lg p-2 w-full mb-2"></select>
                     <div class="grid grid-cols-3 gap-2">
                         <button onclick="app.handlePrimaryAction()" class="bg-indigo-600/80 hover:bg-indigo-700/80 text-white font-bold py-2 px-3 rounded-lg text-2xl" title="Send / Write for Me">→</button>
                         <button onclick="app.handleRegen()" class="bg-sky-600/80 hover:bg-sky-700/80 text-white font-bold py-2 px-3 rounded-lg text-2xl" title="Regenerate / New Response">↻</button>
                         <button onclick="app.undoLastTurn()" class="bg-gray-600/80 hover:bg-gray-500/80 text-white font-bold py-2 px-3 rounded-lg text-2xl" title="Undo">↺</button>
                     </div>
                      <button onclick="app.checkWorldInfoAgent()" class="bg-purple-600/80 hover:bg-purple-700/80 text-white font-bold py-2 px-3 rounded-lg w-full text-sm mt-2">Update World Info</button>
                 </div>
             </div>
             <!-- /Chat Input & Controls -->
        </main>
        <!-- /Main Content Area -->

    </div>
    <!-- /Main Application Container -->

    <!-- Modals -->
    <!-- Story Library Modal -->
    <div id="story-library-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('story-library-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700 flex justify-between items-center"><h2 class="text-2xl font-semibold">Story Library</h2><div><button onclick="app.importBYAF()" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg mr-2">Import BYAF</button><button onclick="app.createNewStory()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Create New Story</button></div></div><div id="library-content-container" class="flex-grow flex min-h-0"></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-between items-center flex-wrap gap-2"><div class="flex space-x-2"><button onclick="app.exportStory()" class="bg-green-600/80 hover:bg-green-700/80 font-bold py-2 px-4 rounded-lg">Export Story</button><button onclick="document.getElementById('import-story-file').click()" class="bg-blue-600/80 hover:bg-blue-700/80 font-bold py-2 px-4 rounded-lg">Import Story</button><input type="file" id="import-story-file" class="hidden" accept=".json" onchange="app.importStory(event)"></div><div class="flex space-x-2"><button onclick="app.exportLibrary()" class="bg-teal-600/80 hover:bg-teal-700/80 font-bold py-2 px-4 rounded-lg">Save Library</button><button onclick="document.getElementById('import-library-file').click()" class="bg-cyan-600/80 hover:bg-cyan-700/80 font-bold py-2 px-4 rounded-lg">Replace Library</button><input type="file" id="import-library-file" class="hidden" accept=".json" onchange="app.importLibrary(event)"></div><button onclick="app.closeModal('story-library-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button></div></div></div>
    
    <!-- Story Details Modal (for mobile view) -->
    <div id="story-details-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('story-details-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[90vh]"><div id="story-details-content-mobile" class="flex-grow flex flex-col min-h-0"></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="app.closeModal('story-details-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Back to Library</button></div></div></div>
    
    <!-- Characters Modal -->
    <div id="characters-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('characters-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700 flex justify-between items-center"><h2 class="text-2xl font-semibold">Character Roster</h2><button onclick="app.addCharacter()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Character</button></div><div class="p-6 overflow-y-auto"><div id="characters-container" class="grid grid-cols-1 md:grid-cols-2 gap-6"></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="app.closeModal('characters-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>
    
    <!-- Knowledge Modal (World & Lore) -->
    <div id="knowledge-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('knowledge-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 pb-0 flex justify-between items-center border-b border-gray-700"><div class="flex"><button id="knowledge-tab-world" onclick="app.switchKnowledgeTab('world')" class="py-3 px-4 font-semibold text-lg border-b-2 border-indigo-500 text-white">World</button><button id="knowledge-tab-lore" onclick="app.switchKnowledgeTab('lore')" class="py-3 px-4 font-semibold text-lg border-b-2 border-transparent text-gray-400 hover:text-white">Lore</button></div><button id="knowledge-add-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg ml-4 flex-shrink-0">Add Entry</button></div><div class="p-6 overflow-y-auto flex-grow"><div id="knowledge-world-content"><div id="world-info-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full"><div id="world-info-list" class="md:col-span-1 bg-black/30 rounded-lg p-4 overflow-y-auto"></div><div id="world-info-details" class="md:col-span-2 bg-black/30 rounded-lg p-4"><div id="world-info-details-content" class="h-full"><div class="text-gray-400 flex items-center justify-center h-full">Select a world info entry.</div></div></div></div></div><div id="knowledge-lore-content" class="hidden"><div id="lorebook-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full"><div id="lorebook-list" class="md:col-span-1 bg-black/30 rounded-lg p-4 overflow-y-auto"></div><div id="lorebook-details" class="md:col-span-2 bg-black/30 rounded-lg p-4"><div id="lorebook-details-content" class="h-full"><div class="text-gray-400 flex items-center justify-center h-full">Select a lorebook entry.</div></div></div></div></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="app.closeModal('knowledge-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>
        
    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('settings-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[90vh]"><div class="p-6 pb-0 border-b border-gray-700"><h2 class="text-2xl font-semibold mb-4">Settings</h2><div class="flex -mb-px"><button id="settings-tab-appearance" onclick="app.switchSettingsTab('appearance')" class="py-2 px-4 font-semibold border-b-2 border-indigo-500 text-white">Appearance</button><button id="settings-tab-prompt" onclick="app.switchSettingsTab('prompt')" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white">Prompt</button><button id="settings-tab-model" onclick="app.switchSettingsTab('model')" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white">Model</button></div></div><div class="p-6 overflow-y-auto flex-grow"><div id="settings-appearance-content" class="space-y-6"><div><div class="grid grid-cols-2 gap-4"><div><label for="font-selector" class="text-gray-400 text-sm block mb-2">Chat Font</label><select id="font-selector" class="w-full bg-black/30 border-gray-600 rounded-lg p-2"><option value="'Inter', sans-serif">Inter (Sans-Serif)</option><option value="'Lora', serif">Lora (Serif)</option><option value="'Roboto Slab', serif">Roboto Slab</option><option value="'EB Garamond', serif">EB Garamond</option><option value="'Cormorant Garamond', serif">Cormorant Garamond</option><option value="'Source Code Pro', monospace">Source Code Pro</option></select></div><div><label for="chat-text-color" class="text-gray-400 text-sm block mb-2">Chat Text Color</label><input type="color" id="chat-text-color" class="w-full bg-black/30 border-gray-600 rounded-lg p-1 h-10"></div></div><label for="background-image-url" class="text-gray-400 text-sm block mt-4 mb-2">Background Image URL</label><input type="text" id="background-image-url" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="https://example.com/image.png"><label for="bubble-opacity-slider" class="text-gray-400 text-sm block mt-4 mb-2">Chat Bubble Opacity</label><div class="flex items-center space-x-4"><input type="range" id="bubble-opacity-slider" class="w-full" min="0" max="1" step="0.05"><span id="bubble-opacity-value" class="text-sm text-gray-400 w-12 text-right"></span></div><label for="character-image-display" class="text-gray-400 text-sm block mt-4 mb-2">Character Image Display</label><div class="flex space-x-4" id="character-image-display"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="none"><span>None</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="floating_portrait"><span>Floating</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="cinematic_overlay"><span>Cinematic</span></label></div></div></div><div id="settings-prompt-content" class="hidden space-y-6"><div><h3 class="text-lg font-medium mb-2">System Prompt</h3><p class="text-gray-400 text-sm mb-2">Guide the AI's style, atmosphere, and response format.</p><textarea id="system-prompt-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2 resize-y" rows="4"></textarea></div><hr class="border-gray-700"><div><h3 class="text-lg font-medium mb-2">Event Master Prompt</h3><p class="text-gray-400 text-sm mb-2">Define the base instruction for the Event Master, which injects surprise events.</p><textarea id="event-master-prompt-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2 resize-y" rows="4"></textarea></div><hr class="border-gray-700"><button onclick="app.openViewRawPromptModal()" class="bg-gray-600/80 hover:bg-gray-500/80 text-white font-bold py-2 px-4 rounded-lg">View Raw Prompt</button></div><div id="settings-model-content" class="hidden space-y-6"><div><h3 class="text-lg font-medium mb-2">AI Provider</h3><div class="flex space-x-4"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="gemini" onchange="app.setApiProvider('gemini')"><span>Gemini</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="openrouter" onchange="app.setApiProvider('openrouter')"><span>OpenRouter</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="koboldcpp" onchange="app.setApiProvider('koboldcpp')"><span>KoboldCPP</span></label></div></div><div id="gemini-settings"><h3 class="text-lg font-medium">Gemini API Settings</h3><p class="text-gray-400 text-sm mb-2">Required for text generation.</p><input type="password" id="gemini-api-key-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="Enter Gemini API key"></div><div id="openrouter-settings"><h3 class="text-lg font-medium">OpenRouter API Settings</h3><p class="text-gray-400 text-sm mb-2">Your key and the model name.</p><input type="password" id="openrouter-api-key-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="Enter OpenRouter API key"><input type="text" id="openrouter-model-input" class="mt-2 w-full bg-black/30 border-gray-600 rounded-lg p-2" placeholder="Enter model name"></div><div id="koboldcpp-settings"><h3 class="text-lg font-medium">KoboldCPP Settings</h3><p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure your local server is running with the <strong>--cors</strong> flag.</p><div><label for="koboldcpp-template-selector" class="text-gray-400 text-sm block mb-2">Prompt Template</label><select id="koboldcpp-template-selector" class="w-full bg-black/30 border-gray-600 rounded-lg p-2"><option value="none">None (Raw Text)</option><option value="mistral">Mistral</option><option value="chatml">ChatML</option><option value="alpaca">Alpaca</option></select></div><div><label for="koboldcpp-min-p-slider" class="text-gray-400 text-sm block mt-4 mb-2">Min P</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-min-p-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-min-p-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div><div><label for="koboldcpp-dry-slider" class="text-gray-400 text-sm block mt-4 mb-2">DRY (Repetition Penalty)</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-dry-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-dry-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div></div></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="app.closeModal('settings-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>
    
    <!-- AI Enhance Modal -->
    <div id="ai-enhance-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('ai-enhance-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl p-6 w-11/12 md:w-1/2 lg:w-1/3 relative"><h3 class="text-xl font-bold mb-4">Enhance with AI</h3><textarea id="modal-input" class="w-full bg-black/30 border-gray-600 rounded-lg p-2" rows="4"></textarea><div class="mt-6 flex justify-end space-x-4"><button onclick="app.closeModal('ai-enhance-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button><button id="modal-confirm-button" class="bg-indigo-600 hover:bg-indigo-700 font-bold py-2 px-4 rounded-lg">Generate</button></div></div></div>
    
    <!-- Edit Response Modal -->
    <div id="edit-response-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('edit-response-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700"><h3 class="text-xl font-bold">Edit Response</h3></div><div class="p-6 flex-grow"><textarea id="edit-modal-input" class="w-full h-full bg-gray-900 border-gray-700 rounded-lg p-2 resize-none"></textarea></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4"><button onclick="app.closeModal('edit-response-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button><button id="edit-modal-save-button" class="bg-indigo-600 hover:bg-indigo-700 font-bold py-2 px-4 rounded-lg">Save</button></div></div></div>
    
    <!-- View Raw Prompt Modal -->
    <div id="view-raw-prompt-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="app.closeModal('view-raw-prompt-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Raw Prompt</h2></div><div class="p-6 overflow-y-auto flex-grow bg-gray-900"><pre id="raw-prompt-content" class="text-sm whitespace-pre-wrap"></pre></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="app.closeModal('view-raw-prompt-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>
    <!-- /Modals -->

    <script>
    // Utility function to prevent a function from being called too frequently.
    const debounce = (func, wait) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; };

    const app = {
        // SECTION: APP STRUCTURE
        // =================================================================================================
        // Centralized constants to avoid "magic strings" and for easy configuration.
        CONSTANTS: {
            LIBRARY_KEY: 'aiStorytellerLibrary',
            CHARACTER_COLORS: [
                { base: '#134e4a', bold: '#2dd4bf' }, // Teal
                { base: '#1e3a8a', bold: '#60a5fa' }, // Blue
                { base: '#581c87', bold: '#f472b6' }, // Fuchsia
                { base: '#78350f', bold: '#fbbf24' }, // Amber
                { base: '#365314', bold: '#a3e635' }, // Lime
                { base: '#5b21b6', bold: '#a78bfa' }, // Violet
                { base: '#881337', bold: '#fb7185' }, // Rose
                { base: '#155e75', bold: '#22d3ee' }  // Cyan
            ]
        },

        // Holds the entire library of stories, saved to localStorage.
        library: { 
            active_story_id: null, 
            stories: [], 
            tag_cache: [] 
        },
        
        // Holds the state of the *currently active* story. This is the object that gets modified during play.
        state: {}, 

        // Holds temporary, non-persistent properties related to the app's runtime behavior.
        RUNTIME: {
            carousel_interval: null,
            streamingInterval: null,
            activeKnowledgeTab: 'world',
            activeSettingsTab: 'appearance',
        },
        
        // A placeholder for caching frequently accessed DOM elements to improve performance.
        DOM: {}, 

        // SECTION: INITIALIZATION
        // =================================================================================================
        /**
         * The main entry point of the application.
         * Initializes the app by loading data, setting up the UI, and attaching event listeners.
         */
        init() {
            // Step 1: Load the entire story library from localStorage.
            this.loadLibrary();

            // Step 2: Determine and load the currently active story into the main `app.state`.
            this.loadActiveStory();
            
            // Step 3: Check if an active story was successfully loaded.
            if (!this.state) { 
                console.log("No active story found, creating a new one.");
                this.createNewStory(false); 
            } else {
                this._ensureCharacterColors();
                this.applyStyling();
                this.renderAll();
                this.setupEventListeners();
            }
        },
        
        // SECTION: LIBRARY & STATE MANAGEMENT
        // =================================================================================================
        loadLibrary() {
            const savedLibraryJSON = localStorage.getItem(this.CONSTANTS.LIBRARY_KEY);
            if (savedLibraryJSON) {
                try {
                    const parsedLibrary = JSON.parse(savedLibraryJSON);
                    this.library = parsedLibrary;
                    if (!this.library.tag_cache) {
                        this.library.tag_cache = [];
                    }
                } catch (error) {
                    console.error("Failed to parse library from localStorage. It might be corrupted.", error);
                    this.library = { active_story_id: null, stories: [], tag_cache: [] };
                }
            } else {
                this.library = { active_story_id: null, stories: [], tag_cache: [] };
            }
        },

        saveLibrary() {
            localStorage.setItem(this.CONSTANTS.LIBRARY_KEY, JSON.stringify(this.library));
        },

        loadActiveStory() {
            if (this.library.stories.length === 0) {
                this.state = null;
                return;
            }
            
            let activeStory = this.library.stories.find(s => s.id === this.library.active_story_id);

            if (!activeStory) {
                activeStory = this.library.stories.sort((a,b) => new Date(b.last_modified) - new Date(a.last_modified))[0];
                this.library.active_story_id = activeStory ? activeStory.id : null;
            }
            
            if (activeStory) {
                this.state = activeStory.state;
            } else {
                this.state = null;
            }
        },

        saveState() {
            const activeStory = this.library.stories.find(s => s.id === this.library.active_story_id);
            if (activeStory) {
                activeStory.state = this.state;
                activeStory.last_modified = new Date().toISOString();
                this.updateSearchIndex(activeStory);
                this.saveLibrary();
            }
        },

        createNewStory(reload = true) {
            const newStoryState = this.getDefaultState();
            const newStory = {
                id: this.uuid(),
                name: "New Story",
                last_modified: new Date().toISOString(),
                created_date: new Date().toISOString(),
                creator_notes: "",
                tags: [],
                search_index: "new story",
                state: newStoryState
            };
            this.library.stories.push(newStory);
            this.library.active_story_id = newStory.id;
            this.saveLibrary();

            if (reload) {
                window.location.reload();
            } else {
                this.state = newStoryState;
                this.applyStyling();
                this.renderAll();
                this.setupEventListeners();
            }
        },
        
        // --- Modular Default State Generators ---
        _getDefaultApiSettings() {
            return {
                apiProvider: 'gemini',
                geminiApiKey: '',
                openRouterKey: '',
                openRouterModel: 'google/gemini-flash-1.5',
                koboldcpp_url: 'http://localhost:5001',
                koboldcpp_template: 'none',
                koboldcpp_min_p: 0.1,
                koboldcpp_dry: 0.25,
            };
        },

        _getDefaultUiSettings() {
            return {
                font: "'Inter', sans-serif",
                backgroundImageURL: '',
                bubbleOpacity: 0.85,
                chatTextColor: '#e5e7eb',
                characterImageMode: 'none',
            };
        },
        
        _getDefaultSystemPrompts() {
            return {
                system_prompt: 'You are a master storyteller. Follow instructions precisely.',
                event_master_base_prompt: 'You are a secret Event Master. Read the chat. Generate a brief, secret instruction for AI characters to introduce a logical but unexpected event.',
                event_master_prompt: '', 
            };
        },

        _getDefaultStoryContent() {
            const narratorColor = this.CONSTANTS.CHARACTER_COLORS[0];
            return {
                characters: [
                    { id: this.uuid(), name: "You", description: "The protagonist.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[] }, 
                    { id: this.uuid(), name: "Narrator", description: "Describes the world.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: narratorColor }
                ], 
                world_info: [{ id: this.uuid(), title: "World Overview", content: "A high-fantasy world." }], 
                lorebook_entries: [{id: this.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content: "This is a sample dynamic lore entry.", triggered_at_turn: null }],
                chat_history: [], 
                messageCounter: 0, 
                selectedWorldInfoId: null,
                selectedLorebookId: null,
            };
        },

        getDefaultState() {
            return {
                ...this._getDefaultApiSettings(),
                ...this._getDefaultUiSettings(),
                ...this._getDefaultSystemPrompts(),
                ...this._getDefaultStoryContent(),
            }
        },
        
        // --- Other Library Functions ---
        loadStory(storyId) {
            this.library.active_story_id = storyId;
            this.saveLibrary();
            window.location.reload();
        },
        deleteStory(storyId) {
            this.library.stories = this.library.stories.filter(s => s.id !== storyId);
            this.updateTagCache();

            if (this.library.active_story_id === storyId) {
                if (this.library.stories.length > 0) {
                    this.library.active_story_id = this.library.stories.sort((a,b) => new Date(b.last_modified) - new Date(a.last_modified))[0].id;
                } else {
                    this.library.active_story_id = null;
                }
                this.saveLibrary();
                window.location.reload();
            } else {
                this.saveLibrary();
                this.renderLibraryInterface();
            }
        },
        renameStory(storyId, newName) {
            const story = this.library.stories.find(s => s.id === storyId);
            if(story) {
                story.name = newName;
                this.saveLibrary();
                this.renderLibraryInterface();
                if (story.id === this.library.active_story_id) {
                    document.getElementById('story-title-input').value = newName;
                    const mobileTitle = document.getElementById('story-title-mobile');
                    if (mobileTitle) mobileTitle.textContent = newName;
                }
            }
        },
        duplicateStory(storyId) {
            const originalStory = this.library.stories.find(s => s.id === storyId);
            if (!originalStory) return;

            const newState = JSON.parse(JSON.stringify(originalStory.state));
            const newStory = {
                id: this.uuid(),
                name: `${originalStory.name || 'Untitled Story'} (Copy)`,
                last_modified: new Date().toISOString(),
                created_date: new Date().toISOString(),
                creator_notes: originalStory.creator_notes || "",
                tags: [...(originalStory.tags || [])],
                state: newState
            };
            this.updateSearchIndex(newStory);
            this.library.stories.push(newStory);
            this.saveLibrary();
            this.renderLibraryInterface();
        },
        updateSearchIndex(story) {
            if (!story) return;
            let index = [story.name];
            if (story.tags) index.push(...story.tags);
            if (story.state && story.state.characters) {
                story.state.characters.forEach(char => {
                    index.push(char.name);
                    index.push(char.description);
                    if (char.tags) index.push(...char.tags);
                });
            }
            story.search_index = index.join(' ').toLowerCase();
        },
        updateTagCache() {
            const allTags = new Set();
            this.library.stories.forEach(story => {
                if (story.tags) story.tags.forEach(tag => allTags.add(tag));
                if (story.state && story.state.characters) {
                    story.state.characters.forEach(char => {
                        if (char.tags) char.tags.forEach(tag => allTags.add(tag));
                    });
                }
            });
            this.library.tag_cache = Array.from(allTags).sort();
            this.saveLibrary();
        },
        
        // SECTION: EVENT LISTENERS & UI SETUP
        // =================================================================================================
        setupEventListeners() {
            const setListener = (id, key, callback) => { 
                const input = document.getElementById(id); 
                if (!input) return;
                input.value = this.state[key]; 
                const debouncedCallback = debounce(function(e) { 
                    this.state[key] = e.target.value; 
                    this.saveState();
                    if(callback) callback();
                }.bind(this), 500);
                input.addEventListener('input', debouncedCallback); 
            };

            const setupSlider = (sliderId, valueId, stateKey) => {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(valueId);
                if (!slider || !valueDisplay) return;
                slider.value = this.state[stateKey];
                valueDisplay.textContent = parseFloat(this.state[stateKey]).toFixed(2);
                slider.addEventListener('input', (e) => {
                    this.state[stateKey] = parseFloat(e.target.value);
                    valueDisplay.textContent = parseFloat(this.state[stateKey]).toFixed(2);
                });
                slider.addEventListener('change', () => this.saveState());
            };

            setListener('gemini-api-key-input', 'geminiApiKey'); 
            setListener('openrouter-api-key-input', 'openRouterKey'); 
            setListener('openrouter-model-input', 'openRouterModel'); 
            setListener('system-prompt-input', 'system_prompt');
            setListener('event-master-prompt-input', 'event_master_base_prompt');
            setListener('background-image-url', 'backgroundImageURL', () => this.applyStyling());
            setListener('chat-text-color', 'chatTextColor', () => this.applyStyling());
            
            setupSlider('koboldcpp-min-p-slider', 'koboldcpp-min-p-value', 'koboldcpp_min_p');
            setupSlider('koboldcpp-dry-slider', 'koboldcpp-dry-value', 'koboldcpp_dry');
            
            const fontSelector = document.getElementById('font-selector'); 
            fontSelector.value = this.state.font; 
            fontSelector.addEventListener('change', (e) => this.changeFont(e.target.value));

            const templateSelector = document.getElementById('koboldcpp-template-selector');
            templateSelector.value = this.state.koboldcpp_template;
            templateSelector.addEventListener('change', (e) => {
                this.state.koboldcpp_template = e.target.value;
                this.saveState();
            });
            
            const opacitySlider = document.getElementById('bubble-opacity-slider');
            const opacityValue = document.getElementById('bubble-opacity-value');
            opacitySlider.value = this.state.bubbleOpacity;
            opacityValue.textContent = `${Math.round(this.state.bubbleOpacity * 100)}%`;
            opacitySlider.addEventListener('input', (e) => {
                this.state.bubbleOpacity = parseFloat(e.target.value);
                opacityValue.textContent = `${Math.round(this.state.bubbleOpacity * 100)}%`;
                this.renderChat();
            });
            opacitySlider.addEventListener('change', () => this.saveState());
            
            document.querySelectorAll('input[name="imageDisplayMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => this.setCharacterImageMode(e.target.value));
            });

            const storyTitleInput = document.getElementById('story-title-input');
            storyTitleInput.addEventListener('input', debounce((e) => {
                this.renameStory(this.library.active_story_id, e.target.value);
            }, 500));
            
            const hamburgerBtn = document.getElementById('hamburger-menu-button');
            if (hamburgerBtn) {
                hamburgerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleMobileMenu();
                });
            }
            
            // Close mobile menu on outside click
            document.addEventListener('click', (e) => {
                const menu = document.getElementById('mobile-menu');
                const btn = document.getElementById('hamburger-menu-button');
                if (menu && !menu.classList.contains('hidden') && !menu.contains(e.target) && !btn.contains(e.target)) {
                    this.toggleMobileMenu();
                }
            });
        },
        
        toggleMobileMenu() {
            document.getElementById('mobile-menu').classList.toggle('hidden');
        },

        switchKnowledgeTab(tabName) {
            this.RUNTIME.activeKnowledgeTab = tabName;
            const worldTab = document.getElementById('knowledge-tab-world');
            const loreTab = document.getElementById('knowledge-tab-lore');
            const worldContent = document.getElementById('knowledge-world-content');
            const loreContent = document.getElementById('knowledge-lore-content');
            const addButton = document.getElementById('knowledge-add-button');

            if (tabName === 'world') {
                worldContent.classList.remove('hidden');
                loreContent.classList.add('hidden');
                worldTab.classList.add('border-indigo-500', 'text-white');
                worldTab.classList.remove('border-transparent', 'text-gray-400');
                loreTab.classList.add('border-transparent', 'text-gray-400');
                loreTab.classList.remove('border-indigo-500', 'text-white');
                addButton.onclick = () => this.addWorldInfoEntry();
            } else { // lore
                loreContent.classList.remove('hidden');
                worldContent.classList.add('hidden');
                loreTab.classList.add('border-indigo-500', 'text-white');
                loreTab.classList.remove('border-transparent', 'text-gray-400');
                worldTab.classList.add('border-transparent', 'text-gray-400');
                worldTab.classList.remove('border-indigo-500', 'text-white');
                addButton.onclick = () => this.addLorebookEntry();
            }
        },

        switchSettingsTab(tabName) {
            this.RUNTIME.activeSettingsTab = tabName;
            const tabs = ['appearance', 'prompt', 'model'];
            tabs.forEach(tab => {
                const tabButton = document.getElementById(`settings-tab-${tab}`);
                const tabContent = document.getElementById(`settings-${tab}-content`);
                if (tab === tabName) {
                    tabContent.classList.remove('hidden');
                    tabButton.classList.add('border-indigo-500', 'text-white');
                    tabButton.classList.remove('border-transparent', 'text-gray-400');
                } else {
                    tabContent.classList.add('hidden');
                    tabButton.classList.remove('border-indigo-500', 'text-white');
                    tabButton.classList.add('border-transparent', 'text-gray-400');
                }
            });
        },

        openModal(modalId) { 
            if(modalId === 'story-library-modal') {
                this.renderLibraryInterface();
            }
            if (modalId === 'knowledge-modal') {
                this.switchKnowledgeTab('world'); // Default to world tab
            }
            if (modalId === 'settings-modal') {
                this.switchSettingsTab('appearance'); // Default to appearance tab
            }
            document.getElementById(modalId).style.display = 'flex'; 
        },
        closeModal(modalId) { 
            if (this.RUNTIME.carousel_interval) {
                clearInterval(this.RUNTIME.carousel_interval);
                this.RUNTIME.carousel_interval = null;
            }
            document.getElementById(modalId).style.display = 'none'; 
        },
        changeFont(font) { this.state.font = font; this.applyStyling(); this.saveState(); },
        applyStyling() { 
            document.getElementById('global-background').style.backgroundImage = this.state.backgroundImageURL ? `url('${this.state.backgroundImageURL}')` : 'none';
            document.documentElement.style.setProperty('--chat-text-color', this.state.chatTextColor);
            document.documentElement.style.setProperty('--chat-font-family', this.state.font);
            this.renderChat();
        },
        setCharacterImageMode(mode) {
            this.state.characterImageMode = mode;
            this.saveState();
            this.renderChat();
        },
        
        // SECTION: RENDERING
        // =================================================================================================
        renderAll() { 
            const activeStory = this.library.stories.find(s => s.id === this.library.active_story_id);
            if (activeStory) {
                document.getElementById('story-title-input').value = activeStory.name || '';
                const mobileTitle = document.getElementById('story-title-mobile');
                if (mobileTitle) mobileTitle.textContent = activeStory.name || '';
            }
            this.renderCharacters(); this.renderWorldInfo(); this.renderLorebook(); this.renderChat(); this.updateAICharacterSelector(); this.renderSettings(); 
        },
        renderLibraryInterface(filterState = {}) {
            const container = document.getElementById('library-content-container');
            const { searchTerm = '', sortBy = 'last_modified', filterTag = '' } = filterState;

            const isTallScreen = window.innerHeight > window.innerWidth;

            // --- Filter, Search, Sort Logic ---
            let stories = [...this.library.stories];
            if (searchTerm) {
                const lowerCaseSearch = searchTerm.toLowerCase();
                stories = stories.filter(s => s.search_index && s.search_index.includes(lowerCaseSearch));
            }
            if (filterTag) {
                stories = stories.filter(s => {
                    const storyTags = new Set(s.tags || []);
                    s.state.characters.forEach(c => (c.tags || []).forEach(t => storyTags.add(t)));
                    return storyTags.has(filterTag);
                });
            }
            stories.sort((a, b) => {
                if (sortBy === 'name') return (a.name || '').localeCompare(b.name || '');
                if (sortBy === 'created_date') return new Date(b.created_date) - new Date(a.created_date);
                return new Date(b.last_modified) - new Date(a.last_modified);
            });

            // --- Controls HTML ---
            const tagOptions = this.library.tag_cache.map(tag => `<option value="${tag}" ${filterTag === tag ? 'selected':''}>${tag}</option>`).join('');
            const controlsHTML = `
                <div class="p-6 border-b border-gray-700 space-y-4">
                    <input type="search" placeholder="Search stories..." value="${searchTerm}" oninput="app.renderLibraryInterface({searchTerm: this.value, sortBy: document.getElementById('sort-by').value, filterTag: document.getElementById('filter-by-tag').value})" class="w-full bg-black/30 p-2 rounded-lg border-gray-600">
                    <div class="flex space-x-4">
                        <select id="sort-by" onchange="app.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: this.value, filterTag: document.getElementById('filter-by-tag').value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                            <option value="last_modified" ${sortBy === 'last_modified' ? 'selected' : ''}>Sort by Last Modified</option>
                            <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Sort by Name</option>
                            <option value="created_date" ${sortBy === 'created_date' ? 'selected' : ''}>Sort by Date Created</option>
                        </select>
                        <select id="filter-by-tag" onchange="app.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: document.getElementById('sort-by').value, filterTag: this.value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                            <option value="">Filter by Tag</option>
                            ${tagOptions}
                        </select>
                    </div>
                </div>`;

            // --- Story List HTML ---
            const storyListHTML = stories.map(story => {
                const displayName = story.name || 'Untitled Story';
                return `
                <div class="p-4 rounded-lg flex justify-between items-center cursor-pointer ${story.id === this.library.active_story_id ? 'bg-indigo-600/30' : 'bg-gray-700/50 hover:bg-gray-600/50'}" onclick="app.openStoryDetails('${story.id}')">
                    <div>
                        <h3 class="font-semibold text-lg">${this.escapeHTML(displayName)}</h3>
                        <p class="text-sm text-gray-400">Modified: ${new Date(story.last_modified).toLocaleString()}</p>
                    </div>
                    ${story.id === this.library.active_story_id ? '<span class="text-xs text-indigo-300 font-bold">ACTIVE</span>' : ''}
                </div>
            `}).join('<hr class="border-gray-700 my-2">');

            // --- Assemble Final Layout ---
            if (isTallScreen) {
                 container.innerHTML = `<div class="flex flex-col flex-grow min-h-0">${controlsHTML}<div class="p-6 overflow-y-auto">${storyListHTML}</div></div>`;
            } else {
                container.innerHTML = `
                    <div class="w-[450px] flex-shrink-0 border-r border-gray-700 flex flex-col">${controlsHTML}<div class="p-6 overflow-y-auto flex-grow">${storyListHTML}</div></div>
                    <div id="story-details-content-desktop" class="flex-grow p-6 flex items-center justify-center text-gray-500">Select a story to see details...</div>
                `;
            }
        },
        openStoryDetails(storyId) {
            const story = this.library.stories.find(s => s.id === storyId);
            if (!story) return;

            const allStoryTags = new Set(story.tags || []);
            story.state.characters.forEach(c => (c.tags || []).forEach(t => allStoryTags.add(t)));
            const tagsHTML = Array.from(allStoryTags).map(tag => `<span class="bg-gray-600/50 text-gray-300 text-xs font-medium mr-2 px-2.5 py-0.5 rounded">${tag}</span>`).join('');
            
            const detailsHTML = `
                <div class="p-6 border-b border-gray-700">
                    <h3 class="text-2xl font-bold">${this.escapeHTML(story.name || 'Untitled Story')}</h3>
                </div>
                <div class="p-6 flex-grow overflow-y-auto space-y-6">
                     <div class="relative w-full aspect-video bg-black/20 rounded-lg overflow-hidden" id="details-carousel"></div>
                     <div>
                        <h4 class="font-bold mb-2">Tags</h4>
                        <div class="flex flex-wrap">${tagsHTML || '<span class="text-gray-400 text-sm">No tags yet.</span>'}</div>
                     </div>
                     <div class="flex space-x-2">
                        <button onclick="app.loadStory('${story.id}')" class="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-3 rounded-lg">Load</button>
                        <button onclick="app.renameStoryPrompt('${story.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg" title="Rename"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button onclick="app.duplicateStory('${story.id}')" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                        <button onclick="app.deleteStory('${story.id}')" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-3 rounded-lg" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                     </div>
                     <div>
                        <h4 class="font-bold mb-2">Creator's Note</h4>
                        <textarea oninput="app.updateStoryField('${story.id}', 'creator_notes', this.value)" class="w-full h-32 bg-black/30 p-2 rounded-lg border-gray-600">${story.creator_notes || ''}</textarea>
                     </div>
                </div>
            `;

            if (window.innerHeight > window.innerWidth) {
                document.getElementById('story-details-content-mobile').innerHTML = detailsHTML;
                this.openModal('story-details-modal');
                this.startCarousel(story.state.characters, 'details-carousel');
            } else {
                document.getElementById('story-details-content-desktop').innerHTML = detailsHTML;
                this.startCarousel(story.state.characters, 'details-carousel');
            }
        },
        updateStoryField: debounce(function(storyId, field, value) {
            const story = this.library.stories.find(s => s.id === storyId);
            if (story) {
                story[field] = value;
                this.saveLibrary(); // Save the whole library object
            }
        }, 500),

        startCarousel(characters, containerId) {
            if (this.RUNTIME.carousel_interval) clearInterval(this.RUNTIME.carousel_interval);
            
            const container = document.getElementById(containerId);
            if (!container) return;

            const images = characters.map(c => c.image_url).filter(Boolean);
            if (images.length === 0) {
                container.innerHTML = `<div class="w-full h-full flex items-center justify-center text-gray-500">No character images</div>`;
                return;
            }

            container.innerHTML = `
                <img id="${containerId}-img1" class="absolute inset-0 w-full h-full object-contain transition-opacity duration-1000" style="opacity: 1;">
                <img id="${containerId}-img2" class="absolute inset-0 w-full h-full object-contain transition-opacity duration-1000" style="opacity: 0;">
            `;
            
            let currentIndex = 0;
            let activeImg = 1;

            const img1 = document.getElementById(`${containerId}-img1`);
            const img2 = document.getElementById(`${containerId}-img2`);
            img1.src = images[currentIndex];
            
            this.RUNTIME.carousel_interval = setInterval(() => {
                currentIndex = (currentIndex + 1) % images.length;
                if (activeImg === 1) {
                    img2.src = images[currentIndex];
                    img1.style.opacity = 0;
                    img2.style.opacity = 1;
                    activeImg = 2;
                } else {
                    img1.src = images[currentIndex];
                    img1.style.opacity = 1;
                    img2.style.opacity = 0;
                    activeImg = 1;
                }
            }, 4000);
        },

        renameStoryPrompt(storyId) {
            const story = this.library.stories.find(s => s.id === storyId);
            if (story) {
                const currentName = story.name || '';
                const newName = prompt("Enter new name for the story:", currentName);
                if (newName && newName.trim() !== '') {
                    this.renameStory(storyId, newName.trim());
                }
            }
        },
        
        // --- The rest of the app logic ---
        renderAllButLibrary() { 
            const activeStory = this.library.stories.find(s => s.id === this.library.active_story_id);
            if (activeStory) {
                document.getElementById('story-title-input').value = activeStory.name || '';
            }
            this.renderCharacters(); this.renderWorldInfo(); this.renderLorebook(); this.renderChat(); this.updateAICharacterSelector(); this.renderSettings(); 
        },
        renderCharacters() { document.getElementById('characters-container').innerHTML = this.state.characters.map(char => {
            const extraPortraitsHTML = (char.extra_portraits || []).map((portrait, index) => `
                <div class="flex items-center space-x-2 mt-2">
                    <select onchange="app.updateExtraPortrait('${char.id}', ${index}, 'emotion', this.value)" class="w-1/3 bg-black/30 border-gray-600 rounded p-1 text-sm">
                        <option value="happy" ${portrait.emotion === 'happy' ? 'selected' : ''}>Happy</option>
                        <option value="sad" ${portrait.emotion === 'sad' ? 'selected' : ''}>Sad</option>
                        <option value="angry" ${portrait.emotion === 'angry' ? 'selected' : ''}>Angry</option>
                        <option value="surprised" ${portrait.emotion === 'surprised' ? 'selected' : ''}>Surprised</option>
                    </select>
                    <input type="text" value="${this.escapeHTML(portrait.url)}" oninput="app.updateExtraPortrait('${char.id}', ${index}, 'url', this.value)" class="w-2/3 bg-black/30 border-gray-600 p-1 text-sm" placeholder="URL...">
                    <button onclick="app.removeExtraPortrait('${char.id}', ${index})" class="text-red-400 hover:text-red-300">X</button>
                </div>
            `).join('');
            const tagsHTML = (char.tags || []).join(', ');

            return `<div class="character-card p-4 flex flex-col space-y-4"><div class="flex justify-between items-center"><input type="text" value="${this.escapeHTML(char.name)}" oninput="app.updateCharacterField('${char.id}', 'name', this.value)" class="text-xl font-bold bg-transparent p-1 w-2/3">${!char.is_user ? `<div class="flex items-center space-x-2"><span class="text-sm">Active</span><label class="flex items-center cursor-pointer"><div class="relative"><input type="checkbox" class="sr-only" ${char.is_active ? 'checked' : ''} onchange="app.toggleCharacterActive(event, '${char.id}')"><div class="w-12 h-6 bg-gray-600 rounded-full toggle-bg"></div></div></label></div>` : '<span class="text-sm font-semibold text-indigo-400">PLAYER</span>'}</div><textarea oninput="app.updateCharacterField('${char.id}', 'description', this.value); app.updateTokenCount('${char.id}', this.value)" class="w-full h-24 bg-black/30 border-gray-600 p-2 resize-none">${this.escapeHTML(char.description)}</textarea><div class="text-right text-sm text-gray-400" id="token-counter-${char.id}">~${Math.round((char.description || '').length / 4)} tokens</div><input type="text" value="${this.escapeHTML(char.image_url)}" oninput="app.updateCharacterField('${char.id}', 'image_url', this.value)" class="w-full bg-black/30 border-gray-600 p-2 text-sm" placeholder="Default/Neutral Image URL..."><div id="extra-portraits-${char.id}">${extraPortraitsHTML}</div><button onclick="app.addExtraPortrait('${char.id}')" class="text-sm text-sky-400 hover:text-sky-300 mt-2">+ Add Emotional Portrait</button><div class="mt-2"><input type="text" value="${tagsHTML}" oninput="app.updateCharacterTags('${char.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-2 text-sm" placeholder="Tags (comma-separated)..."><button onclick="app.generateTagsForCharacter('${char.id}')" class="text-xs text-sky-400 hover:text-sky-300 mt-1">Auto-Tag</button></div><div class="flex justify-end space-x-2"><button onclick="app.openAIEnhanceModal('${char.id}')" class="text-sm bg-gray-600/80 hover:bg-gray-500/80 font-semibold py-2 px-3 rounded-lg">AI Enhance</button>${!char.is_user ? `<button onclick="app.deleteCharacter('${char.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button>` : ''}</div></div>`;
        }).join(''); },
        renderWorldInfo() { document.getElementById('world-info-list').innerHTML = this.state.world_info.map(entry => `<div onclick="app.selectWorldInfoEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${this.state.selectedWorldInfoId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}"><h4 class="font-semibold truncate">${this.escapeHTML(entry.title)}</h4></div>`).join(''); this.renderWorldInfoDetails(); },
        renderWorldInfoDetails() { const container = document.getElementById('world-info-details-content'); const entry = this.state.world_info.find(e => e.id === this.state.selectedWorldInfoId); if (entry) { container.innerHTML = `<input type="text" value="${this.escapeHTML(entry.title)}" oninput="app.updateWorldInfoField('${entry.id}', 'title', this.value)" class="text-xl font-bold bg-black/30 p-2 w-full mb-4"><textarea oninput="app.updateWorldInfoField('${entry.id}', 'content', this.value)" class="w-full h-4/5 bg-black/30 p-2 resize-none">${this.escapeHTML(entry.content)}</textarea><div class="flex justify-end mt-4"><button onclick="app.deleteWorldInfoEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button></div>`; } else { container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a world info entry.</div>`; } },
        renderLorebook() { document.getElementById('lorebook-list').innerHTML = this.state.lorebook_entries.map(entry => `<div onclick="app.selectLorebookEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${this.state.selectedLorebookId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} flex justify-between items-center"><h4 class="font-semibold truncate">${this.escapeHTML(entry.title)}</h4> ${entry.triggered_at_turn !== null ? '<span class="text-xs text-sky-300">ACTIVE</span>' : ''}</div>`).join(''); this.renderLorebookDetails(); },
        renderLorebookDetails() { const container = document.getElementById('lorebook-details-content'); const entry = this.state.lorebook_entries.find(e => e.id === this.state.selectedLorebookId); if (entry) { container.innerHTML = `<div class="flex flex-col h-full"><label class="font-bold">Title</label><input type="text" value="${this.escapeHTML(entry.title)}" oninput="app.updateLorebookField('${entry.id}', 'title', this.value)" class="text-xl font-bold bg-black/30 p-2 w-full mb-4"><label class="font-bold">Triggers (Keywords or % Chance)</label><input type="text" value="${this.escapeHTML(entry.triggers)}" oninput="app.updateLorebookField('${entry.id}', 'triggers', this.value)" placeholder="e.g. sword, magic, 25%" class="bg-black/30 p-2 w-full mb-4"><label class="font-bold">Content</label><textarea oninput="app.updateLorebookField('${entry.id}', 'content', this.value)" class="w-full flex-grow bg-black/30 p-2 resize-none">${this.escapeHTML(entry.content)}</textarea><div class="flex justify-end mt-4"><button onclick="app.deleteLorebookEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button></div></div>`; } else { container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a lorebook entry.</div>`; } },
        
        _getReplacer(contextCharacter) {
            const userChar = this.state.characters.find(c => c.is_user);
            const characterName = contextCharacter ? contextCharacter.name : '';
            const userName = userChar ? userChar.name : 'You';
            return (text) => {
                if (typeof text !== 'string') return '';
                let processedText = text.replace(/{character}/g, characterName);
                processedText = processedText.replace(/{user}/g, userName);
                return processedText;
            };
        },
        
        _createMessageHTML(msg, index) {
            if (msg.type === 'lore_reveal') return '';
            const character = this.state.characters.find(c => c.id === msg.character_id);
            if (!character) return '';

            const replacer = this._getReplacer(character);
            const processedContent = replacer(msg.content);
            const contentId = `message-content-${index}`;
            const contentHTML = marked.parse(processedContent || '').replace(/^<p>|<\/p>$/g, '');
            
            let bubbleColor;
            let characterNameColor = '';

            if (character.is_user) {
                bubbleColor = `rgba(75, 85, 99, ${this.state.bubbleOpacity})`; // Default user color
            } else {
                const charColor = character.color || this.CONSTANTS.CHARACTER_COLORS[0];
                bubbleColor = this.UTILITY.hexToRgba(charColor.base, this.state.bubbleOpacity);
                characterNameColor = `style="color: ${charColor.bold};"`;
            }
            
            const bubbleWidthClass = 'max-w-xs md:max-w-md lg:max-w-2xl';
            const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

            return `
                <div class="chat-bubble-container ${msg.isNew ? 'new-message' : ''} mb-4" data-message-index="${index}">
                    <div class="flex items-start justify-between">
                         <p class="font-bold text-sm mb-1" ${characterNameColor}>${this.escapeHTML(character.name)}</p>
                         <span class="timestamp text-xs text-gray-500 ml-4">${timestamp}</span>
                    </div>
                    <div class="flex items-center w-full">
                        <div class="${bubbleWidthClass} rounded-lg p-3" style="background-color: ${bubbleColor};">
                            <div id="${contentId}" class="whitespace-pre-wrap" style="color: ${this.state.chatTextColor}; font-family: ${this.state.font};">${contentHTML}</div>
                        </div>
                        <div class="action-btn-group flex flex-col ml-2 space-y-1">
                            <button onclick="app.copyMessage(${index})" class="text-gray-400 hover:text-white" title="Copy">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            </button>
                            <button onclick="app.openEditModal(${index})" class="text-gray-400 hover:text-white" title="Edit">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                            </button>
                        </div>
                    </div>
                </div>`;
        },

        renderChat() {
            if (this.RUNTIME.streamingInterval) return; 
            
            document.body.dataset.mode = this.state.characterImageMode;

            const chatWindow = document.getElementById('chat-window');
            const lastChatMessages = this.state.chat_history.filter(m => m.type === 'chat');
            const lastSpeakerMsg = lastChatMessages.length > 0 ? lastChatMessages[lastChatMessages.length - 1] : null;
            const lastSpeaker = lastSpeakerMsg ? this.state.characters.find(c => c.id === lastSpeakerMsg.character_id) : null;
            
            const cinematicBg = document.getElementById('cinematic-overlay-bg');
            if (this.state.characterImageMode === 'cinematic_overlay' && lastSpeaker && lastSpeaker.image_url) {
                const lastEmotion = lastSpeakerMsg.emotion || 'neutral';
                let portraitUrl = lastSpeaker.image_url;
                if (lastEmotion !== 'neutral' && lastSpeaker.extra_portraits) {
                    const emotionalPortrait = lastSpeaker.extra_portraits.find(p => p.emotion === lastEmotion);
                    if (emotionalPortrait) portraitUrl = emotionalPortrait.url;
                }
                cinematicBg.style.backgroundImage = `url('${portraitUrl}')`;
                cinematicBg.style.opacity = 0.2;
            } else {
                cinematicBg.style.opacity = 0;
            }

            chatWindow.innerHTML = this.state.chat_history.map((msg, index) => this._createMessageHTML(msg, index)).join('');
            
            this.state.chat_history.forEach(m => m.isNew = false);
        },

        copyMessage(index) {
            const message = this.state.chat_history[index];
            if (!message) return;
            
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = message.content;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            try {
                document.execCommand('copy');
                const copyBtn = document.querySelector(`[data-message-index='${index}'] .action-btn-group button[title='Copy']`);
                if (copyBtn) {
                    const originalIcon = copyBtn.innerHTML;
                    copyBtn.innerHTML = `<span class="text-xs text-green-400">Copied!</span>`;
                    setTimeout(() => { copyBtn.innerHTML = originalIcon; }, 1500);
                }
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(tempTextarea);
        },

        startStreamingResponse(charId, fullText, emotion) {
            if (this.RUNTIME.streamingInterval) clearInterval(this.RUNTIME.streamingInterval);

            const messageIndex = this.state.chat_history.length;
            this.state.chat_history.push({ 
                character_id: charId, 
                content: '',
                type: 'chat', 
                emotion: emotion, 
                timestamp: new Date().toISOString(),
                isNew: true 
            });

            this.renderChat();
            
            const messageContentEl = document.getElementById(`message-content-${messageIndex}`);
            if (!messageContentEl) {
                console.error("Could not find message element to stream to.");
                return;
            }
            const bubbleEl = messageContentEl.closest('.chat-bubble-container');
            const words = fullText.split(/(\s+)/);
            let wordIndex = 0;

            this.RUNTIME.streamingInterval = setInterval(() => {
                if (wordIndex < words.length) {
                    const word = words[wordIndex];
                    this.state.chat_history[messageIndex].content += word;
                    const replacer = this._getReplacer(this.state.characters.find(c => c.id === charId));
                    const processedContent = replacer(this.state.chat_history[messageIndex].content);
                    messageContentEl.innerHTML = marked.parse(processedContent).replace(/^<p>|<\/p>$/g, '');
                    
                    const chatWindow = document.getElementById('chat-window');
                    const isScrolledToBottom = chatWindow.scrollHeight - chatWindow.clientHeight <= chatWindow.scrollTop + 50;
                    if(isScrolledToBottom) {
                         bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    }

                    wordIndex++;
                } else {
                    clearInterval(this.RUNTIME.streamingInterval);
                    this.RUNTIME.streamingInterval = null;
                    this.state.chat_history[messageIndex].isNew = false;
                    this.saveState();
                    setTimeout(() => bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                }
            }, 10); // Decreased from 50ms to 10ms for faster streaming
        },

        addMessageToHistory(id, content, type = 'chat', emotion = 'neutral') {
            if (this.RUNTIME.streamingInterval) {
                clearInterval(this.RUNTIME.streamingInterval);
                this.RUNTIME.streamingInterval = null;
                this.saveState();
            }
            this.state.chat_history.push({ 
                character_id: id, 
                content, 
                type, 
                emotion,
                timestamp: new Date().toISOString(),
                isNew: true 
            });
            if (type === 'chat') this.state.messageCounter++;
            this.renderChat();
            this.saveState();
            
            const chatWindow = document.getElementById('chat-window');
            const lastBubble = chatWindow.lastElementChild;
            if(lastBubble) {
                lastBubble.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        },

        async triggerAIResponse(charId = null) {
            const aiCharId = charId || document.getElementById('ai-character-selector').value;
            if (!aiCharId) return;
            this.showTypingIndicator(aiCharId);
            try { 
                const responseText = await this.callAI(this.buildPrompt(aiCharId));
                const emotion = await this.getEmotionForText(responseText);
                this.hideTypingIndicator();
                this.startStreamingResponse(aiCharId, responseText, emotion);
            }
            catch (error) { 
                this.hideTypingIndicator();
                this.addMessageToHistory(aiCharId, `[Error: ${error.message}]`); 
            }
        },
        
        renderSettings() { 
            document.querySelector(`input[name="apiProvider"][value="${this.state.apiProvider}"]`).checked = true; 
            document.getElementById('gemini-settings').style.display = this.state.apiProvider === 'gemini' ? 'block' : 'none'; 
            document.getElementById('openrouter-settings').style.display = this.state.apiProvider === 'openrouter' ? 'block' : 'none';
            document.getElementById('koboldcpp-settings').style.display = this.state.apiProvider === 'koboldcpp' ? 'block' : 'none';
            document.getElementById('system-prompt-input').value = this.state.system_prompt; 
            document.getElementById('event-master-prompt-input').value = this.state.event_master_base_prompt; 
            document.getElementById('font-selector').value = this.state.font; 
            document.getElementById('background-image-url').value = this.state.backgroundImageURL; 
            document.getElementById('bubble-opacity-slider').value = this.state.bubbleOpacity; 
            document.getElementById('bubble-opacity-value').textContent = `${Math.round(this.state.bubbleOpacity * 100)}%`; 
            document.getElementById('chat-text-color').value = this.state.chatTextColor; 
            document.querySelector(`input[name="imageDisplayMode"][value="${this.state.characterImageMode}"]`).checked = true;
            document.getElementById('koboldcpp-template-selector').value = this.state.koboldcpp_template;
        },
        updateAICharacterSelector() {
            const selector = document.getElementById('ai-character-selector');
            const currentValue = selector.value;
            selector.innerHTML = this.state.characters.filter(c => !c.is_user && c.is_active).map(c => `<option value="${c.id}">${this.escapeHTML(c.name)}</option>`).join('');
            if (currentValue && selector.querySelector(`option[value="${currentValue}"]`)) {
                selector.value = currentValue;
            }
        },
        
        addCharacter() { 
            const aiCharCount = this.state.characters.filter(c => !c.is_user).length;
            const newColor = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
            this.state.characters.push({ id: this.uuid(), name: "New Character", description: "", image_url: "", extra_portraits: [], tags: [], is_user: false, is_active: true, color: newColor }); 
            this.saveAndRender(); 
        },
        deleteCharacter(id) { 
            this.state.characters = this.state.characters.filter(c => c.id !== id); 
            this.saveAndRender(); 
        },
        updateCharacterField: debounce(function(id, field, value) { 
            const char = this.state.characters.find(c => c.id === id); 
            if (char) { 
                char[field] = value; 
                this.saveState(); 
                if (field === 'name') {
                    this.updateAICharacterSelector();
                }
            } 
        }, 300),
        updateCharacterTags: debounce(function(id, value) {
            const char = this.state.characters.find(c => c.id === id);
            if (char) {
                char.tags = value.split(',').map(t => t.trim()).filter(Boolean);
                this.saveState();
                this.updateTagCache();
            }
        }, 500),
        async generateTagsForCharacter(charId) {
            const char = this.state.characters.find(c => c.id === charId);
            if (!char) return;
            const prompt = `Analyze the following character. Generate 3 to 5 relevant, one-word, comma-separated tags.\n\nCHARACTER: ${char.name}\nDESCRIPTION: ${char.description}`;
            try {
                const tagsString = await this.callAI(prompt);
                char.tags = (char.tags || []).concat(tagsString.split(',').map(t => t.trim().toLowerCase()));
                char.tags = [...new Set(char.tags)]; // remove duplicates
                this.saveAndRender();
                this.updateTagCache();
            } catch (e) {
                console.error("Tag generation failed:", e);
            }
        },
        addExtraPortrait(charId) { const char = this.state.characters.find(c => c.id === charId); if(char) { if(!char.extra_portraits) char.extra_portraits = []; char.extra_portraits.push({emotion: 'happy', url: ''}); this.renderCharacters(); this.saveState(); } },
        removeExtraPortrait(charId, index) { const char = this.state.characters.find(c => c.id === charId); if(char && char.extra_portraits) { char.extra_portraits.splice(index, 1); this.renderCharacters(); this.saveState(); } },
        updateExtraPortrait: debounce(function(charId, index, field, value) { const char = this.state.characters.find(c => c.id === charId); if(char && char.extra_portraits && char.extra_portraits[index]) { char.extra_portraits[index][field] = value; this.saveState(); } }, 300),
        updateTokenCount(charId, text) { const counter = document.getElementById(`token-counter-${charId}`); if (counter) counter.textContent = `~${Math.round((text || '').length / 4)} tokens`; },
        toggleCharacterActive(event, id) { const char = this.state.characters.find(c => c.id === id); if (char) char.is_active = event.target.checked; this.saveState(); this.updateAICharacterSelector(); },
        
        addWorldInfoEntry() { const newEntry = { id: this.uuid(), title: "New World Info", content: "" }; this.state.world_info.push(newEntry); this.state.selectedWorldInfoId = newEntry.id; this.saveAndRenderWorldInfo(); },
        deleteWorldInfoEntry(id) { 
            this.state.world_info = this.state.world_info.filter(e => e.id !== id); 
            if(this.state.selectedWorldInfoId === id) this.state.selectedWorldInfoId = null; 
            this.saveAndRenderWorldInfo(); 
        },
        selectWorldInfoEntry(id) { this.state.selectedWorldInfoId = id; this.renderWorldInfo(); },
        updateWorldInfoField: debounce(function(id, field, value) { 
            const entry = this.state.world_info.find(e => e.id === id); 
            if (entry) { 
                entry[field] = value; 
                this.saveState(); 
                if (field === 'title') {
                    document.getElementById('world-info-list').innerHTML = this.state.world_info.map(entry => `<div onclick="app.selectWorldInfoEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${this.state.selectedWorldInfoId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}"><h4 class="font-semibold truncate">${this.escapeHTML(entry.title)}</h4></div>`).join('');
                }
            } 
        }, 300),

        addLorebookEntry() { const newEntry = {id: this.uuid(), title: "New Lore", triggers: "", content: "", triggered_at_turn: null }; this.state.lorebook_entries.push(newEntry); this.state.selectedLorebookId = newEntry.id; this.saveAndRenderLorebook(); },
        deleteLorebookEntry(id) { 
            this.state.lorebook_entries = this.state.lorebook_entries.filter(e => e.id !== id); 
            if(this.state.selectedLorebookId === id) this.state.selectedLorebookId = null; 
            this.saveAndRenderLorebook(); 
        },
        selectLorebookEntry(id) { this.state.selectedLorebookId = id; this.renderLorebook(); },
        updateLorebookField: debounce(function(id, field, value) { 
            const entry = this.state.lorebook_entries.find(e => e.id === id); 
            if (entry) { 
                entry[field] = value; 
                this.saveState(); 
                if (field === 'title') {
                     document.getElementById('lorebook-list').innerHTML = this.state.lorebook_entries.map(entry => `<div onclick="app.selectLorebookEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${this.state.selectedLorebookId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} flex justify-between items-center"><h4 class="font-semibold truncate">${this.escapeHTML(entry.title)}</h4> ${entry.triggered_at_turn !== null ? '<span class="text-xs text-sky-300">ACTIVE</span>' : ''}</div>`).join('');
                }
            } 
        }, 300),

        handlePrimaryAction() { document.getElementById('chat-input').value.trim() === '' ? this.writeForMe() : this.sendMessage(); },
        async handleRegen() {
            if (this.RUNTIME.streamingInterval) return;
            const selectedCharId = document.getElementById('ai-character-selector').value;
            const lastMsg = this.state.chat_history.filter(m => m.type === 'chat').pop();
            const lastChar = lastMsg ? this.state.characters.find(c => c.id === lastMsg.character_id) : null;

            if (lastChar && !lastChar.is_user && lastMsg.character_id === selectedCharId) {
                this.undoLastTurn();
                await this.triggerAIResponse(selectedCharId);
            } else {
                await this.triggerAIResponse(selectedCharId);
            }
        },
        async sendMessage() {
            if (this.RUNTIME.streamingInterval) return;
            const input = document.getElementById('chat-input');
            const userChar = this.state.characters.find(c => c.is_user);
            this.addMessageToHistory(userChar.id, input.value.trim());
            input.value = '';
            this.checkLorebookTriggers();
            await this.triggerAIResponse();
            this.checkEventMaster();
        },
        
        showTypingIndicator(charId, text="is thinking...") { this.hideTypingIndicator(); const chatWindow=document.getElementById('chat-window'); const name = this.state.characters.find(c => c.id === charId)?.name || 'System'; const indicator = document.createElement('div'); indicator.id = 'typing-indicator'; indicator.innerHTML = `<div class="mb-4 flex flex-col items-start"><p class="font-bold text-sm mb-1">${this.escapeHTML(name)}</p><div class="p-3 bg-gray-700/80 rounded-lg"><p class="italic">${text}</p></div></div>`; chatWindow.appendChild(indicator); chatWindow.scrollTop = chatWindow.scrollHeight; },
        hideTypingIndicator() { const el = document.getElementById('typing-indicator'); if (el) el.remove(); },
        undoLastTurn() { 
            if (this.RUNTIME.streamingInterval) return;
            if (this.state.chat_history.length === 0) return; 
            const lastMessage = this.state.chat_history.pop(); 
            if (lastMessage.type === 'chat') this.state.messageCounter--; 
            this.saveAndRender(); 
        },
        async writeForMe() {
            if (this.RUNTIME.streamingInterval) return;
            const userChar = this.state.characters.find(c => c.is_user); if (!userChar) return;
            const btn = document.querySelector('button[onclick="app.handlePrimaryAction()"]');
            const input = document.getElementById('chat-input');
            const originalPlaceholder = input.placeholder;
            btn.disabled = true;
            input.placeholder = 'AI is writing...';
            try {
                input.value = await this.callAI(this.buildPrompt(userChar.id, true));
            } catch (error) {
                console.error("Write for Me failed:", error);
            } finally {
                btn.disabled = false;
                input.placeholder = originalPlaceholder;
            }
        },

        buildPrompt(charToActId, isForUser = false) {
            const charToAct = this.state.characters.find(c => c.id === charToActId);
            const replacer = this._getReplacer(charToAct);

            const components = {
                system_prompt: replacer(this.state.system_prompt),
                event_master_prompt: replacer(this.state.event_master_prompt),
                world_info: this.state.world_info.map(l => `Title: ${l.title}\nContent: ${replacer(l.content)}`).join('\n\n'),
                characters: this.state.characters.filter(c => c.is_active).map(c => `[Character: ${c.name}]\nDescription: ${replacer(c.description)}`).join('\n\n'),
                history: this.state.chat_history.slice(-10),
                charToAct: charToAct,
                isForUser: isForUser
            };
            
            if (this.state.event_master_prompt) { 
                this.state.event_master_prompt = ''; 
                this.saveState(); 
            }

            if (this.state.apiProvider === 'koboldcpp') { 
                return this.buildKoboldTemplatedPrompt(components, replacer); 
            }
            return this.buildDefaultPrompt(components, replacer);
        },
        buildDefaultPrompt(components, replacer) {
            let p = components.system_prompt + "\n\n";
            if (components.event_master_prompt) p += "--- SECRET EVENT MASTER INSTRUCTION ---\n" + components.event_master_prompt + "\n\n";
            p += "--- WORLD INFO ---\n" + components.world_info + "\n\n";
            p += "--- CHARACTERS ---\n" + components.characters + "\n\n";
            p += "--- RECENT CONVERSATION & EVENTS ---\n";
            components.history.forEach(msg => { 
                if (msg.type === 'chat') {
                    const char = this.state.characters.find(c => c.id === msg.character_id); 
                    if (char) p += `[Speaker: ${char.name}]\n${replacer(msg.content)}\n\n`;
                } else if (msg.type === 'lore_reveal') {
                    p += `[System Note: Lore Revealed - ${msg.title}]\n${replacer(msg.content)}\n\n`;
                }
            });
            p += "\n--- INSTRUCTION ---\n";
            p += components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;
            p += " Do not repeat the character's name in the response itself.\n[CHARACTER_TO_ACT]: " + components.charToAct.name;
            return p;
        },
        buildKoboldTemplatedPrompt(components, replacer) {
            const template = this.state.koboldcpp_template;
            if (template === 'none') return this.buildDefaultPrompt(components, replacer);

            let system = [components.system_prompt];
            if (components.event_master_prompt) system.push("SECRET EVENT INSTRUCTION:\n" + components.event_master_prompt);
            system.push("WORLD INFO:\n" + components.world_info);
            system.push("CHARACTERS:\n" + components.characters);

            const system_prompt_str = system.join('\n\n');
            
            const history_str = components.history.map(msg => {
                if (msg.type === 'chat') {
                    const char = this.state.characters.find(c => c.id === msg.character_id); 
                    if (char) return `${char.is_user ? 'user' : 'assistant'}:${char.name}:\n${replacer(msg.content)}`;
                } else if (msg.type === 'lore_reveal') {
                    return `system:Lore Revealed - ${msg.title}:\n${replacer(msg.content)}`;
                }
            }).filter(Boolean).join('\n');

            let instruction = components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;
            instruction += " Do not repeat the character's name in the response itself.";

            switch (template) {
                case 'mistral':
                    return `<s>[INST] ${system_prompt_str}\n\n${history_str}\n\n${instruction} [/INST]`;
                case 'chatml':
                    const history_chatml = components.history.map(msg => {
                        const role = msg.type === 'lore_reveal' ? 'system' : (this.state.characters.find(c=>c.id === msg.character_id)?.is_user ? 'user' : 'assistant');
                        const content = msg.type === 'lore_reveal' ? `[Lore Revealed - ${msg.title}]\n${replacer(msg.content)}` : `${this.state.characters.find(c=>c.id === msg.character_id)?.name}:\n${replacer(msg.content)}`;
                        return `<|im_start|>${role}\n${content}<|im_end|>`;
                    }).join('\n');
                    return `<|im_start|>system\n${system_prompt_str}<|im_end|>\n${history_chatml}\n<|im_start|>user\n${instruction}<|im_end|>\n<|im_start|>assistant\n${components.charToAct.name}:\n`;
                case 'alpaca':
                     return `### Instruction:\n${system_prompt_str}\n\n${history_str}\n\n${instruction}\n\n### Response:\n`;
                default:
                    return this.buildDefaultPrompt(components, replacer);
            }
        },
        async checkWorldInfoAgent() { this.showTypingIndicator('world-info-agent', 'Updating world info...'); try { const updates = JSON.parse(await this.callAI(this.buildWorldInfoAgentPrompt(), true)); if (updates.add) updates.add.forEach(item => this.state.world_info.push({id: this.uuid(), ...item})); if (updates.modify) updates.modify.forEach(item => { const entry = this.state.world_info.find(e => e.title.toLowerCase() === item.title.toLowerCase()); if (entry) entry.content = item.new_content; }); this.saveAndRenderWorldInfo(); } catch (e) { console.error("World Info Agent failed:", e); } finally { this.hideTypingIndicator(); } },
        buildWorldInfoAgentPrompt() { let p = `As World Info Master, read chat/info, update the info. Output valid JSON: { "add": [{"title": "...", "content": "..."}], "modify": [{"title": "...", "new_content": "..."}] } or {}. INFO:${JSON.stringify(this.state.world_info)}CHAT:`; this.state.chat_history.filter(m=>m.type==='chat').slice(-8).forEach(msg => { const c = this.state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;}); return p; },
        async checkEventMaster() { if (this.state.messageCounter > 0 && this.state.messageCounter % 6 === 0) try { this.state.event_master_prompt = await this.callAI(this.buildEventMasterPrompt()); this.saveState(); console.log("Event Master:", this.state.event_master_prompt); } catch (e) { console.error("Event Master failed:", e); } },
        buildEventMasterPrompt() { let p = this.state.event_master_base_prompt + '\n\n--- RECENT CHAT HISTORY ---\n'; this.state.chat_history.filter(m=>m.type==='chat').slice(-12).forEach(msg => { const c = this.state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;}); return p; },
        
        checkLorebookTriggers() {
            const lastMessage = this.state.chat_history.filter(m => m.type === 'chat').pop();
            if (!lastMessage) return;
            this.state.lorebook_entries.forEach(entry => {
                if (entry.triggered_at_turn !== null && (this.state.messageCounter - entry.triggered_at_turn > 10)) {
                    entry.triggered_at_turn = null;
                }
                if (entry.triggered_at_turn === null) {
                    const { keywords, chance } = this.parseTriggers(entry.triggers);
                    const keywordMatch = keywords.some(kw => lastMessage.content.toLowerCase().includes(kw));
                    const chanceMatch = Math.random() * 100 < chance;
                    if (keywordMatch || chanceMatch) {
                        entry.triggered_at_turn = this.state.messageCounter;
                        this.state.chat_history.push({ type: 'lore_reveal', title: entry.title, content: entry.content });
                        console.log(`Lorebook triggered: ${entry.title}`);
                    }
                }
            });
            this.saveState();
            this.renderLorebook();
        },

        parseTriggers(triggersStr) {
            if (!triggersStr) return { keywords: [], chance: 0 };
            const parts = triggersStr.split(',').map(s => s.trim().toLowerCase());
            const keywords = parts.filter(p => !p.match(/^\d+\s*\%$/) && p.length > 0);
            const chancePart = parts.find(p => p.match(/^\d+\s*\%$/));
            const chance = chancePart ? parseInt(chancePart.replace('%', '')) : 0;
            return { keywords, chance };
        },

        openEditModal(index) {
            this.openModal('edit-response-modal');
            const message = this.state.chat_history[index];
            const input = document.getElementById('edit-modal-input');
            input.value = message.content;
            document.getElementById('edit-modal-save-button').onclick = () => this.saveEditedResponse(index);
        },
        saveEditedResponse(index) {
            const newContent = document.getElementById('edit-modal-input').value;
            this.state.chat_history[index].content = newContent;
            this.saveAndRender();
            this.closeModal('edit-response-modal');
        },

        openAIEnhanceModal(charId) { this.openModal('ai-enhance-modal'); const char = this.state.characters.find(c => c.id === charId); document.getElementById('modal-input').value = char.description; const btn = document.getElementById('modal-confirm-button'); btn.onclick = async () => { btn.disabled = true; btn.textContent = 'Generating...'; try { char.description = await this.callAI(`Embellish this character concept into a rich description. CONCEPT: "${document.getElementById('modal-input').value}"`); this.saveAndRender(); } catch (error) { alert(`AI Error: ${error.message}`); } finally { this.closeModal('ai-enhance-modal'); btn.disabled = false; btn.textContent = 'Generate'; } }; },
        async getEmotionForText(text) {
            try {
                const prompt = `Analyze the sentiment of the following text. Classify it as one of the following: neutral, happy, sad, angry, surprised. Respond with only a single word from that list.\n\nTEXT: "${text}"`;
                const response = await this.callAI(prompt);
                const emotion = response.toLowerCase().trim();
                const validEmotions = ['neutral', 'happy', 'sad', 'angry', 'surprised'];
                return validEmotions.includes(emotion) ? emotion : 'neutral';
            } catch (error) {
                console.error("Sentiment analysis failed:", error);
                return 'neutral'; // Default on error
            }
        },
        async callAI(prompt, isJson = false) {
            let text = "";
            try {
                if (this.state.apiProvider === 'gemini') {
                    text = await this.callGemini(prompt);
                } else if (this.state.apiProvider === 'openrouter') {
                    text = await this.callOpenRouter(prompt);
                } else if (this.state.apiProvider === 'koboldcpp') {
                    text = await this.callKoboldCPP(prompt);
                }

                if (isJson) {
                    // The AI might wrap the JSON in ```json ... ```. We need to extract the raw JSON.
                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch && jsonMatch[0]) {
                        return jsonMatch[0];
                    }
                    console.error("AI did not return valid JSON for a JSON-expected call. Response:", text);
                    throw new Error("AI response was not in the expected JSON format.");
                }
                return text;
            } catch (error) {
                console.error(`AI call failed for provider ${this.state.apiProvider}:`, error);
                throw error;
            }
        },
        async callGemini(prompt) {
            if (!this.state.geminiApiKey) throw new Error("Gemini API key not set.");
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${this.state.geminiApiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
            if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
            const data = await res.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
        },
        async callOpenRouter(prompt) {
            if (!this.state.openRouterKey || !this.state.openRouterModel) throw new Error("OpenRouter API key or model not set.");
            const res = await fetch('https://openrouter.ai/api/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${this.state.openRouterKey}`}, body: JSON.stringify({ model: this.state.openRouterModel, messages: [{ role: 'user', content: prompt }] }) });
            if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
            const data = await res.json();
            return data.choices[0].message.content;
        },
        async callKoboldCPP(prompt) {
            const payload = {
                prompt: prompt,
                use_story: false, use_memory: false, use_authors_note: false, use_world_info: false,
                max_context_length: 4096, max_length: 200,
                min_p: this.state.koboldcpp_min_p,
                rep_pen: 1.1, rep_pen_range: 2048, rep_pen_slope: 0.7,
                temperature: 0.65, tfs: 1, top_p: 0.92, top_k: 0, typical: 1,
                sampler_order: [6, 0, 1, 2, 3, 4, 5],
                mirostat: 2, mirostat_tau: 4, mirostat_eta: 0.1,
                dry: this.state.koboldcpp_dry,
            };
            const res = await fetch(`${this.state.koboldcpp_url}/api/v1/generate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`KoboldCPP API Error: ${errorDetails}`); }
            const data = await res.json();
            return data.results[0].text.trim();
        },
        
        setApiProvider(provider) { this.state.apiProvider = provider; this.renderSettings(); this.saveState(); },
        exportStory() { 
            const activeStory = this.library.stories.find(s => s.id === this.library.active_story_id);
            if (!activeStory) return alert("No active story to export.");
            const storyName = activeStory.name || 'Untitled_Story';
            const data = JSON.stringify(activeStory.state, null, 2); 
            const blob = new Blob([data], {type: 'application/json'}); 
            const url = URL.createObjectURL(blob); 
            const a = document.createElement('a'); 
            a.href = url; a.download = `${storyName.replace(/ /g, '_')}.json`; 
            a.click(); 
            URL.revokeObjectURL(url); 
        },
        importStory(event) { 
            const file = event.target.files[0]; 
            if (!file) return; 
            const reader = new FileReader(); 
            reader.onload = e => { 
                try { 
                    const importedState = JSON.parse(e.target.result); 
                    if (importedState.characters) { 
                        const newStory = {
                            id: this.uuid(),
                            name: file.name.replace('.json', '') || "Imported Story",
                            last_modified: new Date().toISOString(),
                            created_date: new Date().toISOString(),
                            creator_notes: '',
                            tags: [],
                            state: {...this.getDefaultState(), ...importedState}
                        };
                        this.updateSearchIndex(newStory);
                        this.library.stories.push(newStory);
                        this.updateTagCache();
                        this.saveLibrary();
                        this.renderLibraryInterface();
                        alert(`'${newStory.name}' imported successfully! You can load it from the Story Library.`);
                    } else { 
                        alert('Invalid story file.'); 
                    } 
                } catch (err) { 
                    alert(`Error importing: ${err.message}`); 
                } 
            }; 
            reader.readAsText(file); 
            event.target.value = '';
        },
        importBYAF() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.zip,.byaf';
            input.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const zip = await JSZip.loadAsync(e.target.result);
                        
                        const manifestFile = zip.file('manifest.json');
                        if (!manifestFile) throw new Error("manifest.json not found in the archive.");
                        const manifestData = JSON.parse(await manifestFile.async('string'));

                        if (!manifestData.characters || manifestData.characters.length === 0) throw new Error("No character specified in manifest.json.");
                        if (!manifestData.scenarios || manifestData.scenarios.length === 0) throw new Error("No scenario specified in manifest.json.");
                        
                        const charFilePath = manifestData.characters[0];
                        const scenarioFilePath = manifestData.scenarios[0];

                        const charFileEntry = zip.file(charFilePath);
                        const scenarioFileEntry = zip.file(scenarioFilePath);

                        if (!charFileEntry) throw new Error(`Character file not found at path: ${charFilePath}`);
                        if (!scenarioFileEntry) throw new Error(`Scenario file not found at path: ${scenarioFilePath}`);

                        const byafCharData = JSON.parse(await charFileEntry.async('string'));
                        const byafScenarioData = JSON.parse(await scenarioFileEntry.async('string'));

                        const newStoryState = this.getDefaultState();
                        const userChar = newStoryState.characters.find(c => c.is_user);
                        const characterName = byafCharData.name || "Unnamed Character";
                        
                        const newCharacter = {
                            id: this.uuid(),
                            name: characterName,
                            description: (byafCharData.persona || '').replace(/{character}/g, characterName),
                            image_url: '',
                            extra_portraits: [],
                            tags: byafCharData.tags || [],
                            is_user: false, is_active: true
                        };

                        if (byafCharData.images && Array.isArray(byafCharData.images)) {
                            const imagePromises = byafCharData.images.map(async (imgData) => {
                                const imageFileEntry = zip.file(imgData.path);
                                if (imageFileEntry) {
                                    const blob = await imageFileEntry.async('blob');
                                    const objectURL = URL.createObjectURL(blob);
                                    return { label: imgData.label, url: objectURL };
                                }
                                return null;
                            });
                            const imageDataResults = (await Promise.all(imagePromises)).filter(Boolean);
                            if (imageDataResults.length > 0) {
                                newCharacter.image_url = imageDataResults[0].url;
                                if (imageDataResults.length > 1) {
                                    newCharacter.extra_portraits = imageDataResults.slice(1).map(img => ({ emotion: img.label, url: img.url }));
                                }
                            }
                        }
                        
                        newStoryState.characters = [userChar, newCharacter];

                        if (byafScenarioData.narrative) {
                            const content = byafScenarioData.narrative.replace(/{character}/g, characterName);
                            newStoryState.world_info.push({ id: this.uuid(), title: "Narrative", content: content });
                        }
                        
                        const characterNameIdMap = {
                            [byafCharData.id.toLowerCase()]: newCharacter.id,
                            'user': userChar.id 
                        };

                        if (byafScenarioData.exampleMessages && Array.isArray(byafScenarioData.exampleMessages)) {
                            byafScenarioData.exampleMessages.forEach(msg => {
                                const speakerId = characterNameIdMap[msg.characterID.toLowerCase()];
                                if (speakerId && msg.text) {
                                    const content = msg.text.replace(/{character}/g, characterName);
                                    newStoryState.chat_history.push({ character_id: speakerId, content: content, type: 'chat', emotion: 'neutral' });
                                }
                            });
                        }

                        if (byafScenarioData.firstMessages && Array.isArray(byafScenarioData.firstMessages) && byafScenarioData.firstMessages.length > 0) {
                            const firstMsg = byafScenarioData.firstMessages[0];
                            const speakerId = characterNameIdMap[firstMsg.characterID.toLowerCase()];
                            if (speakerId && firstMsg.text) {
                                const content = firstMsg.text.replace(/{character}/g, characterName);
                                newStoryState.chat_history.push({ character_id: speakerId, content: content, type: 'chat', emotion: 'neutral' });
                            }
                        }
                        
                        if (byafScenarioData.formattingInstructions) {
                            newStoryState.system_prompt = byafScenarioData.formattingInstructions.replace(/{character}/g, characterName);
                        }

                        if (byafCharData.loreItems && Array.isArray(byafCharData.loreItems)) {
                            byafCharData.loreItems.forEach(item => {
                                newStoryState.lorebook_entries.push({ id: this.uuid(), title: item.key, triggers: item.key, content: item.value.replace(/{character}/g, characterName), triggered_at_turn: null });
                            });
                        }

                        newStoryState.messageCounter = newStoryState.chat_history.filter(m => m.type === 'chat').length;
                        
                        const newStory = {
                            id: this.uuid(), name: byafScenarioData?.title || byafCharData.displayName || `Chat with ${characterName}`,
                            last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
                            creator_notes: `[Imported from BYAF file: ${file.name}]`,
                            tags: byafCharData.tags || [],
                            state: newStoryState
                        };
                        
                        this.updateSearchIndex(newStory);
                        this.library.stories.push(newStory);
                        this.updateTagCache();
                        this.saveLibrary();
                        alert(`'${newStory.name}' imported successfully! You can now find it in your Story Library.`);
                        this.renderLibraryInterface();

                    } catch (err) {
                        alert(`Error importing BYAF file: ${err.message}`);
                        console.error(err);
                    }
                };
                reader.readAsArrayBuffer(file);
            };
            input.click();
        },
        exportLibrary() {
            const data = JSON.stringify(this.library, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_storyteller_library_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        },
        importLibrary(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                if (!confirm('WARNING: This will replace your entire story library. Are you sure you want to continue?')) {
                    return;
                }
                try {
                    const importedLibrary = JSON.parse(e.target.result);
                    if (importedLibrary.stories && importedLibrary.hasOwnProperty('active_story_id')) {
                        this.library = importedLibrary;
                        this.saveLibrary();
                        window.location.reload();
                    } else {
                        alert('Invalid library file.');
                    }
                } catch (err) {
                    alert(`Error importing library: ${err.message}`);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        },
        
        UTILITY: {
             hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) {
                    r = "0x" + hex[1] + hex[1];
                    g = "0x" + hex[2] + hex[2];
                    b = "0x" + hex[3] + hex[3];
                } else if (hex.length == 7) {
                    r = "0x" + hex[1] + hex[2];
                    g = "0x" + hex[3] + hex[4];
                    b = "0x" + hex[5] + hex[6];
                }
                return `rgba(${+r},${+g},${+b},${alpha})`;
            }
        },
        _ensureCharacterColors() {
            let aiCharCount = 0;
            this.state.characters.forEach(char => {
                if (!char.is_user) {
                     if (!char.color) {
                        char.color = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
                    }
                    aiCharCount++;
                }
            });
        },

        saveAndRender() { this.saveState(); this.renderAll(); },
        saveAndRenderWorldInfo() { this.saveState(); this.renderWorldInfo(); },
        saveAndRenderLorebook() { this.saveState(); this.renderLorebook(); },
        uuid() { return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)); },
        escapeHTML(str) { if(typeof str !== 'string') return ''; const p = document.createElement("p"); p.textContent = str; return p.innerHTML; },

        openViewRawPromptModal() {
            const selectedCharId = document.getElementById('ai-character-selector').value;
            if (!selectedCharId) {
                alert("Please select an AI character from the dropdown first.");
                return;
            }
            const prompt = this.buildPrompt(selectedCharId);
            document.getElementById('raw-prompt-content').textContent = prompt;
            this.openModal('view-raw-prompt-modal');
        }
    };

    document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>



